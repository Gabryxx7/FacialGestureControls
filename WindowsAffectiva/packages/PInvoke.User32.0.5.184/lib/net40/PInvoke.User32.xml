<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PInvoke.User32</name>
    </assembly>
    <members>
        <member name="T:PInvoke.User32">
            <content>
            Contains the <see cref="T:PInvoke.User32.ChildWindowFromPointExFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.ClassStyles"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.CURSORINFO"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.CURSORINFOFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.Cursors"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.DesktopCreationFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.DeviceContextValues"/> nested type.
            </content>
            <content>
            Contains nested type <see cref="T:PInvoke.User32.DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS"/>
            </content>
            <content>
            Contains nested type <see cref="T:PInvoke.User32.DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS"/>
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.DISPLAYCONFIG_2DREGION"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.DISPLAYCONFIG_VIDEO_SIGNAL_INFO"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.DISPLAYCONFIG_DESKTOP_IMAGE_INFO"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.DISPLAYCONFIG_MODE_INFO"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.DISPLAYCONFIG_MODE_INFO_TYPE"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.DISPLAYCONFIG_PATH_INFO"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.DISPLAYCONFIG_PATH_SOURCE_INFO"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.DISPLAYCONFIG_PATH_TARGET_INFO"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.DISPLAYCONFIG_PIXELFORMAT"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.DISPLAYCONFIG_RATIONAL"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.DISPLAYCONFIG_ROTATION"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.DISPLAYCONFIG_SCALING"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.DISPLAYCONFIG_SCANLINE_ORDERING"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.DISPLAYCONFIG_SOURCE_MODE"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.DISPLAYCONFIG_TARGET_MODE"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.DISPLAYCONFIG_TOPOLOGY_ID"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.DISPLAYCONFIG_VIDEO_SIGNAL_INFO"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.DISPLAYCONFIG_PATH_TARGET_INFO"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.DLGITEMTEMPLATE"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.DLGTEMPLATE"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.DPI_AWARENESS"/> nested type.
            </content>
            <content>
            Contains nested type <see cref="T:PInvoke.User32.DPI_HOSTING_BEHAVIOR"/>
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.DRAWTEXTPARAMS"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.FlashWindowFlags"/> nested type.
            </content>
            <content>Contains the <see cref="T:PInvoke.User32.FLASHWINFO" /> nested type.</content>
            <content>
            Contains the <see cref="T:PInvoke.User32.GetAncestorFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.GetNextWindowCommands"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.GetWindowCommands"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.HARDWAREINPUT"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.HELPINFO"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.ImageType"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.INPUT"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.InputType"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.KEYBDINPUT"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.KEYEVENTF"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.LoadImageFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.LookupIconIdFromDirectoryExFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.LUID"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.MapVirtualKeyTranslation"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.MenuItemFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.MENUITEMINFO"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.MenuItemState"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.MenuItemType"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.MenuMembersMask"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.MessageBoxOptions"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.MessageBeepType"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.MessageBoxResult"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.MONITORINFO"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.MONITORINFOEX"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.MonitorOptions"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.MOUSEEVENTF"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.MOUSEINPUT"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.mouse_eventFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.MSG"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.MSGBOXPARAMS"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.ObjectInformationType"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.PAINTSTRUCT"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.PeekMessageParams"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.PeekMessageRemoveFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="M:PInvoke.User32.PrintWindow(System.IntPtr,System.IntPtr,PInvoke.User32.PrintWindowFlags)"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.QueueStatusFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.SafeCursorHandle"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.SafeDCHandle"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.SafeDesktopHandle"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.SafeEventHookHandle"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.SafeHookHandle"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.SafeWindowStationHandle"/> nested type.
            </content>
            <content>
            Contains the Keyboard scan code constants.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.SendMessageTimeoutFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.SetWindowLongFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.SetWindowPosFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.SpecialWindowHandles"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.SysCommands"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.SystemMetric"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.SystemParametersInfoAction"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.SystemParametersInfoFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.TextFormats"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.USEROBJECTFLAGS"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.UserObjectFlagsEnum"/> nested type.
            </content>
            <content>
            Contains the virtual-key code constants.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.WINDOWINFO"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.WindowLongIndexFlags"/> nested type.
            </content>
            <content>
            Contains the Windows Messages constants.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.WINDOWPLACEMENT"/> nested type.
            </content>
            <content>Contains the <see cref="T:PInvoke.User32.WindowPlacementFlags" /> nested type.</content>
            <content>Contains the <see cref="T:PInvoke.User32.WindowsEventHookType" /> nested type.</content>
            <content>Contains the <see cref="T:PInvoke.User32.WindowsEventHookType" /> nested type.</content>
            <content>Contains the <see cref="T:PInvoke.User32.WindowsHookType" /> nested type.</content>
            <content>
            Contains the <see cref="T:PInvoke.User32.WindowShowStyle"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.WindowStationCreationFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.WindowStyles"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.WindowStylesEx"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.MINMAXINFO"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.WNDCLASS"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.User32.WNDCLASSEX"/> nested type.
            </content>
            <summary>
            Exported functions from the User32.dll Windows library.
            </summary>
            <content>
            Methods and nested types that are not strictly P/Invokes but provide
            a slightly higher level of functionality to ease calling into native code.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.ChildWindowFromPointExFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.ClassStyles"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.CURSORINFO"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.CURSORINFOFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.Cursors"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.DesktopCreationFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.DeviceContextValues"/> nested type.
            </content>
            <content>
            Contains nested type <see cref = "T:PInvoke.User32.DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS"/>
            </content>
            <content>
            Contains nested type <see cref = "T:PInvoke.User32.DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS"/>
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.DISPLAYCONFIG_2DREGION"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.DISPLAYCONFIG_VIDEO_SIGNAL_INFO"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.DISPLAYCONFIG_DESKTOP_IMAGE_INFO"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.DISPLAYCONFIG_MODE_INFO"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.DISPLAYCONFIG_MODE_INFO_TYPE"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.DISPLAYCONFIG_PATH_INFO"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.DISPLAYCONFIG_PATH_SOURCE_INFO"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.DISPLAYCONFIG_PATH_TARGET_INFO"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.DISPLAYCONFIG_PIXELFORMAT"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.DISPLAYCONFIG_RATIONAL"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.DISPLAYCONFIG_ROTATION"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.DISPLAYCONFIG_SCALING"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.DISPLAYCONFIG_SCANLINE_ORDERING"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.DISPLAYCONFIG_SOURCE_MODE"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.DISPLAYCONFIG_TARGET_MODE"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.DISPLAYCONFIG_TOPOLOGY_ID"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.DISPLAYCONFIG_VIDEO_SIGNAL_INFO"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.DISPLAYCONFIG_PATH_TARGET_INFO"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.DLGITEMTEMPLATE"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.DLGTEMPLATE"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.DPI_AWARENESS"/> nested type.
            </content>
            <content>
            Contains nested type <see cref = "T:PInvoke.User32.DPI_HOSTING_BEHAVIOR"/>
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.DRAWTEXTPARAMS"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.FlashWindowFlags"/> nested type.
            </content>
            <content>Contains the <see cref = "T:PInvoke.User32.FLASHWINFO"/> nested type.</content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.GetAncestorFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.GetNextWindowCommands"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.GetWindowCommands"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.HARDWAREINPUT"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.HELPINFO"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.ImageType"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.INPUT"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.InputType"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.KEYBDINPUT"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.KEYEVENTF"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.LoadImageFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.LookupIconIdFromDirectoryExFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.LUID"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.MapVirtualKeyTranslation"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.MenuItemFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.MENUITEMINFO"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.MenuItemState"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.MenuItemType"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.MenuMembersMask"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.MessageBoxOptions"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.MessageBeepType"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.MessageBoxResult"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.MONITORINFO"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.MONITORINFOEX"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.MonitorOptions"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.MOUSEEVENTF"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.MOUSEINPUT"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.mouse_eventFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.MSG"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.MSGBOXPARAMS"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.ObjectInformationType"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.PAINTSTRUCT"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.PeekMessageParams"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.PeekMessageRemoveFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "M:PInvoke.User32.PrintWindow(System.IntPtr,System.IntPtr,PInvoke.User32.PrintWindowFlags)"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.QueueStatusFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.SafeCursorHandle"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.SafeDCHandle"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.SafeDesktopHandle"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.SafeEventHookHandle"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.SafeHookHandle"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.SafeWindowStationHandle"/> nested type.
            </content>
            <content>
            Contains the Keyboard scan code constants.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.SendMessageTimeoutFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.SetWindowLongFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.SetWindowPosFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.SpecialWindowHandles"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.SysCommands"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.SystemMetric"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.SystemParametersInfoAction"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.SystemParametersInfoFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.TextFormats"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.USEROBJECTFLAGS"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.UserObjectFlagsEnum"/> nested type.
            </content>
            <content>
            Contains the virtual-key code constants.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.WINDOWINFO"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.WindowLongIndexFlags"/> nested type.
            </content>
            <content>
            Contains the Windows Messages constants.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.WINDOWPLACEMENT"/> nested type.
            </content>
            <content>Contains the <see cref = "T:PInvoke.User32.WindowPlacementFlags"/> nested type.</content>
            <content>Contains the <see cref = "T:PInvoke.User32.WindowsEventHookType"/> nested type.</content>
            <content>Contains the <see cref = "T:PInvoke.User32.WindowsEventHookType"/> nested type.</content>
            <content>Contains the <see cref = "T:PInvoke.User32.WindowsHookType"/> nested type.</content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.WindowShowStyle"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.WindowStationCreationFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.WindowStyles"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.WindowStylesEx"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.MINMAXINFO"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.WNDCLASS"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.User32.WNDCLASSEX"/> nested type.
            </content>
            <summary>
            Exported functions from the User32.dll Windows library.
            </summary>
            <content>
            Methods and nested types that are not strictly P/Invokes but provide
            a slightly higher level of functionality to ease calling into native code.
            </content>
        </member>
        <member name="T:PInvoke.User32.ChildWindowFromPointExFlags">
            <summary>
            For use with <see cref="M:PInvoke.User32.ChildWindowFromPointEx(System.IntPtr,PInvoke.POINT,PInvoke.User32.ChildWindowFromPointExFlags)"/>
            </summary>
        </member>
        <member name="F:PInvoke.User32.ChildWindowFromPointExFlags.CWP_ALL">
            <summary>
            Does not skip any child windows
            </summary>
        </member>
        <member name="F:PInvoke.User32.ChildWindowFromPointExFlags.CWP_SKIPINVISIBLE">
            <summary>
            Skips invisible child windows
            </summary>
        </member>
        <member name="F:PInvoke.User32.ChildWindowFromPointExFlags.CWP_SKIPDISABLED">
            <summary>
            Skips disabled child windows
            </summary>
        </member>
        <member name="F:PInvoke.User32.ChildWindowFromPointExFlags.CWP_SKIPTRANSPARENT">
            <summary>
            Skips transparent child windows
            </summary>
        </member>
        <member name="F:PInvoke.User32.ClassStyles.CS_BYTEALIGNCLIENT">
            <summary>
            Aligns the window's client area on a byte boundary (in the x direction). This style
            affects the width of the window and its horizontal placement on the display.
            </summary>
        </member>
        <member name="F:PInvoke.User32.ClassStyles.CS_BYTEALIGNWINDOW">
            <summary>
            Aligns the window on a byte boundary (in the x direction). This style affects the width
            of the window and its horizontal placement on the display.
            </summary>
        </member>
        <member name="F:PInvoke.User32.ClassStyles.CS_CLASSDC">
            <summary>
            Allocates one device context to be shared by all windows in the class. Because window
            classes are process specific, it is possible for multiple threads of an application to
            create a window of the same class. It is also possible for the threads to attempt to use
            the device context simultaneously. When this happens, the system allows only one thread
            to successfully finish its drawing operation.
            </summary>
        </member>
        <member name="F:PInvoke.User32.ClassStyles.CS_DBLCLKS">
            <summary>
            Sends a double-click message to the window procedure when the user double-clicks the
            mouse while the cursor is within a window belonging to the class.
            </summary>
        </member>
        <member name="F:PInvoke.User32.ClassStyles.CS_DROPSHADOW">
            <summary>
            Enables the drop shadow effect on a window. The effect is turned on and off through
            SPI_SETDROPSHADOW. Typically, this is enabled for small, short-lived windows such as
            menus to emphasize their Z order relationship to other windows.
            </summary>
        </member>
        <member name="F:PInvoke.User32.ClassStyles.CS_GLOBALCLASS">
            <summary>
            Indicates that the window class is an application global class.
            </summary>
        </member>
        <member name="F:PInvoke.User32.ClassStyles.CS_HREDRAW">
            <summary>
            Redraws the entire window if a movement or size adjustment changes the width of the
            client area.
            </summary>
        </member>
        <member name="F:PInvoke.User32.ClassStyles.CS_NOCLOSE">
            <summary>
            Disables Close on the window menu.
            </summary>
        </member>
        <member name="F:PInvoke.User32.ClassStyles.CS_OWNDC">
            <summary>
            Allocates a unique device context for each window in the class.
            </summary>
        </member>
        <member name="F:PInvoke.User32.ClassStyles.CS_PARENTDC">
            <summary>
            Sets the clipping rectangle of the child window to that of the parent window so that the
            child can draw on the parent. A window with the CS_PARENTDC style bit receives a regular
            device context from the system's cache of device contexts. It does not give the child the
            parent's device context or device context settings. Specifying CS_PARENTDC enhances an
            application's performance.
            </summary>
        </member>
        <member name="F:PInvoke.User32.ClassStyles.CS_SAVEBITS">
            <summary>
            Saves, as a bitmap, the portion of the screen image obscured by a window of this class.
            When the window is removed, the system uses the saved bitmap to restore the screen image,
            including other windows that were obscured. Therefore, the system does not send WM_PAINT
            messages to windows that were obscured if the memory used by the bitmap has not been
            discarded and if other screen actions have not invalidated the stored image. This style
            is useful for small windows (for example, menus or dialog
            boxes) that are displayed briefly and then removed before other screen activity takes
            place. This style increases the time required to display the window, because the system
            must first allocate memory to store the bitmap.
            </summary>
        </member>
        <member name="F:PInvoke.User32.ClassStyles.CS_VREDRAW">
            <summary>
            Redraws the entire window if a movement or size adjustment changes the height of the
            client area.
            </summary>
        </member>
        <member name="T:PInvoke.User32.CURSORINFO">
            <summary>
            Contains global cursor information.
            </summary>
        </member>
        <member name="F:PInvoke.User32.CURSORINFO.cbSize">
            <summary>
            The size of the structure, in bytes. The caller must set this to sizeof(CURSORINFO).
            </summary>
        </member>
        <member name="F:PInvoke.User32.CURSORINFO.flags">
            <summary>
            The cursor state.
            </summary>
        </member>
        <member name="F:PInvoke.User32.CURSORINFO.hCursor">
            <summary>
            A handle to the cursor. An HCURSOR. Consider exposing as an <see cref="T:PInvoke.User32.SafeCursorHandle" />.
            </summary>
        </member>
        <member name="F:PInvoke.User32.CURSORINFO.ptScreenPos">
            <summary>
            A structure that receives the screen coordinates of the cursor.
            </summary>
        </member>
        <member name="M:PInvoke.User32.CURSORINFO.Create">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.User32.CURSORINFO" /> struct
            with the <see cref="F:PInvoke.User32.CURSORINFO.cbSize" /> field initialized.
            </summary>
            <returns>
            An instance of the structure.
            </returns>
        </member>
        <member name="T:PInvoke.User32.CURSORINFOFlags">
            <summary>
            Flags for the <see cref="F:PInvoke.User32.CURSORINFO.flags" /> field.
            </summary>
        </member>
        <member name="F:PInvoke.User32.CURSORINFOFlags.CURSOR_HIDDEN">
            <summary>The cursor is hidden.</summary>
        </member>
        <member name="F:PInvoke.User32.CURSORINFOFlags.CURSOR_SHOWING">
            <summary>The cursor is showing.</summary>
        </member>
        <member name="F:PInvoke.User32.CURSORINFOFlags.CURSOR_SUPPRESSED">
            <summary>
            Windows 8: The cursor is suppressed. This flag indicates that the system is not drawing the cursor because the user is providing input through touch or pen instead of the mouse.
            </summary>
        </member>
        <member name="T:PInvoke.User32.Cursors">
            <summary>
            Represents system predefined cursors.
            </summary>
        </member>
        <member name="F:PInvoke.User32.Cursors.IDC_APPSTARTING">
            <summary>Standard arrow and small hourglass</summary>
        </member>
        <member name="F:PInvoke.User32.Cursors.IDC_ARROW">
            <summary>Standard arrow</summary>
        </member>
        <member name="F:PInvoke.User32.Cursors.IDC_CROSS">
            <summary>Crosshair</summary>
        </member>
        <member name="F:PInvoke.User32.Cursors.IDC_HAND">
            <summary>Hand</summary>
        </member>
        <member name="F:PInvoke.User32.Cursors.IDC_HELP">
            <summary>Arrow and question mark</summary>
        </member>
        <member name="F:PInvoke.User32.Cursors.IDC_IBEAM">
            <summary>I-beam</summary>
        </member>
        <member name="F:PInvoke.User32.Cursors.IDC_ICON">
            <summary>Obsolete for applications marked version 4.0 or later.</summary>
        </member>
        <member name="F:PInvoke.User32.Cursors.IDC_NO">
            <summary>Slashed circle</summary>
        </member>
        <member name="F:PInvoke.User32.Cursors.IDC_SIZE">
            <summary>Obsolete for applications marked version 4.0 or later. Use IDC_SIZEALL.</summary>
        </member>
        <member name="F:PInvoke.User32.Cursors.IDC_SIZEALL">
            <summary>Four-pointed arrow pointing north, south, east, and west</summary>
        </member>
        <member name="F:PInvoke.User32.Cursors.IDC_SIZENESW">
            <summary>Double-pointed arrow pointing northeast and southwest</summary>
        </member>
        <member name="F:PInvoke.User32.Cursors.IDC_SIZENS">
            <summary>Double-pointed arrow pointing north and south</summary>
        </member>
        <member name="F:PInvoke.User32.Cursors.IDC_SIZENWSE">
            <summary>Double-pointed arrow pointing northwest and southeast</summary>
        </member>
        <member name="F:PInvoke.User32.Cursors.IDC_SIZEWE">
            <summary>Double-pointed arrow pointing west and east</summary>
        </member>
        <member name="F:PInvoke.User32.Cursors.IDC_UPARROW">
            <summary>Vertical arrow</summary>
        </member>
        <member name="F:PInvoke.User32.Cursors.IDC_WAIT">
            <summary>Hourglass</summary>
        </member>
        <member name="T:PInvoke.User32.DesktopCreationFlags">
            <summary>
            Controls the access of other processes to the created desktop
            </summary>
        </member>
        <member name="F:PInvoke.User32.DesktopCreationFlags.DF_ALLOWOTHERACCOUNTHOOK">
            <summary>
            Enables processes running in other accounts on the desktop to set hooks in this process
            </summary>
        </member>
        <member name="T:PInvoke.User32.DeviceContextValues">
            <summary>
            Values to pass to the <see cref="M:PInvoke.User32.GetDCEx(System.IntPtr,System.IntPtr,PInvoke.User32.DeviceContextValues)"/> method describing how to create the DC.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DeviceContextValues.DCX_WINDOW">
            <summary>
            Returns a DC that corresponds to the window rectangle rather than the client rectangle.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DeviceContextValues.DCX_CACHE">
            <summary>
            Returns a DC from the cache, rather than the OWNDC or CLASSDC window.
            Essentially overrides CS_OWNDC and CS_CLASSDC.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DeviceContextValues.DCX_NORESETATTRS">
            <summary>
            Does not reset the attributes of this DC to the default attributes when this DC is released.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DeviceContextValues.DCX_CLIPCHILDREN">
            <summary>
            Excludes the visible regions of all child windows below the window identified by hWnd.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DeviceContextValues.DCX_CLIPSIBLINGS">
            <summary>
            Excludes the visible regions of all sibling windows above the window identified by hWnd.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DeviceContextValues.DCX_PARENTCLIP">
            <summary>
            Uses the visible region of the parent window. The parent's WS_CLIPCHILDREN and CS_PARENTDC style bits are ignored.
            The origin is set to the upper-left corner of the window identified by hWnd.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DeviceContextValues.DCX_EXCLUDERGN">
            <summary>
            The clipping region identified by hrgnClip is excluded from the visible region of the returned DC.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DeviceContextValues.DCX_INTERSECTRGN">
            <summary>
            The clipping region identified by hrgnClip is intersected with the visible region of the returned DC.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DeviceContextValues.DCX_EXCLUDEUPDATE">
            <summary>
            Undocumented
            </summary>
            <remarks>Reserved; do not use.</remarks>
        </member>
        <member name="F:PInvoke.User32.DeviceContextValues.DCX_INTERSECTUPDATE">
            <summary>
            Returns a region that includes the window's update region.
            </summary>
            <remarks>Reserved; do not use (it is documented on Windows CE GetDCEx function on MSDN).</remarks>
        </member>
        <member name="F:PInvoke.User32.DeviceContextValues.DCX_LOCKWINDOWUPDATE">
            <summary>
            Allows drawing even if there is a LockWindowUpdate call in effect
            that would otherwise exclude this window. Used for drawing during tracking.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DeviceContextValues.DCX_USESTYLE">
            <summary>
            Undocumented, something internal related to WM_NCPAINT message and not using <see cref="F:PInvoke.User32.DeviceContextValues.DCX_CACHE"/> on updates.
            </summary>
            <remarks>Internal; do not use</remarks>
        </member>
        <member name="F:PInvoke.User32.DeviceContextValues.DCX_VALIDATE">
            <summary>
            When specified with <see cref="F:PInvoke.User32.DeviceContextValues.DCX_INTERSECTUPDATE"/>, causes the DC to be completely validated.
            Using this function with both <see cref="F:PInvoke.User32.DeviceContextValues.DCX_INTERSECTUPDATE"/> and <see cref="F:PInvoke.User32.DeviceContextValues.DCX_VALIDATE"/> is identical to using the <see cref="M:PInvoke.User32.BeginPaint(System.IntPtr,PInvoke.User32.PAINTSTRUCT*)"/> function.
            </summary>
            <remarks>Reserved; do not use (it is documented on Windows CE GetDCEx function on MSDN).</remarks>
        </member>
        <member name="T:PInvoke.User32.DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS">
             <summary>
             Describes per-monitor DPI scaling behavior overrides for child windows within dialogs. The values in this enumeration are bitfields and can be combined.
             </summary>
             <remarks>
             This enum is used with SetDialogControlDpiChangeBehavior in order to override the default per-monitor DPI scaling behavior for a child window within a dialog.
            
             These settings only apply to individual controls within dialogs. The dialog-wide per-monitor DPI scaling behavior of a dialog is controlled by <see cref="T:PInvoke.User32.DIALOG_DPI_CHANGE_BEHAVIORS"/>.
             </remarks>
        </member>
        <member name="F:PInvoke.User32.DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS.DCDC_DEFAULT">
            <summary>
            The default behavior of the dialog manager. The dialog managed will update the font, size, and position of the child window on DPI changes.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS.DCDC_DISABLE_FONT_UPDATE">
            <summary>
            Prevents the dialog manager from sending an updated font to the child window via WM_SETFONT in response to a DPI change.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS.DCDC_DISABLE_RELAYOUT">
            <summary>
            Prevents the dialog manager from resizing and repositioning the child window in response to a DPI change.
            </summary>
        </member>
        <member name="T:PInvoke.User32.DIALOG_DPI_CHANGE_BEHAVIORS">
            <summary>
            In Per Monitor v2 contexts, dialogs will automatically respond to DPI changes by resizing themselves and re-computing the positions of their child windows (here referred to as re-layouting).
            This enum works in conjunction with SetDialogDpiChangeBehavior in order to override the default DPI scaling behavior for dialogs.
            This does not affect DPI scaling behavior for the child windows of dialogs(beyond re-layouting), which is controlled by <see cref="T:PInvoke.User32.DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS"/>.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DIALOG_DPI_CHANGE_BEHAVIORS.DDC_DEFAULT">
            <summary>
            The default behavior of the dialog manager. In response to a DPI change, the dialog manager will re-layout each control, update the font on each control, resize the dialog, and update the dialog's own font.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DIALOG_DPI_CHANGE_BEHAVIORS.DDC_DISABLE_ALL">
            <summary>
            Prevents the dialog manager from responding to <see cref="F:PInvoke.User32.WindowMessage.WM_GETDPISCALEDSIZE"/> and <see cref="F:PInvoke.User32.WindowMessage.WM_DPICHANGED"/>, disabling all default DPI scaling behavior.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DIALOG_DPI_CHANGE_BEHAVIORS.DDC_DISABLE_RESIZE">
            <summary>
            Prevents the dialog manager from resizing the dialog in response to a DPI change.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DIALOG_DPI_CHANGE_BEHAVIORS.DDC_DISABLE_CONTROL_RELAYOUT">
            <summary>
            Prevents the dialog manager from re-layouting all of the dialogue's immediate children HWNDs in response to a DPI change.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DISPLAYCONFIG_PATH_SOURCE_INFOFlags.DISPLAYCONFIG_SOURCE_IN_USE">
            <summary>
            This source is in use by at least one active path.
            </summary>
        </member>
        <member name="T:PInvoke.User32.DLGITEMTEMPLATE">
            <summary>
                Defines the dimensions and style of a control in a dialog box. One or more of these structures are combined with a
                <see cref="T:PInvoke.User32.DLGTEMPLATE" /> structure to form a standard template for a dialog box.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DLGITEMTEMPLATE.style">
            <summary>
                The style of the control. This member can be a combination of window style values (such as WS_BORDER) and one or
                more of the control style values (such as BS_PUSHBUTTON and ES_LEFT).
            </summary>
        </member>
        <member name="F:PInvoke.User32.DLGITEMTEMPLATE.dwExtendedStyle">
            <summary>
                The extended styles for a window. This member is not used to create controls in dialog boxes, but applications that
                use dialog box templates can use it to create other types of windows.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DLGITEMTEMPLATE.x">
            <summary>
                The x-coordinate, in dialog box units, of the upper-left corner of the control. This coordinate is always relative
                to the upper-left corner of the dialog box's client area.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DLGITEMTEMPLATE.y">
            <summary>
                The y-coordinate, in dialog box units, of the upper-left corner of the control. This coordinate is always relative
                to the upper-left corner of the dialog box's client area.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DLGITEMTEMPLATE.cx">
            <summary>
                The width, in dialog box units, of the control.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DLGITEMTEMPLATE.cy">
            <summary>
                The height, in dialog box units, of the control.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DLGITEMTEMPLATE.id">
            <summary>
                The control identifier.
            </summary>
        </member>
        <member name="T:PInvoke.User32.DLGTEMPLATE">
            <summary>
                Defines the dimensions and style of a dialog box. This structure, always the first in a standard template for a
                dialog box, also specifies the number of controls in the dialog box and therefore specifies the number of
                subsequent <see cref="T:PInvoke.User32.DLGITEMTEMPLATE" /> structures in the template.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DLGTEMPLATE.style">
            <summary>
                The style of the dialog box. This member can be a combination of window style values (such as WS_CAPTION and
                WS_SYSMENU) and dialog box style values (such as DS_CENTER).
                <para>
                    If the style member includes the DS_SETFONT style, the header of the dialog box template contains additional
                    data specifying the font to use for text in the client area and controls of the dialog box. The font data
                    begins on the WORD boundary that follows the title array. The font data specifies a 16-bit point size value and
                    a Unicode font name string. If possible, the system creates a font according to the specified values. Then the
                    system sends a WM_SETFONT message to the dialog box and to each control to provide a handle to the font. If
                    DS_SETFONT is not specified, the dialog box template does not include the font data.
                </para>
                <para>The DS_SHELLFONT style is not supported in the DLGTEMPLATE header.</para>
            </summary>
        </member>
        <member name="F:PInvoke.User32.DLGTEMPLATE.dwExtendedStyle">
            <summary>
                The extended styles for a window. This member is not used to create dialog boxes, but applications that use dialog
                box templates can use it to create other types of windows.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DLGTEMPLATE.cdit">
            <summary>
                The number of items in the dialog box.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DLGTEMPLATE.x">
            <summary>
                The x-coordinate, in dialog box units, of the upper-left corner of the dialog box.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DLGTEMPLATE.y">
            <summary>
                The y-coordinate, in dialog box units, of the upper-left corner of the dialog box.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DLGTEMPLATE.cx">
            <summary>
                The width, in dialog box units, of the dialog box.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DLGTEMPLATE.cy">
            <summary>
                The height, in dialog box units, of the dialog box.
            </summary>
        </member>
        <member name="T:PInvoke.User32.DPI_AWARENESS">
            <summary>
            Identifies the dots per inch (dpi) setting for a thread, process, or window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DPI_AWARENESS.DPI_AWARENESS_INVALID">
            <summary>
            Invalid DPI awareness. This is an invalid DPI awareness value.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DPI_AWARENESS.DPI_AWARENESS_UNAWARE">
            <summary>
            DPI unaware. This process does not scale for DPI changes and is always assumed to have a scale factor of 100% (96 DPI). It will be automatically scaled by the system on any other DPI setting.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DPI_AWARENESS.DPI_AWARENESS_SYSTEM_AWARE">
            <summary>
            System DPI aware. This process does not scale for DPI changes. It will query for the DPI once and use that value for the lifetime of the process. If the DPI changes, the process will not adjust to the new DPI value. It will be automatically scaled up or down by the system when the DPI changes from the system value.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DPI_AWARENESS.DPI_AWARENESS_PER_MONITOR_AWARE">
            <summary>
            Per monitor DPI aware. This process checks for the DPI when it is created and adjusts the scale factor whenever the DPI changes. These processes are not automatically scaled by the system.
            </summary>
        </member>
        <member name="T:PInvoke.User32.DPI_HOSTING_BEHAVIOR">
            <summary>
            Identifies the DPI hosting behavior for a window. This behavior allows windows created in the thread to host child windows with a different DPI_AWARENESS_CONTEXT.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DPI_HOSTING_BEHAVIOR.DPI_HOSTING_BEHAVIOR_INVALID">
            <summary>
            Invalid DPI hosting behavior. This usually occurs if the previous <see cref="M:PInvoke.User32.SetThreadDpiHostingBehavior(PInvoke.User32.DPI_HOSTING_BEHAVIOR)"/> call used an invalid parameter.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DPI_HOSTING_BEHAVIOR.DPI_HOSTING_BEHAVIOR_DEFAULT">
            <summary>
            Default DPI hosting behavior. The associated window behaves as normal, and cannot create or re-parent child windows with a different DPI_AWARENESS_CONTEXT.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DPI_HOSTING_BEHAVIOR.DPI_HOSTING_BEHAVIOR_MIXED">
            <summary>
            Mixed DPI hosting behavior. This enables the creation and re-parenting of child windows with different DPI_AWARENESS_CONTEXT. These child windows will be independently scaled by the OS.
            </summary>
        </member>
        <member name="T:PInvoke.User32.DRAWTEXTPARAMS">
            <summary>
            Values to pass to the <see cref="M:PInvoke.User32.DrawTextEx(PInvoke.User32.SafeDCHandle,System.Char*,System.Int32,PInvoke.RECT*,System.UInt32,PInvoke.User32.DRAWTEXTPARAMS*)"/> method describing extended formatting options for the text.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DRAWTEXTPARAMS.cbSize">
            <summary>
            The structure size, in bytes.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DRAWTEXTPARAMS.iTabLength">
            <summary>
            The size of each tab stop, in units equal to the average character width.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DRAWTEXTPARAMS.iLeftMargin">
            <summary>
            The left margin, in units equal to the average character width.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DRAWTEXTPARAMS.iRightMargin">
            <summary>
            The right margin, in units equal to the average character width.
            </summary>
        </member>
        <member name="F:PInvoke.User32.DRAWTEXTPARAMS.uiLengthDrawn">
            <summary>
            Receives the number of characters processed by <see cref="M:PInvoke.User32.DrawTextEx(PInvoke.User32.SafeDCHandle,System.Char*,System.Int32,PInvoke.RECT*,System.UInt32,PInvoke.User32.DRAWTEXTPARAMS*)"/>,
            including white-space characters. The number can be the length of the string or the index of the first line that falls below the drawing area.
            Note that <see cref="M:PInvoke.User32.DrawTextEx(PInvoke.User32.SafeDCHandle,System.Char*,System.Int32,PInvoke.RECT*,System.UInt32,PInvoke.User32.DRAWTEXTPARAMS*)"/> always processes the entire string if the <see cref="F:PInvoke.User32.TextFormats.DT_NOCLIP"/> formatting flag is specified.
            </summary>
        </member>
        <member name="T:PInvoke.User32.FlashWindowFlags">
            <summary>The flash status stored in <see cref="T:PInvoke.User32.FLASHWINFO" /> and used in <see cref="M:PInvoke.User32.FlashWindowEx(PInvoke.User32.FLASHWINFO@)" />.</summary>
        </member>
        <member name="F:PInvoke.User32.FlashWindowFlags.FLASHW_ALL">
            <summary>
                Flash both the window caption and taskbar button. This is equivalent to setting the FLASHW_CAPTION |
                FLASHW_TRAY flags.
            </summary>
        </member>
        <member name="F:PInvoke.User32.FlashWindowFlags.FLASHW_CAPTION">
            <summary>Flash the window caption.</summary>
        </member>
        <member name="F:PInvoke.User32.FlashWindowFlags.FLASHW_STOP">
            <summary>Stop flashing. The system restores the window to its original state.</summary>
        </member>
        <member name="F:PInvoke.User32.FlashWindowFlags.FLASHW_TIMER">
            <summary>Flash continuously, until the <see cref="F:PInvoke.User32.FlashWindowFlags.FLASHW_STOP" /> flag is set.</summary>
        </member>
        <member name="F:PInvoke.User32.FlashWindowFlags.FLASHW_TIMERNOFG">
            <summary>Flash continuously until the window comes to the foreground.</summary>
        </member>
        <member name="F:PInvoke.User32.FlashWindowFlags.FLASHW_TRAY">
            <summary>Flash the taskbar button.</summary>
        </member>
        <member name="T:PInvoke.User32.FLASHWINFO">
            <summary>
                Contains the flash status for a window and the number of times the system should flash the window. Used in
                <see cref="M:PInvoke.User32.FlashWindowEx(PInvoke.User32.FLASHWINFO@)" />.
            </summary>
        </member>
        <member name="F:PInvoke.User32.FLASHWINFO.cbSize">
            <summary>The size of the structure, in bytes.</summary>
        </member>
        <member name="F:PInvoke.User32.FLASHWINFO.hwnd">
            <summary>A handle to the window to be flashed. The window can be either opened or minimized.</summary>
        </member>
        <member name="F:PInvoke.User32.FLASHWINFO.dwFlags">
            <summary>The flash status</summary>
        </member>
        <member name="F:PInvoke.User32.FLASHWINFO.uCount">
            <summary>The number of times to flash the window.</summary>
        </member>
        <member name="F:PInvoke.User32.FLASHWINFO.dwTimeout">
            <summary>
                The rate at which the window is to be flashed, in milliseconds. If <see cref="F:PInvoke.User32.FLASHWINFO.dwTimeout"/> is zero, the
                function uses the default cursor blink rate.
            </summary>
        </member>
        <member name="M:PInvoke.User32.FLASHWINFO.Create">
            <summary>
            Create a new instance of <see cref="T:PInvoke.User32.FLASHWINFO"/> with <see cref="F:PInvoke.User32.FLASHWINFO.cbSize"/> set to the correct value.
            </summary>
            <returns>A new instance of <see cref="T:PInvoke.User32.FLASHWINFO"/> with <see cref="F:PInvoke.User32.FLASHWINFO.cbSize"/> set to the correct value.</returns>
        </member>
        <member name="T:PInvoke.User32.GetAncestorFlags">
            <summary>The ancestor to be retrieved by <see cref="M:PInvoke.User32.GetAncestor(System.IntPtr,PInvoke.User32.GetAncestorFlags)" />.</summary>
        </member>
        <member name="F:PInvoke.User32.GetAncestorFlags.GA_PARENT">
            <summary>Retrieves the parent window. This does not include the owner, as it does with the GetParent function.</summary>
        </member>
        <member name="F:PInvoke.User32.GetAncestorFlags.GA_ROOT">
            <summary>Retrieves the root window by walking the chain of parent windows.</summary>
        </member>
        <member name="F:PInvoke.User32.GetAncestorFlags.GA_ROOTOWNER">
            <summary>Retrieves the owned root window by walking the chain of parent and owner windows returned by GetParent.</summary>
        </member>
        <member name="T:PInvoke.User32.GetNextWindowCommands">
            <summary>The commands that can be used as arguments to <see cref="M:PInvoke.User32.GetNextWindow(System.IntPtr,PInvoke.User32.GetNextWindowCommands)" />.</summary>
        </member>
        <member name="F:PInvoke.User32.GetNextWindowCommands.GW_HWNDNEXT">
            <summary>Returns a handle to the window below the given window.</summary>
        </member>
        <member name="F:PInvoke.User32.GetNextWindowCommands.GW_HWNDPREV">
            <summary>Returns a handle to the window above the given window.</summary>
        </member>
        <member name="T:PInvoke.User32.GetWindowCommands">
            <summary>The commands that can be used as arguments to <see cref="M:PInvoke.User32.GetWindow(System.IntPtr,PInvoke.User32.GetWindowCommands)" />.</summary>
        </member>
        <member name="F:PInvoke.User32.GetWindowCommands.GW_HWNDFIRST">
            <summary>
            The retrieved handle identifies the window of the same type that is highest in the Z order.
            If the specified window is a topmost window, the handle identifies a topmost window. If the specified window is a top-level window, the handle identifies a top-level window. If the specified window is a child window, the handle identifies a sibling window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.GetWindowCommands.GW_HWNDLAST">
            <summary>
            The retrieved handle identifies the window of the same type that is lowest in the Z order.
            If the specified window is a topmost window, the handle identifies a topmost window. If the specified window is a top-level window, the handle identifies a top-level window. If the specified window is a child window, the handle identifies a sibling window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.GetWindowCommands.GW_HWNDNEXT">
            <summary>Returns a handle to the window below the given window.</summary>
        </member>
        <member name="F:PInvoke.User32.GetWindowCommands.GW_HWNDPREV">
            <summary>Returns a handle to the window above the given window.</summary>
        </member>
        <member name="F:PInvoke.User32.GetWindowCommands.GW_OWNER">
            <summary>The retrieved handle identifies the specified window's owner window, if any. For more information, see Owned Windows.</summary>
        </member>
        <member name="F:PInvoke.User32.GetWindowCommands.GW_CHILD">
            <summary>The retrieved handle identifies the child window at the top of the Z order, if the specified window is a parent window; otherwise, the retrieved handle is NULL. The function examines only child windows of the specified window. It does not examine descendant windows.</summary>
        </member>
        <member name="F:PInvoke.User32.GetWindowCommands.GW_ENABLEDPOPUP">
            <summary>The retrieved handle identifies the enabled popup window owned by the specified window (the search uses the first such window found using <see cref="F:PInvoke.User32.GetWindowCommands.GW_HWNDNEXT" />); otherwise, if there are no enabled popup windows, the retrieved handle is that of the specified window.</summary>
        </member>
        <member name="T:PInvoke.User32.HARDWAREINPUT">
            <summary>
            Contains information about a simulated message generated by an input device other than a keyboard or mouse.
            </summary>
        </member>
        <member name="F:PInvoke.User32.HARDWAREINPUT.uMsg">
            <summary>
            The message generated by the input hardware.
            </summary>
        </member>
        <member name="F:PInvoke.User32.HARDWAREINPUT.wParamL">
            <summary>
            The low-order word of the lParam parameter for <see cref="F:PInvoke.User32.HARDWAREINPUT.uMsg"/>.
            </summary>
        </member>
        <member name="F:PInvoke.User32.HARDWAREINPUT.wParamH">
            <summary>
            The high-order word of the lParam parameter for <see cref="F:PInvoke.User32.HARDWAREINPUT.uMsg"/>.
            </summary>
        </member>
        <member name="T:PInvoke.User32.ImageType">
            <summary>
            Represents various image types.
            </summary>
        </member>
        <member name="F:PInvoke.User32.ImageType.IMAGE_BITMAP">
            <summary>
            Loads a bitmap.
            </summary>
        </member>
        <member name="F:PInvoke.User32.ImageType.IMAGE_ICON">
            <summary>
            Loads an icon.
            </summary>
        </member>
        <member name="F:PInvoke.User32.ImageType.IMAGE_CURSOR">
            <summary>
            Loads a cursor.
            </summary>
        </member>
        <member name="T:PInvoke.User32.INPUT">
            <summary>
            Used by <see cref="M:PInvoke.User32.SendInput(System.Int32,PInvoke.User32.INPUT*,System.Int32)"/> to store information for synthesizing input events such as keystrokes, mouse movement, and mouse clicks.
            </summary>
        </member>
        <member name="F:PInvoke.User32.INPUT.type">
            <summary>
            The type of the input event.
            </summary>
        </member>
        <member name="F:PInvoke.User32.INPUT.Inputs">
            <summary>
            The union of mouse, keyboard and hardware input.
            </summary>
        </member>
        <member name="T:PInvoke.User32.INPUT.InputUnion">
            <summary>
            Describes some kind of input.
            </summary>
            <remarks>
            This struct is a union where all fields share memory address space.
            </remarks>
            <devremarks>
            From http://www.pinvoke.net/default.aspx/Structures/INPUT.html:
            The last 3 fields are a union, which is why they are all at the same memory offset.
            On 64-Bit systems, the offset of the <see cref="F:PInvoke.User32.INPUT.InputUnion.mi"/>, <see cref="F:PInvoke.User32.INPUT.InputUnion.ki"/> and <see cref="F:PInvoke.User32.INPUT.InputUnion.hi"/> fields is 8,
            because the nested struct uses the alignment of its biggest member, which is 8
            (due to the 64-bit pointer in <see cref="F:PInvoke.User32.KEYBDINPUT.dwExtraInfo"/>).
            By separating the union into its own structure, rather than placing the
            <see cref="F:PInvoke.User32.INPUT.InputUnion.mi"/>, <see cref="F:PInvoke.User32.INPUT.InputUnion.ki"/> and <see cref="F:PInvoke.User32.INPUT.InputUnion.hi"/> fields directly in the INPUT structure,
            we assure that the .NET structure will have the correct alignment on both 32 and 64 bit.
            </devremarks>
        </member>
        <member name="F:PInvoke.User32.INPUT.InputUnion.mi">
            <summary>
            The information about a simulated mouse event.
            This field shares memory with the <see cref="F:PInvoke.User32.INPUT.InputUnion.ki"/> and <see cref="F:PInvoke.User32.INPUT.InputUnion.hi"/> fields.
            </summary>
        </member>
        <member name="F:PInvoke.User32.INPUT.InputUnion.ki">
            <summary>
            The information about a simulated keyboard event.
            This field shares memory with the <see cref="F:PInvoke.User32.INPUT.InputUnion.mi"/> and <see cref="F:PInvoke.User32.INPUT.InputUnion.hi"/> fields.
            </summary>
        </member>
        <member name="F:PInvoke.User32.INPUT.InputUnion.hi">
            <summary>
            The information about a simulated hardware event.
            This field shares memory with the <see cref="F:PInvoke.User32.INPUT.InputUnion.mi"/> and <see cref="F:PInvoke.User32.INPUT.InputUnion.ki"/> fields.
            </summary>
        </member>
        <member name="T:PInvoke.User32.InputType">
            <summary>
            The type of the input event used by <see cref="F:PInvoke.User32.INPUT.type" />.
            </summary>
        </member>
        <member name="F:PInvoke.User32.InputType.INPUT_MOUSE">
            <summary>
            The event is a mouse event. Use the <see cref="F:PInvoke.User32.INPUT.InputUnion.mi"/> structure of the union.
            </summary>
        </member>
        <member name="F:PInvoke.User32.InputType.INPUT_KEYBOARD">
            <summary>
            The event is a keyboard event. Use the <see cref="F:PInvoke.User32.INPUT.InputUnion.ki"/> structure of the union.
            </summary>
        </member>
        <member name="F:PInvoke.User32.InputType.INPUT_HARDWARE">
            <summary>
            The event is a hardware event. Use the <see cref="F:PInvoke.User32.INPUT.InputUnion.hi"/> structure of the union.
            </summary>
        </member>
        <member name="T:PInvoke.User32.KEYBDINPUT">
            <summary>
            Contains information about a simulated keyboard event.
            </summary>
        </member>
        <member name="F:PInvoke.User32.KEYBDINPUT.wVk">
            <summary>
            A virtual-key code. The code must be a value in the range 1 to 254. If the dwFlags member specifies KEYEVENTF_UNICODE, wVk must be 0.
            </summary>
        </member>
        <member name="F:PInvoke.User32.KEYBDINPUT.wScan">
            <summary>
            A hardware scan code for the key.
            If <see cref="F:PInvoke.User32.KEYBDINPUT.dwFlags"/> specifies <see cref="F:PInvoke.User32.KEYEVENTF.KEYEVENTF_UNICODE"/>,
            <see cref="F:PInvoke.User32.KEYBDINPUT.wScan"/> specifies a Unicode character which is to be sent to the foreground application.
            </summary>
        </member>
        <member name="F:PInvoke.User32.KEYBDINPUT.dwFlags">
            <summary>
            Specifies various aspects of a keystroke.
            This member can be certain combinations of the following values.
            </summary>
        </member>
        <member name="F:PInvoke.User32.KEYBDINPUT.time">
            <summary>
            The time stamp for the event, in milliseconds. If this parameter is zero, the system will provide its own time stamp.
            </summary>
        </member>
        <member name="F:PInvoke.User32.KEYBDINPUT.dwExtraInfo">
            <summary>
            An additional value associated with the keystroke.
            Use the GetMessageExtraInfo function to obtain this information.
            </summary>
        </member>
        <member name="P:PInvoke.User32.KEYBDINPUT.dwExtraInfo_IntPtr">
            <summary>
            An additional value associated with the keystroke.
            Use the GetMessageExtraInfo function to obtain this information.
            </summary>
        </member>
        <member name="T:PInvoke.User32.KEYEVENTF">
            <summary>
            Specifies various aspects of a keystroke. This member can be certain combinations of the following values.
            </summary>
        </member>
        <member name="F:PInvoke.User32.KEYEVENTF.KEYEVENTF_EXTENDED_KEY">
            <summary>
            If specified, the scan code was preceded by a prefix byte that has the value 0xE0 (224).
            </summary>
        </member>
        <member name="F:PInvoke.User32.KEYEVENTF.KEYEVENTF_KEYUP">
            <summary>
            If specified, the key is being released. If not specified, the key is being pressed.
            </summary>
        </member>
        <member name="F:PInvoke.User32.KEYEVENTF.KEYEVENTF_SCANCODE">
            <summary>
            If specified, <see cref="F:PInvoke.User32.KEYBDINPUT.wScan"/> identifies the key and <see cref="F:PInvoke.User32.KEYBDINPUT.wVk"/> is ignored.
            </summary>
        </member>
        <member name="F:PInvoke.User32.KEYEVENTF.KEYEVENTF_UNICODE">
            <summary>
            If specified, the system synthesizes a <see cref="F:PInvoke.User32.VirtualKey.VK_PACKET"/> keystroke.
            The <see cref="F:PInvoke.User32.KEYBDINPUT.wVk"/> parameter must be zero.
            This flag can only be combined with the <see cref="F:PInvoke.User32.KEYEVENTF.KEYEVENTF_KEYUP"/> flag.
            For more information, see the Remarks section.
            </summary>
        </member>
        <member name="T:PInvoke.User32.LoadImageFlags">
            <summary>
            Represents various image types.
            </summary>
        </member>
        <member name="F:PInvoke.User32.LoadImageFlags.LR_CREATEDIBSECTION">
            <summary>
            When the uType parameter specifies <see cref="F:PInvoke.User32.ImageType.IMAGE_BITMAP"/>, causes the function to return a DIB section bitmap rather than a compatible bitmap. This flag is useful for loading a bitmap without mapping it to the colors of the display device.
            </summary>
        </member>
        <member name="F:PInvoke.User32.LoadImageFlags.LR_DEFAULTCOLOR">
            <summary>
            The default flag; it does nothing. All it means is "not <see cref="F:PInvoke.User32.LoadImageFlags.LR_MONOCHROME"/>".
            </summary>
        </member>
        <member name="F:PInvoke.User32.LoadImageFlags.LR_DEFAULTSIZE">
            <summary>
            Uses the width or height specified by the system metric values for cursors or icons, if the cxDesired or cyDesired values are set to zero. If this flag is not specified and cxDesired and cyDesired are set to zero, the function uses the actual resource size. If the resource contains multiple images, the function uses the size of the first image.
            </summary>
        </member>
        <member name="F:PInvoke.User32.LoadImageFlags.LR_LOADFROMFILE">
            <summary>
            Loads the stand-alone image from the file specified by lpszName (icon, cursor, or bitmap file).
            </summary>
        </member>
        <member name="F:PInvoke.User32.LoadImageFlags.LR_LOADMAP3DCOLORS">
            <summary>
            Searches the color table for the image and replaces the following shades of gray with the corresponding 3-D color.
            <list type="bullet">
            <item>Dk Gray, RGB(128,128,128) with COLOR_3DSHADOW</item>
            <item>Gray, RGB(192,192,192) with COLOR_3DFACE</item>
            <item>Lt Gray, RGB(223,223,223) with COLOR_3DLIGHT</item>
            </list>
            Do not use this option if you are loading a bitmap with a color depth greater than 8bpp.
            </summary>
        </member>
        <member name="F:PInvoke.User32.LoadImageFlags.LR_LOADTRANSPARENT">
            <summary>
            Retrieves the color value of the first pixel in the image and replaces the corresponding entry in the color table with the default window color (COLOR_WINDOW). All pixels in the image that use that entry become the default window color. This value applies only to images that have corresponding color tables.
            Do not use this option if you are loading a bitmap with a color depth greater than 8bpp.
            If fuLoad includes both the <see cref="F:PInvoke.User32.LoadImageFlags.LR_LOADTRANSPARENT"/> and <see cref="F:PInvoke.User32.LoadImageFlags.LR_LOADMAP3DCOLORS"/> values, <see cref="F:PInvoke.User32.LoadImageFlags.LR_LOADTRANSPARENT"/> takes precedence. However, the color table entry is replaced with COLOR_3DFACE rather than COLOR_WINDOW.
            </summary>
        </member>
        <member name="F:PInvoke.User32.LoadImageFlags.LR_MONOCHROME">
            <summary>
            Loads the image in black and white.
            </summary>
        </member>
        <member name="F:PInvoke.User32.LoadImageFlags.LR_SHARED">
            <summary>
            Shares the image handle if the image is loaded multiple times. If <see cref="F:PInvoke.User32.LoadImageFlags.LR_SHARED"/> is not set, a second call to LoadImage for the same resource will load the image again and return a different handle.
            When you use this flag, the system will destroy the resource when it is no longer needed.
            Do not use <see cref="F:PInvoke.User32.LoadImageFlags.LR_SHARED"/> for images that have non-standard sizes, that may change after loading, or that are loaded from a file.
            When loading a system icon or cursor, you must use <see cref="F:PInvoke.User32.LoadImageFlags.LR_SHARED"/> or the function will fail to load the resource.
            This function finds the first image in the cache with the requested resource name, regardless of the size requested.
            </summary>
        </member>
        <member name="F:PInvoke.User32.LoadImageFlags.LR_VGACOLOR">
            <summary>
            Uses true VGA colors.
            </summary>
        </member>
        <member name="T:PInvoke.User32.LookupIconIdFromDirectoryExFlags">
            <summary>
            Flags for the <see cref="M:PInvoke.User32.LookupIconIdFromDirectoryEx(System.Byte*,System.Boolean,System.Int32,System.Int32,PInvoke.User32.LookupIconIdFromDirectoryExFlags)"/> method.
            </summary>
        </member>
        <member name="F:PInvoke.User32.LookupIconIdFromDirectoryExFlags.LR_DEFAULTCOLOR">
            <summary>
            Uses the default color format.
            </summary>
        </member>
        <member name="F:PInvoke.User32.LookupIconIdFromDirectoryExFlags.LR_MONOCHROME">
            <summary>
            Creates a monochrome icon or cursor.
            </summary>
        </member>
        <member name="T:PInvoke.User32.MapVirtualKeyTranslation">
            <summary>The translation to be performed in <see cref="M:PInvoke.User32.MapVirtualKey(System.Int32,PInvoke.User32.MapVirtualKeyTranslation)" />.</summary>
        </member>
        <member name="F:PInvoke.User32.MapVirtualKeyTranslation.MAPVK_VK_TO_CHAR">
            <summary>
                uCode is a virtual-key code and is translated into an unshifted character value in the low-order word of the
                return value. Dead keys (diacritics) are indicated by setting the top bit of the return value. If there is no
                translation, the function returns 0.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MapVirtualKeyTranslation.MAPVK_VK_TO_VSC">
            <summary>
                uCode is a virtual-key code and is translated into a scan code. If it is a virtual-key code that does not
                distinguish between left- and right-hand keys, the left-hand scan code is returned. If there is no translation, the
                function returns 0.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MapVirtualKeyTranslation.MAPVK_VSC_TO_VK">
            <summary>
                uCode is a scan code and is translated into a virtual-key code that does not distinguish between left- and
                right-hand keys. If there is no translation, the function returns 0.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MapVirtualKeyTranslation.MAPVK_VSC_TO_VK_EX">
            <summary>
                uCode is a scan code and is translated into a virtual-key code that distinguishes between left- and right-hand
                keys. If there is no translation, the function returns 0.
            </summary>
        </member>
        <member name="T:PInvoke.User32.MenuItemFlags">
            <summary>
            Controls the appearance and behavior of a menu item
            </summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemFlags.MF_BITMAP">
            <summary>Uses a bitmap as the menu item. The lpNewItem parameter contains a handle to the bitmap.</summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemFlags.MF_CHECKED">
            <summary>
                Places a check mark next to the menu item. If the application provides check-mark bitmaps (see
                SetMenuItemBitmaps) this flag displays the check-mark bitmap next to the menu item.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemFlags.MF_DISABLED">
            <summary>Disables the menu item so that it cannot be selected, but the flag does not gray it.</summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemFlags.MF_ENABLED">
            <summary>Enables the menu item so that it can be selected, and restores it from its grayed state.</summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemFlags.MF_GRAYED">
            <summary>Disables the menu item and grays it so that it cannot be selected.</summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemFlags.MF_MENUBARBREAK">
            <summary>
                Functions the same as the MF_MENUBREAK flag for a menu bar. For a drop-down menu, submenu, or shortcut menu,
                the new column is separated from the old column by a vertical line.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemFlags.MF_MENUBREAK">
            <summary>
                Places the item on a new line (for a menu bar) or in a new column (for a drop-down menu, submenu, or shortcut
                menu) without separating columns.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemFlags.MF_OWNERDRAW">
            <summary>
                Specifies that the item is an owner-drawn item. Before the menu is displayed for the first time, the window
                that owns the menu receives a WM_MEASUREITEM message to retrieve the width and height of the menu item. The
                WM_DRAWITEM message is then sent to the window procedure of the owner window whenever the appearance of the menu
                item must be updated.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemFlags.MF_POPUP">
            <summary>
                Specifies that the menu item opens a drop-down menu or submenu. The uIDNewItem parameter specifies a handle to
                the drop-down menu or submenu. This flag is used to add a menu name to a menu bar, or a menu item that opens a
                submenu to a drop-down menu, submenu, or shortcut menu.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemFlags.MF_SEPARATOR">
            <summary>
                Draws a horizontal dividing line. This flag is used only in a drop-down menu, submenu, or shortcut menu. The
                line cannot be grayed, disabled, or highlighted. The lpNewItem and uIDNewItem parameters are ignored.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemFlags.MF_STRING">
            <summary>Specifies that the menu item is a text string; the lpNewItem parameter is a pointer to the string.</summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemFlags.MF_UNCHECKED">
            <summary>
                Does not place a check mark next to the item (default). If the application supplies check-mark bitmaps (see
                SetMenuItemBitmaps), this flag displays the clear bitmap next to the menu item.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemFlags.MF_BYCOMMAND">
            <summary>Indicates that the menu item is identified by it's command.</summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemFlags.MF_BYPOSITION">
            <summary>Indicates that the menu item is identified by it's zero-based relative position.</summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemFlags.MF_UNHILITE">
            <summary>Removes highlighting from the menu item.</summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemFlags.MF_HILITE">
            <summary>Highlights the menu item</summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemFlags.MF_END">
            <summary>Obsolete -- only used by old RES files</summary>
        </member>
        <member name="T:PInvoke.User32.MENUITEMINFO">
            <summary>
            Contains information about a menu item.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MENUITEMINFO.cbSize">
            <summary>The size of the structure, in bytes.</summary>
        </member>
        <member name="F:PInvoke.User32.MENUITEMINFO.fMask">
            <summary>Indicates the members to be retrieved or set.</summary>
        </member>
        <member name="F:PInvoke.User32.MENUITEMINFO.fType">
            <summary>The menu item type.</summary>
        </member>
        <member name="F:PInvoke.User32.MENUITEMINFO.fState">
            <summary>The menu item state.</summary>
        </member>
        <member name="F:PInvoke.User32.MENUITEMINFO.wID">
            <summary>
                An application-defined value that identifies the menu item. Set <see cref="F:PInvoke.User32.MENUITEMINFO.fMask" /> to
                <see cref="F:PInvoke.User32.MenuMembersMask.MIIM_ID" /> to use <see cref="F:PInvoke.User32.MENUITEMINFO.wID" />.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MENUITEMINFO.hSubMenu">
            <summary>
                A handle to the drop-down menu or submenu associated with the menu item. If the menu item is not an item that
                opens a drop-down menu or submenu, this member is <see cref="F:System.IntPtr.Zero" />. Set <see cref="F:PInvoke.User32.MENUITEMINFO.fMask" /> to
                <see cref="F:PInvoke.User32.MenuMembersMask.MIIM_SUBMENU" /> to use hSubMenu.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MENUITEMINFO.hbmpChecked">
            <summary>
                A handle to the bitmap to display next to the item if it is selected. If this member is
                <see cref="F:System.IntPtr.Zero" />, a default bitmap is used. If the <see cref="F:PInvoke.User32.MenuItemType.MFT_RADIOCHECK" /> type value
                is specified, the default bitmap is a bullet. Otherwise, it is a check mark. Set fMask to
                <see cref="F:PInvoke.User32.MenuMembersMask.MIIM_CHECKMARKS" /> to use <see cref="F:PInvoke.User32.MENUITEMINFO.hbmpChecked" />.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MENUITEMINFO.hbmpUnchecked">
            <summary>
                A handle to the bitmap to display next to the item if it is not selected. If this member is
                <see cref="F:System.IntPtr.Zero" />, no bitmap is used. Set <see cref="F:PInvoke.User32.MENUITEMINFO.fMask" /> to
                <see cref="F:PInvoke.User32.MenuMembersMask.MIIM_CHECKMARKS" /> to use <see cref="F:PInvoke.User32.MENUITEMINFO.hbmpUnchecked" />.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MENUITEMINFO.dwItemData">
            <summary>
                An application-defined value associated with the menu item. Set <see cref="F:PInvoke.User32.MENUITEMINFO.fMask" /> to
                <see cref="F:PInvoke.User32.MenuMembersMask.MIIM_DATA" /> to use <see cref="F:PInvoke.User32.MENUITEMINFO.dwItemData" />.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MENUITEMINFO.dwTypeData">
            <summary>
                The contents of the menu item. The meaning of this member depends on the value of fType and is used only if the
                MIIM_TYPE flag is set in the fMask member.
                <para>
                    To retrieve a menu item of type <see cref="F:PInvoke.User32.MenuItemType.MFT_STRING" />, first find the size of the string by
                    setting the <see cref="F:PInvoke.User32.MENUITEMINFO.dwTypeData" />
                    member of <see cref="T:PInvoke.User32.MENUITEMINFO" /> to <see cref="F:System.IntPtr.Zero" /> and then calling
                    <see cref="M:PInvoke.User32.GetMenuItemInfo(System.IntPtr,System.UInt32,System.Boolean,PInvoke.User32.MENUITEMINFO@)" />. The value of <see cref="F:PInvoke.User32.MENUITEMINFO.cch" />+1 is the size needed. Then allocate a buffer of
                    this size, place the pointer to the buffer in dwTypeData, increment cch, and call
                    <see cref="M:PInvoke.User32.GetMenuItemInfo(System.IntPtr,System.UInt32,System.Boolean,PInvoke.User32.MENUITEMINFO@)" /> once again to fill the buffer with the string. If the retrieved menu item is of
                    some other type, then <see cref="M:PInvoke.User32.GetMenuItemInfo(System.IntPtr,System.UInt32,System.Boolean,PInvoke.User32.MENUITEMINFO@)" /> sets the <see cref="F:PInvoke.User32.MENUITEMINFO.dwTypeData" /> member to a value whose
                    type is specified by the <see cref="F:PInvoke.User32.MENUITEMINFO.fType" /> member.
                </para>
                <para>
                    When using with the <see cref="M:PInvoke.User32.SetMenuItemInfo(System.IntPtr,System.UInt32,System.Boolean,PInvoke.User32.MENUITEMINFO@)" /> function, this member should contain a value whose type is
                    specified by the <see cref="F:PInvoke.User32.MENUITEMINFO.fType" /> member.
                </para>
                <para>
                    dwTypeData is used only if the <see cref="F:PInvoke.User32.MenuMembersMask.MIIM_STRING" /> flag is set in the
                    <see cref="F:PInvoke.User32.MENUITEMINFO.fMask" /> member
                </para>
            </summary>
        </member>
        <member name="F:PInvoke.User32.MENUITEMINFO.cch">
            <summary>
                The length of the menu item text, in characters, when information is received about a menu item of the
                <see cref="F:PInvoke.User32.MenuItemType.MFT_STRING" />
                type. However, <see cref="F:PInvoke.User32.MENUITEMINFO.cch" /> is used only if the <see cref="F:PInvoke.User32.MenuMembersMask.MIIM_TYPE" /> flag is set in the
                <see cref="F:PInvoke.User32.MENUITEMINFO.fMask" /> member and is zero otherwise. Also, <see cref="F:PInvoke.User32.MENUITEMINFO.cch" />
                is ignored when the content of a menu item is set by calling <see cref="M:PInvoke.User32.SetMenuItemInfo(System.IntPtr,System.UInt32,System.Boolean,PInvoke.User32.MENUITEMINFO@)" />.
                <para>
                    Note that, before calling <see cref="M:PInvoke.User32.GetMenuItemInfo(System.IntPtr,System.UInt32,System.Boolean,PInvoke.User32.MENUITEMINFO@)" />, the application must set <see cref="F:PInvoke.User32.MENUITEMINFO.cch" /> to the
                    length of the buffer pointed to by the <see cref="F:PInvoke.User32.MENUITEMINFO.dwTypeData" /> member. If the retrieved menu item is of type
                    <see cref="F:PInvoke.User32.MenuItemType.MFT_STRING" /> (as indicated by the <see cref="F:PInvoke.User32.MENUITEMINFO.fType" />
                    member), then <see cref="M:PInvoke.User32.GetMenuItemInfo(System.IntPtr,System.UInt32,System.Boolean,PInvoke.User32.MENUITEMINFO@)" /> changes <see cref="F:PInvoke.User32.MENUITEMINFO.cch" /> to the length of the menu item text. If
                    the retrieved menu item is of some other type, <see cref="M:PInvoke.User32.GetMenuItemInfo(System.IntPtr,System.UInt32,System.Boolean,PInvoke.User32.MENUITEMINFO@)" /> sets the <see cref="F:PInvoke.User32.MENUITEMINFO.cch" /> field
                    to zero.
                </para>
                <para>
                    The <see cref="F:PInvoke.User32.MENUITEMINFO.cch" /> member is used when the <see cref="F:PInvoke.User32.MenuMembersMask.MIIM_STRING" /> flag is set in the
                    <see cref="F:PInvoke.User32.MENUITEMINFO.fMask" /> member.
                </para>
            </summary>
        </member>
        <member name="F:PInvoke.User32.MENUITEMINFO.hbmpItem">
            <summary>
                A handle to the bitmap to be displayed, or it can be one of the following values :
                <para>
                    <see cref="F:PInvoke.User32.HBMMENU_CALLBACK" />
                </para>
                <para>
                    <see cref="F:PInvoke.User32.HBMMENU_MBAR_CLOSE" />
                </para>
                <para>
                    <see cref="F:PInvoke.User32.HBMMENU_MBAR_CLOSE_D" />
                </para>
                <para>
                    <see cref="F:PInvoke.User32.HBMMENU_MBAR_MINIMIZE" />
                </para>
                <para>
                    <see cref="F:PInvoke.User32.HBMMENU_MBAR_MINIMIZE_D" />
                </para>
                <para>
                    <see cref="F:PInvoke.User32.HBMMENU_MBAR_RESTORE" />
                </para>
                <para>
                    <see cref="F:PInvoke.User32.HBMMENU_POPUP_CLOSE" />
                </para>
                <para>
                    <see cref="F:PInvoke.User32.HBMMENU_POPUP_MAXIMIZE" />
                </para>
                <para>
                    <see cref="F:PInvoke.User32.HBMMENU_POPUP_MINIMIZE" />
                </para>
                <para>
                    <see cref="F:PInvoke.User32.HBMMENU_POPUP_RESTORE" />
                </para>
                <para>
                    <see cref="F:PInvoke.User32.HBMMENU_SYSTEM" />
                </para>
            </summary>
        </member>
        <member name="M:PInvoke.User32.MENUITEMINFO.Create">
            <summary>
            Create a new instance of <see cref="T:PInvoke.User32.MENUITEMINFO"/> with <see cref="F:PInvoke.User32.MENUITEMINFO.cbSize"/> set to the correct value.
            </summary>
            <returns>A new instance of <see cref="T:PInvoke.User32.MENUITEMINFO"/> with <see cref="F:PInvoke.User32.MENUITEMINFO.cbSize"/> set to the correct value.</returns>
        </member>
        <member name="T:PInvoke.User32.MenuItemState">
            <summary>The menu item state in <see cref="T:PInvoke.User32.MENUITEMINFO" />.</summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemState.MFS_CHECKED">
            <summary>
                Checks the menu item. For more information about selected menu items, see the
                <see cref="F:PInvoke.User32.MENUITEMINFO.hbmpChecked" /> member.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemState.MFS_DEFAULT">
            <summary>
                Specifies that the menu item is the default. A menu can contain only one default menu item, which is displayed
                in bold.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemState.MFS_DISABLED">
            <summary>
                Disables the menu item and grays it so that it cannot be selected. This is equivalent to
                <see cref="F:PInvoke.User32.MenuItemState.MFS_GRAYED" />.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemState.MFS_ENABLED">
            <summary>Enables the menu item so that it can be selected. This is the default state.</summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemState.MFS_GRAYED">
            <summary>
                Disables the menu item and grays it so that it cannot be selected. This is equivalent to
                <see cref="F:PInvoke.User32.MenuItemState.MFS_DISABLED" />.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemState.MFS_HILITE">
            <summary>Highlights the menu item.</summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemState.MFS_UNCHECKED">
            <summary>Unchecks the menu item. For more information about clear menu items, see the hbmpChecked member.</summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemState.MFS_UNHILITE">
            <summary>Removes the highlight from the menu item. This is the default state.</summary>
        </member>
        <member name="T:PInvoke.User32.MenuItemType">
            <summary>
            The menu item type in <see cref="T:PInvoke.User32.MENUITEMINFO"/>.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemType.MFT_BITMAP">
            <summary>
                Displays the menu item using a bitmap. The low-order word of the <see cref="F:PInvoke.User32.MENUITEMINFO.dwTypeData" /> member is
                the bitmap handle, and the <see cref="F:PInvoke.User32.MENUITEMINFO.cch" /> member is ignored.
                <para>
                    <see cref="F:PInvoke.User32.MenuItemType.MFT_BITMAP" /> is replaced by <see cref="F:PInvoke.User32.MenuMembersMask.MIIM_BITMAP" /> and
                    <see cref="F:PInvoke.User32.MENUITEMINFO.hbmpItem" />.
                </para>
            </summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemType.MFT_MENUBARBREAK">
            <summary>
                Places the menu item on a new line (for a menu bar) or in a new column (for a drop-down menu, submenu, or
                shortcut menu). For a drop-down menu, submenu, or shortcut menu, a vertical line separates the new column from the
                old.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemType.MFT_MENUBREAK">
            <summary>
                Places the menu item on a new line (for a menu bar) or in a new column (for a drop-down menu, submenu, or
                shortcut menu). For a drop-down menu, submenu, or shortcut menu, the columns are not separated by a vertical line.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemType.MFT_OWNERDRAW">
            <summary>
                Assigns responsibility for drawing the menu item to the window that owns the menu. The window receives a
                WM_MEASUREITEM message before the menu is displayed for the first time, and a WM_DRAWITEM message whenever the
                appearance of the menu item must be updated. If this value is specified, the dwTypeData member contains an
                application-defined value.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemType.MFT_RADIOCHECK">
            <summary>
                Displays selected menu items using a radio-button mark instead of a check mark if the
                <see cref="F:PInvoke.User32.MENUITEMINFO.hbmpChecked" /> member is <see cref="F:System.IntPtr.Zero" />.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemType.MFT_RIGHTJUSTIFY">
            <summary>
                Right-justifies the menu item and any subsequent items. This value is valid only if the menu item is in a menu
                bar.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemType.MFT_RIGHTORDER">
            <summary>
                Specifies that menus cascade right-to-left (the default is left-to-right). This is used to support
                right-to-left languages, such as Arabic and Hebrew.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemType.MFT_SEPARATOR">
            <summary>
                Specifies that the menu item is a separator. A menu item separator appears as a horizontal dividing line. The
                dwTypeData and cch members are ignored. This value is valid only in a drop-down menu, submenu, or shortcut menu.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MenuItemType.MFT_STRING">
            <summary>
                Displays the menu item using a text string. The <see cref="F:PInvoke.User32.MENUITEMINFO.dwTypeData" /> member is the pointer
                to a null-terminated string, and the <see cref="F:PInvoke.User32.MENUITEMINFO.cch" /> member is the length of the string.
                <para><see cref="F:PInvoke.User32.MenuItemType.MFT_STRING" /> is replaced by <see cref="F:PInvoke.User32.MenuMembersMask.MIIM_STRING" />.</para>
            </summary>
        </member>
        <member name="T:PInvoke.User32.MenuMembersMask">
            <summary>Indicates the members to be retrieved or set in <see cref="T:PInvoke.User32.MENUITEMINFO" />.</summary>
        </member>
        <member name="F:PInvoke.User32.MenuMembersMask.MIIM_BITMAP">
            <summary>Retrieves or sets the <see cref="F:PInvoke.User32.MENUITEMINFO.hbmpItem" /> member.</summary>
        </member>
        <member name="F:PInvoke.User32.MenuMembersMask.MIIM_CHECKMARKS">
            <summary>Retrieves or sets the <see cref="F:PInvoke.User32.MENUITEMINFO.hbmpChecked" /> and <see cref="F:PInvoke.User32.MENUITEMINFO.hbmpUnchecked" />
                members.</summary>
        </member>
        <member name="F:PInvoke.User32.MenuMembersMask.MIIM_DATA">
            <summary>Retrieves or sets the <see cref="F:PInvoke.User32.MENUITEMINFO.dwItemData" /> member.</summary>
        </member>
        <member name="F:PInvoke.User32.MenuMembersMask.MIIM_FTYPE">
            <summary>Retrieves or sets the <see cref="F:PInvoke.User32.MENUITEMINFO.fType" /> member.</summary>
        </member>
        <member name="F:PInvoke.User32.MenuMembersMask.MIIM_ID">
            <summary>Retrieves or sets the <see cref="F:PInvoke.User32.MENUITEMINFO.wID" /> member.</summary>
        </member>
        <member name="F:PInvoke.User32.MenuMembersMask.MIIM_STATE">
            <summary>Retrieves or sets the <see cref="F:PInvoke.User32.MENUITEMINFO.fState" /> member.</summary>
        </member>
        <member name="F:PInvoke.User32.MenuMembersMask.MIIM_STRING">
            <summary>Retrieves or sets the <see cref="F:PInvoke.User32.MENUITEMINFO.dwTypeData" /> member.</summary>
        </member>
        <member name="F:PInvoke.User32.MenuMembersMask.MIIM_SUBMENU">
            <summary>Retrieves or sets the <see cref="F:PInvoke.User32.MENUITEMINFO.hSubMenu" /> member.</summary>
        </member>
        <member name="F:PInvoke.User32.MenuMembersMask.MIIM_TYPE">
            <summary>
                Retrieves or sets the <see cref="F:PInvoke.User32.MENUITEMINFO.fType" /> and <see cref="F:PInvoke.User32.MENUITEMINFO.dwTypeData" /> members.
                <para>MIIM_TYPE is replaced by <see cref="F:PInvoke.User32.MenuMembersMask.MIIM_BITMAP" />, <see cref="F:PInvoke.User32.MenuMembersMask.MIIM_FTYPE" />, and
                    <see cref="F:PInvoke.User32.MenuMembersMask.MIIM_STRING" />.</para>
            </summary>
        </member>
        <member name="T:PInvoke.User32.MessageBoxOptions">
            <summary>
            Flags that define appearance and behavior of a standard message box
            displayed by a call to the <see cref="M:PInvoke.User32.MessageBox(System.IntPtr,System.String,System.String,PInvoke.User32.MessageBoxOptions)"/> function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxOptions.MB_OK">
            <summary>
            The message box contains one push button: OK. This is the default.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxOptions.MB_OKCANCEL">
            <summary>
            The message box contains two push buttons: OK and Cancel.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxOptions.MB_ABORTRETRYIGNORE">
            <summary>
            The message box contains three push buttons: Abort, Retry, and Ignore.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxOptions.MB_YESNOCANCEL">
            <summary>
            The message box contains three push buttons: Yes, No, and Cancel.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxOptions.MB_YESNO">
            <summary>
            The message box contains two push buttons: Yes and No.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxOptions.MB_RETRYCANCEL">
            <summary>
            The message box contains two push buttons: Retry and Cancel.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxOptions.MB_CANCELTRYCONTINUE">
            <summary>
            The message box contains three push buttons: Cancel, Try Again, Continue. Use this message box type instead of <see cref="F:PInvoke.User32.MessageBoxOptions.MB_ABORTRETRYIGNORE"/>.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxOptions.MB_ICONSTOP">
            <summary>
            A stop-sign icon appears in the message box.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxOptions.MB_ICONERROR">
            <summary>
            A stop-sign icon appears in the message box.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxOptions.MB_ICONHAND">
            <summary>
            A stop-sign icon appears in the message box.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxOptions.MB_ICONQUESTION">
            <summary>
            A question-mark icon appears in the message box. The question-mark message icon is no longer recommended because it does not clearly represent a specific type of message
            and because the phrasing of a message as a question could apply to any message type.
            In addition, users can confuse the message symbol question mark with Help information.
            Therefore, do not use this question mark message symbol in your message boxes.
            The system continues to support its inclusion only for backward compatibility.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxOptions.MB_ICONWARNING">
            <summary>
            An exclamation-point icon appears in the message box.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxOptions.MB_ICONEXCLAMATION">
            <summary>
            An exclamation-point icon appears in the message box.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxOptions.MB_ICONASTERISK">
            <summary>
            An icon consisting of a lowercase letter i in a circle appears in the message box.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxOptions.MB_ICONINFORMATION">
            <summary>
            An icon consisting of a lowercase letter i in a circle appears in the message box.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxOptions.MB_USERICON">
            <summary>
            Uses an user defined icon
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxOptions.MB_DEFBUTTON1">
            <summary>
            The first button is the default button.
            MB_DEFBUTTON1 is the default unless <see cref="F:PInvoke.User32.MessageBoxOptions.MB_DEFBUTTON2"/>, <see cref="F:PInvoke.User32.MessageBoxOptions.MB_DEFBUTTON3"/>, or <see cref="F:PInvoke.User32.MessageBoxOptions.MB_DEFBUTTON4"/> is specified.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxOptions.MB_DEFBUTTON2">
            <summary>
            The second button is the default button.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxOptions.MB_DEFBUTTON3">
            <summary>
            The third button is the default button.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxOptions.MB_DEFBUTTON4">
            <summary>
            The fourth button is the default button.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxOptions.MB_APPLMODAL">
            <summary>
            The user must respond to the message box before continuing work in the window identified by the hWnd parameter.
            However, the user can move to the windows of other threads and work in those windows.
            Depending on the hierarchy of windows in the application, the user may be able to move to other windows within the thread.
            All child windows of the parent of the message box are automatically disabled, but pop-up windows are not.
            MB_APPLMODAL is the default if neither <see cref="F:PInvoke.User32.MessageBoxOptions.MB_SYSTEMMODAL"/> nor <see cref="F:PInvoke.User32.MessageBoxOptions.MB_TASKMODAL"/> is specified.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxOptions.MB_SYSTEMMODAL">
            <summary>
            Same as <see cref="F:PInvoke.User32.MessageBoxOptions.MB_APPLMODAL"/> except that the message box has the WS_EX_TOPMOST style.
            Use system-modal message boxes to notify the user of serious, potentially damaging errors that require immediate attention (for example, running out of memory).
            This flag has no effect on the user's ability to interact with windows other than those associated with hWnd.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxOptions.MB_TASKMODAL">
            <summary>
            Same as <see cref="F:PInvoke.User32.MessageBoxOptions.MB_APPLMODAL"/> except that all the top-level windows belonging to the current thread are disabled if the hWnd parameter is NULL.
            Use this flag when the calling application or library does not have a window handle available but still needs to prevent input to other windows
            in the calling thread without suspending other threads.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxOptions.MB_HELP">
            <summary>
            Adds a Help button to the message box. When the user clicks the Help button or presses F1, the system sends a <see cref="F:PInvoke.User32.WindowMessage.WM_HELP"/> message to the owner.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxOptions.MB_NOFOCUS">
            <summary>
            Undocumented
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxOptions.MB_SETFOREGROUND">
            <summary>
            The message box becomes the foreground window. Internally, the system calls the <see cref="M:PInvoke.User32.SetForegroundWindow(System.IntPtr)"/> function for the message box.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxOptions.MB_DEFAULT_DESKTOP_ONLY">
            <summary>
            Same as desktop of the interactive window station. For more information, see Window Stations.
            If the current input desktop is not the default desktop, MessageBox does not return until the user switches to the default desktop.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxOptions.MB_TOPMOST">
            <summary>
            The message box is created with the WS_EX_TOPMOST window style.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxOptions.MB_RIGHT">
            <summary>
            The text is right-justified.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxOptions.MB_RTLREADING">
            <summary>
            Displays message and caption text using right-to-left reading order on Hebrew and Arabic systems.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxOptions.MB_SERVICE_NOTIFICATION">
            <summary>
            The caller is a service notifying the user of an event. The function displays a message box on the current active desktop, even if there is no user logged on to the computer.
            If this flag is set, the hWnd parameter must be NULL. This is so that the message box can appear on a desktop other than the desktop corresponding to the hWnd.
            </summary>
            <remarks>Terminal Services: If the calling thread has an impersonation token, the function directs the message box to the session specified in the impersonation token.</remarks>
        </member>
        <member name="T:PInvoke.User32.MessageBeepType">
            <summary>
            Types of sounds that can be emitted by the <see cref="M:PInvoke.User32.MessageBeep(PInvoke.User32.MessageBeepType)"/> method.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBeepType.SimpleBeep">
            <summary>
            A simple beep. If the sound card is not available, the sound is generated using the speaker.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBeepType.MB_ICONASTERISK">
            <summary>
            See <see cref="F:PInvoke.User32.MessageBeepType.MB_ICONINFORMATION"/>.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBeepType.MB_ICONEXCLAMATION">
            <summary>
            See <see cref="F:PInvoke.User32.MessageBeepType.MB_ICONWARNING"/>.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBeepType.MB_ICONERROR">
            <summary>
            The sound specified as the Windows Critical Stop sound.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBeepType.MB_ICONHAND">
            <summary>
            See <see cref="F:PInvoke.User32.MessageBeepType.MB_ICONERROR"/>.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBeepType.MB_ICONINFORMATION">
            <summary>
            The sound specified as the Windows Asterisk sound.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBeepType.MB_ICONQUESTION">
            <summary>
            The sound specified as the Windows Question sound.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBeepType.MB_ICONSTOP">
            <summary>
            See <see cref="F:PInvoke.User32.MessageBeepType.MB_ICONERROR"/>.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBeepType.MB_ICONWARNING">
            <summary>
            The sound specified as the Windows Exclamation sound.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBeepType.MB_OK">
            <summary>
            The sound specified as the Windows Default Beep sound.
            </summary>
        </member>
        <member name="T:PInvoke.User32.MessageBoxResult">
            <summary>
            Represents possible values returned by the <see cref="M:PInvoke.User32.MessageBox(System.IntPtr,System.String,System.String,PInvoke.User32.MessageBoxOptions)"/> function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxResult.IDOK">
            <summary>
            The OK button was selected.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxResult.IDCANCEL">
            <summary>
            The Cancel button was selected.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxResult.IDABORT">
            <summary>
            The Abort button was selected.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxResult.IDRETRY">
            <summary>
            The Retry button was selected.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxResult.IDIGNORE">
            <summary>
            The Ignore button was selected.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxResult.IDYES">
            <summary>
            The Yes button was selected.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxResult.IDNO">
            <summary>
            The No button was selected.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxResult.IDCLOSE">
            <summary>
            The user closed the message box.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxResult.IDHELP">
            <summary>
            The Help button was selected.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxResult.IDTRYAGAIN">
            <summary>
            The Try Again button was selected.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxResult.IDCONTINUE">
            <summary>
            The Continue button was selected.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MessageBoxResult.IDTIMEOUT">
            <summary>
            The user did not click any button and the messagebox timed out.
            </summary>
        </member>
        <member name="T:PInvoke.User32.MONITORINFOEX">
            <summary>
            The MONITORINFOEX structure contains information about a display monitor. The GetMonitorInfo
            function stores information into a MONITORINFOEX structure or a MONITORINFO structure. The
            MONITORINFOEX structure is a superset of the MONITORINFO structure. The MONITORINFOEX
            structure adds a string member to contain a name for the display monitor.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MONITORINFOEX.cbSize">
            <summary>
            The size, in bytes, of the structure. Set this member to sizeof(MONITORINFOEX) (72)
            before calling the GetMonitorInfo function. Doing so lets the function determine the type
            of structure you are passing to it.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MONITORINFOEX.Monitor">
            <summary>
            A <see cref="T:PInvoke.RECT"/> structure that specifies the display monitor rectangle, expressed in
            virtual-screen coordinates. Note that if the monitor is not the primary display monitor,
            some of the rectangle's coordinates may be negative values.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MONITORINFOEX.WorkArea">
            <summary>
            A <see cref="T:PInvoke.RECT"/> structure that specifies the work area rectangle of the display monitor that can
            be used by applications, expressed in virtual-screen coordinates. Windows uses this
            rectangle to maximize an application on the monitor. The rest of the area in rcMonitor
            contains system windows such as the task bar and side bars. Note that if the monitor is
            not the primary display monitor, some of the rectangle's coordinates may be negative values.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MONITORINFOEX.Flags">
            <summary>
            The attributes of the display monitor.
            </summary>
            <remarks>This member can be the following value: 1 : MONITORINFOF_PRIMARY</remarks>
        </member>
        <member name="F:PInvoke.User32.MONITORINFOEX.DeviceName">
            <summary>
            A string that specifies the device name of the monitor being used. Most applications have
            no use for a display monitor name, and so can save some bytes by using a MONITORINFO structure.
            </summary>
        </member>
        <member name="T:PInvoke.User32.MOUSEEVENTF">
            <summary>
            A set of bit flags that specify various aspects of mouse motion and button clicks. The bits in this member can be any reasonable combination of the following values.
            </summary>
            <remarks>
            The bit flags that specify mouse button status are set to indicate changes in status, not ongoing conditions.
            For example, if the left mouse button is pressed and held down, MOUSEEVENTF_LEFTDOWN is set when the left button is first pressed, but not for subsequent motions.
            Similarly, MOUSEEVENTF_LEFTUP is set only when the button is first released.
            You cannot specify both the MOUSEEVENTF_WHEEL flag and either MOUSEEVENTF_XDOWN or MOUSEEVENTF_XUP flags simultaneously in the <see cref="F:PInvoke.User32.MOUSEINPUT.dwFlags"/> parameter,
            because they both require use of the <see cref="F:PInvoke.User32.MOUSEINPUT.mouseData" /> field.
            </remarks>
        </member>
        <member name="T:PInvoke.User32.MOUSEINPUT">
            <summary>
            Contains information about a simulated mouse event.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MOUSEINPUT.dx">
            <summary>
            The absolute position of the mouse, or the amount of motion since the last mouse event was generated, depending on the value of the dwFlags member. Absolute data is specified as the x coordinate of the mouse; relative data is specified as the number of pixels moved.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MOUSEINPUT.dy">
            <summary>
            The absolute position of the mouse, or the amount of motion since the last mouse event was generated, depending on the value of the dwFlags member. Absolute data is specified as the y coordinate of the mouse; relative data is specified as the number of pixels moved.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MOUSEINPUT.mouseData">
            <summary>
            If dwFlags contains <see cref="F:PInvoke.User32.MOUSEEVENTF.MOUSEEVENTF_WHEEL"/>, then <see cref="F:PInvoke.User32.MOUSEINPUT.mouseData"/> specifies the amount of wheel movement. A positive value indicates that the wheel was rotated forward, away from the user; a negative value indicates that the wheel was rotated backward, toward the user. One wheel click is defined as <see cref="F:PInvoke.User32.WHEEL_DELTA"/>, which is 120.
            If dwFlags does not contain <see cref="F:PInvoke.User32.MOUSEEVENTF.MOUSEEVENTF_WHEEL"/>, <see cref="F:PInvoke.User32.MOUSEEVENTF.MOUSEEVENTF_XDOWN"/>, or <see cref="F:PInvoke.User32.MOUSEEVENTF.MOUSEEVENTF_XUP"/>, then mouseData should be zero.
            If dwFlags contains <see cref="F:PInvoke.User32.MOUSEEVENTF.MOUSEEVENTF_XDOWN"/> or <see cref="F:PInvoke.User32.MOUSEEVENTF.MOUSEEVENTF_XUP"/>, then mouseData specifies which X buttons were pressed or released.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MOUSEINPUT.dwFlags">
            <summary>
            A set of bit flags that specify various aspects of mouse motion and button clicks. The bits in this member can be any reasonable combination of the following values.
            See MSDN docs for more info.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MOUSEINPUT.time">
            <summary>
            The time stamp for the event, in milliseconds. If this parameter is 0, the system will provide its own time stamp.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MOUSEINPUT.dwExtraInfo">
            <summary>
            An additional value associated with the mouse event. An application calls GetMessageExtraInfo to obtain this extra information.
            </summary>
        </member>
        <member name="P:PInvoke.User32.MOUSEINPUT.dwExtraInfo_IntPtr">
            <summary>
            An additional value associated with the mouse event. An application calls GetMessageExtraInfo to obtain this extra information.
            </summary>
        </member>
        <member name="T:PInvoke.User32.mouse_eventFlags">
            <summary>
            Controls various aspects of mouse motion and button clicking.
            </summary>
        </member>
        <member name="F:PInvoke.User32.mouse_eventFlags.MOUSEEVENTF_ABSOLUTE">
            <summary>
            The dx and dy parameters contain normalized absolute coordinates. If not set, those parameters contain relative data: the change in position since the last reported position. This flag can be set, or not set, regardless of what kind of mouse or mouse-like device, if any, is connected to the system. For further information about relative mouse motion, see the following Remarks section.
            </summary>
        </member>
        <member name="F:PInvoke.User32.mouse_eventFlags.MOUSEEVENTF_LEFTDOWN">
            <summary>
            The left button is down.
            </summary>
        </member>
        <member name="F:PInvoke.User32.mouse_eventFlags.MOUSEEVENTF_LEFTUP">
            <summary>
            The left button is up.
            </summary>
        </member>
        <member name="F:PInvoke.User32.mouse_eventFlags.MOUSEEVENTF_MIDDLEDOWN">
            <summary>
            The middle button is down.
            </summary>
        </member>
        <member name="F:PInvoke.User32.mouse_eventFlags.MOUSEEVENTF_MIDDLEUP">
            <summary>
            The middle button is up.
            </summary>
        </member>
        <member name="F:PInvoke.User32.mouse_eventFlags.MOUSEEVENTF_MOVE">
            <summary>
            Movement occurred.
            </summary>
        </member>
        <member name="F:PInvoke.User32.mouse_eventFlags.MOUSEEVENTF_RIGHTDOWN">
            <summary>
            The right button is down.
            </summary>
        </member>
        <member name="F:PInvoke.User32.mouse_eventFlags.MOUSEEVENTF_RIGHTUP">
            <summary>
            The right button is up.
            </summary>
        </member>
        <member name="F:PInvoke.User32.mouse_eventFlags.MOUSEEVENTF_WHEEL">
            <summary>
            The wheel has been moved, if the mouse has a wheel. The amount of movement is specified in dwData
            </summary>
        </member>
        <member name="F:PInvoke.User32.mouse_eventFlags.MOUSEEVENTF_XDOWN">
            <summary>
            An X button was pressed.
            </summary>
        </member>
        <member name="F:PInvoke.User32.mouse_eventFlags.MOUSEEVENTF_XUP">
            <summary>
            An X button was released.
            </summary>
        </member>
        <member name="F:PInvoke.User32.mouse_eventFlags.MOUSEEVENTF_HWHEEL">
            <summary>
            The wheel button is tilted.
            </summary>
        </member>
        <member name="T:PInvoke.User32.MSG">
            <summary>
            Contains message information from a thread's message queue.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MSG.hwnd">
            <summary>
            A handle to the window whose window procedure receives the message. This member is <see cref="F:System.IntPtr.Zero" /> when
            the message is a thread message.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MSG.message">
            <summary>
            The message identifier. Applications can only use the low word; the high word is reserved by the system.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MSG.wParam">
            <summary>
            Additional information about the message. The exact meaning depends on the value of the message member.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MSG.lParam">
            <summary>
            Additional information about the message. The exact meaning depends on the value of the message member.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MSG.time">
            <summary>
            The time at which the message was posted.
            </summary>
        </member>
        <member name="F:PInvoke.User32.MSG.pt">
            <summary>
            The cursor position, in screen coordinates, when the message was posted.
            </summary>
        </member>
        <member name="T:PInvoke.User32.ObjectInformationType">
            <summary>
            The information to be retrieved by <see cref="M:PInvoke.User32.GetUserObjectInformation(System.IntPtr,PInvoke.User32.ObjectInformationType,System.Void*,System.UInt32,System.UInt32*)"/>
            </summary>
        </member>
        <member name="F:PInvoke.User32.ObjectInformationType.UOI_FLAGS">
            <summary>
            The handle flags. The pvInfo parameter must point to a <see cref="T:PInvoke.User32.USEROBJECTFLAGS"/> structure.
            </summary>
        </member>
        <member name="F:PInvoke.User32.ObjectInformationType.UOI_NAME">
            <summary>
            The name of the object, as a string.
            </summary>
        </member>
        <member name="F:PInvoke.User32.ObjectInformationType.UOI_TYPE">
            <summary>
            The type name of the object, as a string
            </summary>
        </member>
        <member name="F:PInvoke.User32.ObjectInformationType.UOI_USER_SID">
            <summary>
            The SID structure that identifies the user that is currently associated with the specified object.
            If no user is associated with the object, the value returned in the buffer pointed to by lpnLengthNeeded is zero.
            Note that SID is a variable length structure. You will usually make a call to GetUserObjectInformation to determine
            the length of the SID before retrieving its value.
            </summary>
        </member>
        <member name="F:PInvoke.User32.ObjectInformationType.UOI_HEAPSIZE">
            <summary>
            The size of the desktop heap, in KB, as a ULONG value. The hObj parameter must be a handle to a desktop object,
            otherwise, the function fails.
            </summary>
            <remarks>Windows Server 2003 and Windows XP/2000:  This value is not supported.</remarks>
        </member>
        <member name="F:PInvoke.User32.ObjectInformationType.UOI_IO">
            <summary>
            TRUE if the hObj parameter is a handle to the desktop object that is receiving input from the user. FALSE otherwise.
            </summary>
            <remarks>Windows Server 2003 and Windows XP/2000:  This value is not supported.</remarks>
        </member>
        <member name="T:PInvoke.User32.PAINTSTRUCT">
            <summary>
             Contains information for an application. This information can be used to paint the client area of a window owned by that application.
            </summary>
        </member>
        <member name="F:PInvoke.User32.PAINTSTRUCT.hdc">
            <summary>
            A handle to the display DC to be used for painting.
            </summary>
        </member>
        <member name="F:PInvoke.User32.PAINTSTRUCT.fErase">
            <summary>
            Indicates whether the background must be erased. This value is nonzero if the application should erase the background.
            The application is responsible for erasing the background if a window class is created without a background brush.
            For more information, see the description of the <see cref="F:PInvoke.User32.WNDCLASS.hbrBackground"/> member.
            </summary>
        </member>
        <member name="F:PInvoke.User32.PAINTSTRUCT.rcPaint">
            <summary>
            A <see cref="T:PInvoke.RECT"/> structure that specifies the upper left and lower right corners of the rectangle in which the painting is requested,
            in device units relative to the upper-left corner of the client area.
            </summary>
        </member>
        <member name="F:PInvoke.User32.PAINTSTRUCT.fRestore">
            <summary>
            Reserved; used internally by the system.
            </summary>
        </member>
        <member name="F:PInvoke.User32.PAINTSTRUCT.fIncUpdate">
            <summary>
            Reserved; used internally by the system.
            </summary>
        </member>
        <member name="F:PInvoke.User32.PAINTSTRUCT.rgbReserved">
            <summary>
            Reserved; used internally by the system.
            </summary>
        </member>
        <member name="T:PInvoke.User32.PeekMessageParams">
            <summary>
            Specifies how messages are to be handled.
            </summary>
            <remarks>By default, all message types are processed. To specify that only certain message should be processed, specify one or more of the PM_QS_* values.</remarks>
        </member>
        <member name="F:PInvoke.User32.PeekMessageParams.PM_NOREMOVE">
            <summary>
            Messages are not removed from the queue after processing by PeekMessage.
            </summary>
        </member>
        <member name="F:PInvoke.User32.PeekMessageParams.PM_REMOVE">
            <summary>
            Messages are removed from the queue after processing by PeekMessage.
            </summary>
        </member>
        <member name="F:PInvoke.User32.PeekMessageParams.PM_NOYIELD">
            <summary>
            Prevents the system from releasing any thread that is waiting for the caller to go idle (see <see cref="M:PInvoke.User32.WaitForInputIdle(System.IntPtr,System.Int32)"/>).
            </summary>
            <remarks>Combine this value with either PM_NOREMOVE or PM_REMOVE.</remarks>
        </member>
        <member name="F:PInvoke.User32.PeekMessageParams.PM_QS_INPUT">
            <summary>
            Process mouse and keyboard messages.
            </summary>
        </member>
        <member name="F:PInvoke.User32.PeekMessageParams.PM_QS_PAINT">
            <summary>
            Process paint messages.
            </summary>
        </member>
        <member name="F:PInvoke.User32.PeekMessageParams.PM_QS_POSTMESSAGE">
            <summary>
            Process all posted messages, including timers and hotkeys.
            </summary>
        </member>
        <member name="F:PInvoke.User32.PeekMessageParams.PM_QS_SENDMESSAGE">
            <summary>
            Process all sent messages.
            </summary>
        </member>
        <member name="T:PInvoke.User32.PeekMessageRemoveFlags">
            <summary>
            Flags to be passed to the <code>wRemoveMsg</code> parameter of
            <see cref="M:PInvoke.User32.PeekMessage(System.IntPtr,System.IntPtr,PInvoke.User32.WindowMessage,PInvoke.User32.WindowMessage,PInvoke.User32.PeekMessageRemoveFlags)" />
            </summary>
        </member>
        <member name="F:PInvoke.User32.PeekMessageRemoveFlags.PM_NOREMOVE">
            <summary>
            Messages are not removed from the queue after processing by
            <see cref="M:PInvoke.User32.PeekMessage(System.IntPtr,System.IntPtr,PInvoke.User32.WindowMessage,PInvoke.User32.WindowMessage,PInvoke.User32.PeekMessageRemoveFlags)" />.
            </summary>
        </member>
        <member name="F:PInvoke.User32.PeekMessageRemoveFlags.PM_REMOVE">
            <summary>
            Messages are removed from the queue after processing by
            <see cref="M:PInvoke.User32.PeekMessage(System.IntPtr,System.IntPtr,PInvoke.User32.WindowMessage,PInvoke.User32.WindowMessage,PInvoke.User32.PeekMessageRemoveFlags)" />.
            </summary>
        </member>
        <member name="F:PInvoke.User32.PeekMessageRemoveFlags.PM_NOYIELD">
            <summary>
            Prevents the system from releasing any thread that is waiting for the caller to go idle (see
            WaitForInputIdle). Combine this value with either <see cref="F:PInvoke.User32.PeekMessageRemoveFlags.PM_NOREMOVE" /> or <see cref="F:PInvoke.User32.PeekMessageRemoveFlags.PM_REMOVE" />.
            </summary>
        </member>
        <member name="F:PInvoke.User32.PeekMessageRemoveFlags.PM_QS_INPUT">
            <summary>Process mouse and keyboard messages.</summary>
        </member>
        <member name="F:PInvoke.User32.PeekMessageRemoveFlags.PM_QS_PAINT">
            <summary>Process paint messages.</summary>
        </member>
        <member name="F:PInvoke.User32.PeekMessageRemoveFlags.PM_QS_POSTMESSAGE">
            <summary>Process all posted messages, including timers and hotkeys.</summary>
        </member>
        <member name="F:PInvoke.User32.PeekMessageRemoveFlags.PM_QS_SENDMESSAGE">
            <summary>Process all sent messages.</summary>
        </member>
        <member name="F:PInvoke.User32.PrintWindowFlags.PW_FULLWINDOW">
            <summary>
                Default option. The entire window is copied to hdcBlt.
            </summary>
        </member>
        <member name="F:PInvoke.User32.PrintWindowFlags.PW_CLIENTONLY">
            <summary>
                Only the client area of the window is copied to hdcBlt.
            </summary>
            <remarks>By default, the entire window is copied.</remarks>
        </member>
        <member name="T:PInvoke.User32.QueueStatusFlags">
            <summary>
            The types of messages for which to check.
            </summary>
        </member>
        <member name="F:PInvoke.User32.QueueStatusFlags.QS_ALLEVENTS">
            <summary>
            An input, <see cref="F:PInvoke.User32.WindowMessage.WM_TIMER"/>, <see cref="F:PInvoke.User32.WindowMessage.WM_PAINT"/>, <see cref="F:PInvoke.User32.WindowMessage.WM_HOTKEY"/>, or posted message is in the queue.
            </summary>
        </member>
        <member name="F:PInvoke.User32.QueueStatusFlags.QS_ALLINPUT">
            <summary>
            Any message is in the queue.
            </summary>
        </member>
        <member name="F:PInvoke.User32.QueueStatusFlags.QS_ALLPOSTMESSAGE">
            <summary>
            A posted message (other than those listed here) is in the queue.
            </summary>
        </member>
        <member name="F:PInvoke.User32.QueueStatusFlags.QS_HOTKEY">
            <summary>
            A <see cref="F:PInvoke.User32.WindowMessage.WM_HOTKEY"/> message is in the queue.
            </summary>
        </member>
        <member name="F:PInvoke.User32.QueueStatusFlags.QS_INPUT">
            <summary>
            An input message is in the queue.
            </summary>
        </member>
        <member name="F:PInvoke.User32.QueueStatusFlags.QS_KEY">
            <summary>
            A <see cref="F:PInvoke.User32.WindowMessage.WM_KEYUP"/>, <see cref="F:PInvoke.User32.WindowMessage.WM_KEYDOWN"/>, <see cref="F:PInvoke.User32.WindowMessage.WM_SYSKEYUP"/>, or <see cref="F:PInvoke.User32.WindowMessage.WM_SYSKEYDOWN"/> message is in the queue
            </summary>
        </member>
        <member name="F:PInvoke.User32.QueueStatusFlags.QS_MOUSE">
            <summary>
            A <see cref="F:PInvoke.User32.WindowMessage.WM_MOUSEMOVE"/> message or mouse-button message (<see cref="F:PInvoke.User32.WindowMessage.WM_LBUTTONUP"/>, <see cref="F:PInvoke.User32.WindowMessage.WM_RBUTTONDOWN"/>, and so on).
            </summary>
        </member>
        <member name="F:PInvoke.User32.QueueStatusFlags.QS_MOUSEBUTTON">
            <summary>
            A mouse-button message (<see cref="F:PInvoke.User32.WindowMessage.WM_LBUTTONUP"/>, <see cref="F:PInvoke.User32.WindowMessage.WM_RBUTTONDOWN"/>, and so on).
            </summary>
        </member>
        <member name="F:PInvoke.User32.QueueStatusFlags.QS_MOUSEMOVE">
            <summary>
            A <see cref="F:PInvoke.User32.WindowMessage.WM_MOUSEMOVE"/> message is in the queue.
            </summary>
        </member>
        <member name="F:PInvoke.User32.QueueStatusFlags.QS_PAINT">
            <summary>
            A <see cref="F:PInvoke.User32.WindowMessage.WM_PAINT"/> message is in the queue.
            </summary>
        </member>
        <member name="F:PInvoke.User32.QueueStatusFlags.QS_POSTMESSAGE">
            <summary>
            A posted message (other than those listed here) is in the queue.
            </summary>
        </member>
        <member name="F:PInvoke.User32.QueueStatusFlags.QS_RAWINPUT">
            <summary>
            A raw input message is in the queue. For more information, see Raw Input.
            </summary>
            <remarks>Windows 2000:  This flag is not supported.</remarks>
        </member>
        <member name="F:PInvoke.User32.QueueStatusFlags.QS_SENDMESSAGE">
            <summary>
            A message sent by another thread or application is in the queue.
            </summary>
        </member>
        <member name="F:PInvoke.User32.QueueStatusFlags.QS_TIMER">
            <summary>
            A <see cref="F:PInvoke.User32.WindowMessage.WM_TIMER"/> message is in the queue.
            </summary>
        </member>
        <member name="T:PInvoke.User32.SafeCursorHandle">
            <summary>
            Represents an HCURSOR handle that can be closed with <see cref="M:PInvoke.User32.DestroyCursor(System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SafeCursorHandle.Null">
            <summary>
            A handle that may be used in place of <see cref="F:System.IntPtr.Zero"/>.
            </summary>
        </member>
        <member name="M:PInvoke.User32.SafeCursorHandle.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.User32.SafeCursorHandle"/> class.
            </summary>
        </member>
        <member name="M:PInvoke.User32.SafeCursorHandle.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.User32.SafeCursorHandle"/> class.
            </summary>
            <param name="preexistingHandle">An object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
                <see langword="true" /> to have the native handle released when this safe handle is disposed or finalized;
                <see langword="false" /> otherwise.
            </param>
        </member>
        <member name="T:PInvoke.User32.SafeDCHandle">
            <summary>
            A SafeHandle to track DC handles.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SafeDCHandle.Null">
            <summary>
            A null handle.
            </summary>
        </member>
        <member name="M:PInvoke.User32.SafeDCHandle.#ctor(System.IntPtr,System.IntPtr,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.User32.SafeDCHandle"/> class.
            </summary>
            <param name="hWnd">The HWND this handle is associated with and must be released with.</param>
            <param name="hDC">The handle to the DC.</param>
            <param name="ownsHandle">
                <see langword="true" /> to have the native handle released when this safe handle is disposed or finalized;
                <see langword="false" /> otherwise.
            </param>
        </member>
        <member name="P:PInvoke.User32.SafeDCHandle.HWnd">
            <summary>
            Gets the HWND this handle is associated with.
            </summary>
        </member>
        <member name="P:PInvoke.User32.SafeDCHandle.IsInvalid">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.User32.SafeDCHandle.ReleaseHandle">
            <inheritdoc />
        </member>
        <member name="T:PInvoke.User32.SafeDesktopHandle">
            <summary>
            Represents a Desktop handle that can be closed with <see cref="M:PInvoke.User32.CloseDesktop(System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SafeDesktopHandle.Null">
            <summary>
            A handle that may be used in place of <see cref="F:System.IntPtr.Zero"/>.
            </summary>
        </member>
        <member name="M:PInvoke.User32.SafeDesktopHandle.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.User32.SafeDesktopHandle"/> class.
            </summary>
        </member>
        <member name="M:PInvoke.User32.SafeDesktopHandle.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.User32.SafeDesktopHandle"/> class.
            </summary>
            <param name="preexistingHandle">An object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
                <see langword="true" /> to have the native handle released when this safe handle is disposed or finalized;
                <see langword="false" /> otherwise.
            </param>
        </member>
        <member name="T:PInvoke.User32.SafeEventHookHandle">
            <summary>
            Represents a windows event Hook that can be removed with <see cref="M:PInvoke.User32.UnhookWinEvent(System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SafeEventHookHandle.Null">
            <summary>
            A handle that may be used in place of <see cref="F:System.IntPtr.Zero"/>.
            </summary>
        </member>
        <member name="M:PInvoke.User32.SafeEventHookHandle.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.User32.SafeEventHookHandle"/> class.
            </summary>
        </member>
        <member name="M:PInvoke.User32.SafeEventHookHandle.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.User32.SafeEventHookHandle"/> class.
            </summary>
            <param name="preexistingHandle">An object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
                <see langword="true" /> to have the native handle released when this safe handle is disposed or finalized;
                <see langword="false" /> otherwise.
            </param>
        </member>
        <member name="P:PInvoke.User32.SafeEventHookHandle.IsInvalid">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.User32.SafeEventHookHandle.ReleaseHandle">
            <inheritdoc />
        </member>
        <member name="T:PInvoke.User32.SafeHookHandle">
            <summary>
            Represents a windows Hook that can be removed with <see cref="M:PInvoke.User32.UnhookWindowsHookEx(System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SafeHookHandle.Null">
            <summary>
            A handle that may be used in place of <see cref="F:System.IntPtr.Zero"/>.
            </summary>
        </member>
        <member name="M:PInvoke.User32.SafeHookHandle.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.User32.SafeHookHandle"/> class.
            </summary>
        </member>
        <member name="M:PInvoke.User32.SafeHookHandle.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.User32.SafeHookHandle"/> class.
            </summary>
            <param name="preexistingHandle">An object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
                <see langword="true" /> to have the native handle released when this safe handle is disposed or finalized;
                <see langword="false" /> otherwise.
            </param>
        </member>
        <member name="P:PInvoke.User32.SafeHookHandle.IsInvalid">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.User32.SafeHookHandle.ReleaseHandle">
            <inheritdoc />
        </member>
        <member name="T:PInvoke.User32.SafeWindowStationHandle">
            <summary>
            Represents a Desktop handle that can be closed with <see cref="M:PInvoke.User32.CloseWindowStation(System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SafeWindowStationHandle.Null">
            <summary>
            A handle that may be used in place of <see cref="F:System.IntPtr.Zero"/>.
            </summary>
        </member>
        <member name="M:PInvoke.User32.SafeWindowStationHandle.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.User32.SafeWindowStationHandle"/> class.
            </summary>
        </member>
        <member name="M:PInvoke.User32.SafeWindowStationHandle.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.User32.SafeWindowStationHandle"/> class.
            </summary>
            <param name="preexistingHandle">An object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
                <see langword="true" /> to have the native handle released when this safe handle is disposed or finalized;
                <see langword="false" /> otherwise.
            </param>
        </member>
        <member name="T:PInvoke.User32.ScanCode">
            <summary>
            General keyboard scan code constants on the same order that it can be found on <see cref="T:PInvoke.User32.VirtualKey" /> constants
            </summary>
            <remarks>Scan codes are device-dependant values, these are general values used by most keyboards.</remarks>
        </member>
        <member name="T:PInvoke.User32.SendMessageTimeoutFlags">
            <summary>
            Possible flag values for <see cref="M:PInvoke.User32.SendMessageTimeout(System.IntPtr,PInvoke.User32.WindowMessage,System.IntPtr,System.IntPtr,PInvoke.User32.SendMessageTimeoutFlags,System.Int32,System.IntPtr@)"/>
            </summary>
        </member>
        <member name="F:PInvoke.User32.SendMessageTimeoutFlags.SMTO_ABORTIFHUNG">
            <summary>
            The function returns without waiting for the time-out period to elapse if the receiving thread appears to not respond or "hangs."
            </summary>
        </member>
        <member name="F:PInvoke.User32.SendMessageTimeoutFlags.SMTO_BLOCK">
            <summary>
            Prevents the calling thread from processing any other requests until the function returns.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SendMessageTimeoutFlags.SMTO_NORMAL">
            <summary>
            The calling thread is not prevented from processing other requests while waiting for the function to return.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SendMessageTimeoutFlags.SMTO_NOTIMEOUTIFNOTHUNG">
            <summary>
            The function does not enforce the time-out period as long as the receiving thread is processing messages.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SendMessageTimeoutFlags.SMTO_ERRORONEXIT">
            <summary>
            The function should return 0 if the receiving window is destroyed or its owning thread dies while the message is being processed.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SetWindowPosFlags.SWP_ASYNCWINDOWPOS">
            <summary>
                If the calling thread and the thread that owns the window are attached to different input queues, the system posts the request to the thread that owns the window. This prevents the calling thread from blocking its execution while other threads process the request.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SetWindowPosFlags.SWP_DEFERERASE">
            <summary>
                Prevents generation of the WM_SYNCPAINT message.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SetWindowPosFlags.SWP_DRAWFRAME">
            <summary>
                Draws a frame (defined in the window's class description) around the window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SetWindowPosFlags.SWP_FRAMECHANGED">
            <summary>
                Applies new frame styles set using the SetWindowLong function. Sends a WM_NCCALCSIZE message to the window, even if the window's size is not being changed. If this flag is not specified, WM_NCCALCSIZE is sent only when the window's size is being changed.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SetWindowPosFlags.SWP_HIDEWINDOW">
            <summary>
                Hides the window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SetWindowPosFlags.SWP_NOACTIVATE">
            <summary>
                Does not activate the window. If this flag is not set, the window is activated and moved to the top of either the topmost or non-topmost group (depending on the setting of the hWndInsertAfter parameter).
            </summary>
        </member>
        <member name="F:PInvoke.User32.SetWindowPosFlags.SWP_NOCOPYBITS">
            <summary>
                Discards the entire contents of the client area. If this flag is not specified, the valid contents of the client area are saved and copied back into the client area after the window is sized or repositioned.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SetWindowPosFlags.SWP_NOMOVE">
            <summary>
                Retains the current position (ignores X and Y parameters).
            </summary>
        </member>
        <member name="F:PInvoke.User32.SetWindowPosFlags.SWP_NOOWNERZORDER">
            <summary>
                Does not change the owner window's position in the Z order.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SetWindowPosFlags.SWP_NOREDRAW">
            <summary>
                Does not redraw changes. If this flag is set, no repainting of any kind occurs. This applies to the client area, the nonclient area (including the title bar and scroll bars), and any part of the parent window uncovered as a result of the window being moved. When this flag is set, the application must explicitly invalidate or redraw any parts of the window and parent window that need redrawing.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SetWindowPosFlags.SWP_NOREPOSITION">
            <summary>
                Same as the SWP_NOOWNERZORDER flag.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SetWindowPosFlags.SWP_NOSENDCHANGING">
            <summary>
                Prevents the window from receiving the WM_WINDOWPOSCHANGING message.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SetWindowPosFlags.SWP_NOSIZE">
            <summary>
                Retains the current size (ignores the cx and cy parameters).
            </summary>
        </member>
        <member name="F:PInvoke.User32.SetWindowPosFlags.SWP_NOZORDER">
            <summary>
                Retains the current Z order (ignores the hWndInsertAfter parameter).
            </summary>
        </member>
        <member name="F:PInvoke.User32.SetWindowPosFlags.SWP_SHOWWINDOW">
            <summary>
                Displays the window.
            </summary>
        </member>
        <member name="T:PInvoke.User32.SpecialWindowHandles">
            <summary>
            Special window handles
            </summary>
        </member>
        <member name="F:PInvoke.User32.SpecialWindowHandles.HWND_TOP">
            <summary>
            Places the window at the top of the Z order.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SpecialWindowHandles.HWND_BOTTOM">
            <summary>
            Places the window at the bottom of the Z order. If the hWnd parameter identifies a
            topmost window, the window loses its topmost status and is placed at the bottom of all
            other windows.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SpecialWindowHandles.HWND_TOPMOST">
            <summary>
            Places the window above all non-topmost windows. The window maintains its topmost
            position even when it is deactivated.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SpecialWindowHandles.HWND_NOTOPMOST">
            <summary>
            Places the window above all non-topmost windows (that is, behind all topmost windows).
            This flag has no effect if the window is already a non-topmost window.
            </summary>
        </member>
        <member name="T:PInvoke.User32.SysCommands">
            <summary>
            wParam options for <see cref="F:PInvoke.User32.WindowMessage.WM_SYSCOMMAND"/>
            </summary>
        </member>
        <member name="F:PInvoke.User32.SysCommands.SC_CLOSE">
            <summary>
            Closes the window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SysCommands.SC_CONTEXTHELP">
            <summary>
            Changes the cursor to a question mark with a pointer. If the user then clicks a control in the dialog box, the control receives a WM_HELP message.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SysCommands.SC_DEFAULT">
            <summary>
            Selects the default item; the user double-clicked the window menu.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SysCommands.SC_HOTKEY">
            <summary>
            Activates the window associated with the application-specified hot key. The lParam parameter identifies the window to activate.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SysCommands.SC_HSCROLL">
            <summary>
            Scrolls horizontally.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SysCommands.SCF_ISSECURE">
            <summary>
            Indicates whether the screen saver is secure.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SysCommands.SC_KEYMENU">
            <summary>
            Retrieves the window menu as a result of a keystroke. For more information, see the Remarks section.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SysCommands.SC_MAXIMIZE">
            <summary>
            Maximizes the window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SysCommands.SC_MINIMIZE">
            <summary>
            Minimizes the window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SysCommands.SC_MONITORPOWER">
            <summary>
            Sets the state of the display. This command supports devices that have power-saving features, such as a battery-powered personal computer.
            The lParam parameter can have the following values:
            -1 (the display is powering on)
            1 (the display is going to low power)
            2 (the display is being shut off)
            </summary>
        </member>
        <member name="F:PInvoke.User32.SysCommands.SC_MOUSEMENU">
            <summary>
            Retrieves the window menu as a result of a mouse click.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SysCommands.SC_MOVE">
            <summary>
            Moves the window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SysCommands.SC_NEXTWINDOW">
            <summary>
            Moves to the next window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SysCommands.SC_PREVWINDOW">
            <summary>
            Moves to the previous window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SysCommands.SC_RESTORE">
            <summary>
            Restores the window to its normal position and size.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SysCommands.SC_SCREENSAVE">
            <summary>
            Executes the screen saver application specified in the [boot]
            section of the System.ini file.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SysCommands.SC_SIZE">
            <summary>
            Sizes the window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SysCommands.SC_TASKLIST">
            <summary>
            Activates the Start menu.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SysCommands.SC_VSCROLL">
            <summary>
            Scrolls vertically.
            </summary>
        </member>
        <member name="T:PInvoke.User32.SystemMetric">
            <summary>
            Flags used in the <see cref="M:PInvoke.User32.GetSystemMetrics(PInvoke.User32.SystemMetric)"/> function
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_ARRANGE">
            <summary>
            The flags that specify how the system arranged minimized windows. For more information,
            see the Remarks section in this topic.
            </summary>
            <remarks>
            The SM_ARRANGE setting specifies how the system arranges minimized windows, and consists of a starting position and a direction.The starting position can be one of the following values.
            Value Meaning
            ARW_BOTTOMLEFT Start at the lower-left corner of the screen.The default position.
            ARW_BOTTOMRIGHT Start at the lower-right corner of the screen.Equivalent to ARW_STARTRIGHT.
            ARW_TOPLEFT Start at the upper-left corner of the screen.Equivalent to ARW_STARTTOP.
            ARW_TOPRIGHT Start at the upper-right corner of the screen.Equivalent to ARW_STARTTOP | SRW_STARTRIGHT.
            The direction in which to arrange minimized windows can be one of the following values.
            Value Meaning
            ARW_DOWN Arrange vertically, top to bottom.
            ARW_HIDE Hide minimized windows by moving them off the visible area of the screen.
            ARW_LEFT Arrange horizontally, left to right.
            ARW_RIGHT Arrange horizontally, right to left.
            ARW_UP Arrange vertically, bottom to top.
            </remarks>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CLEANBOOT">
            <summary>
            The value that specifies how the system is started: 0 Normal boot 1 Fail-safe boot 2
            Fail-safe with network boot A fail-safe boot (also called SafeBoot, Safe Mode, or Clean
            Boot) bypasses the user startup files.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CMONITORS">
            <summary>
            The number of display monitors on a desktop. For more information, see the Remarks
            section in this topic.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CMOUSEBUTTONS">
            <summary>
            The number of buttons on a mouse, or zero if no mouse is installed.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CXBORDER">
            <summary>
            The width of a window border, in pixels. This is equivalent to the SM_CXEDGE value for
            windows with the 3-D look.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CXCURSOR">
            <summary>
            The width of a cursor, in pixels. The system cannot create cursors of other sizes.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CXDLGFRAME">
            <summary>
            This value is the same as SM_CXFIXEDFRAME.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CXDOUBLECLK">
            <summary>
            The width of the rectangle around the location of a first click in a double-click
            sequence, in pixels. , The second click must occur within the rectangle that is defined
            by SM_CXDOUBLECLK and SM_CYDOUBLECLK for the system to consider the two clicks a
            double-click. The two clicks must also occur within a specified time. To set the width of
            the double-click rectangle, call SystemParametersInfo with SPI_SETDOUBLECLKWIDTH.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CXDRAG">
            <summary>
            The number of pixels on either side of a mouse-down point that the mouse pointer can move
            before a drag operation begins. This allows the user to click and release the mouse
            button easily without unintentionally starting a drag operation. If this value is
            negative, it is subtracted from the left of the mouse-down point and added to the right
            of it.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CXEDGE">
            <summary>
            The width of a 3-D border, in pixels. This metric is the 3-D counterpart of SM_CXBORDER.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CXFIXEDFRAME">
            <summary>
            The thickness of the frame around the perimeter of a window that has a caption but is not
            sizable, in pixels. SM_CXFIXEDFRAME is the height of the horizontal border, and
            SM_CYFIXEDFRAME is the width of the vertical border. This value is the same as SM_CXDLGFRAME.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CXFOCUSBORDER">
            <summary>
            The width of the left and right edges of the focus rectangle that the DrawFocusRectdraws.
            This value is in pixels. Windows 2000: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CXFRAME">
            <summary>
            This value is the same as SM_CXSIZEFRAME.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CXFULLSCREEN">
            <summary>
            The width of the client area for a full-screen window on the primary display monitor, in
            pixels. To get the coordinates of the portion of the screen that is not obscured by the
            system taskbar or by application desktop toolbars, call the SystemParametersInfo function
            with the SPI_GETWORKAREA value.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CXHSCROLL">
            <summary>
            The width of the arrow bitmap on a horizontal scroll bar, in pixels.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CXHTHUMB">
            <summary>
            The width of the thumb box in a horizontal scroll bar, in pixels.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CXICON">
            <summary>
            The default width of an icon, in pixels. The LoadIcon function can load only icons with
            the dimensions that SM_CXICON and SM_CYICON specifies.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CXICONSPACING">
            <summary>
            The width of a grid cell for items in large icon view, in pixels. Each item fits into a
            rectangle of size SM_CXICONSPACING by SM_CYICONSPACING when arranged. This value is
            always greater than or equal to SM_CXICON.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CXMAXIMIZED">
            <summary>
            The default width, in pixels, of a maximized top-level window on the primary display monitor.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CXMAXTRACK">
            <summary>
            The default maximum width of a window that has a caption and sizing borders, in pixels.
            This metric refers to the entire desktop. The user cannot drag the window frame to a size
            larger than these dimensions. A window can override this value by processing the
            WM_GETMINMAXINFO message.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CXMENUCHECK">
            <summary>
            The width of the default menu check-mark bitmap, in pixels.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CXMENUSIZE">
            <summary>
            The width of menu bar buttons, such as the child window close button that is used in the
            multiple document interface, in pixels.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CXMIN">
            <summary>
            The minimum width of a window, in pixels.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CXMINIMIZED">
            <summary>
            The width of a minimized window, in pixels.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CXMINSPACING">
            <summary>
            The width of a grid cell for a minimized window, in pixels. Each minimized window fits
            into a rectangle this size when arranged. This value is always greater than or equal to SM_CXMINIMIZED.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CXMINTRACK">
            <summary>
            The minimum tracking width of a window, in pixels. The user cannot drag the window frame
            to a size smaller than these dimensions. A window can override this value by processing
            the WM_GETMINMAXINFO message.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CXPADDEDBORDER">
            <summary>
            The amount of border padding for captioned windows, in pixels. Windows XP/2000: This
            value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CXSCREEN">
            <summary>
            The width of the screen of the primary display monitor, in pixels. This is the same value
            obtained by calling GetDeviceCaps as follows: GetDeviceCaps( hdcPrimaryMonitor, HORZRES).
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CXSIZE">
            <summary>
            The width of a button in a window caption or title bar, in pixels.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CXSIZEFRAME">
            <summary>
            The thickness of the sizing border around the perimeter of a window that can be resized,
            in pixels. SM_CXSIZEFRAME is the width of the horizontal border, and SM_CYSIZEFRAME is
            the height of the vertical border. This value is the same as SM_CXFRAME.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CXSMICON">
            <summary>
            The recommended width of a small icon, in pixels. Small icons typically appear in window
            captions and in small icon view.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CXSMSIZE">
            <summary>
            The width of small caption buttons, in pixels.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CXVIRTUALSCREEN">
            <summary>
            The width of the virtual screen, in pixels. The virtual screen is the bounding rectangle
            of all display monitors. The SM_XVIRTUALSCREEN metric is the coordinates for the left
            side of the virtual screen.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CXVSCROLL">
            <summary>
            The width of a vertical scroll bar, in pixels.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYBORDER">
            <summary>
            The height of a window border, in pixels. This is equivalent to the SM_CYEDGE value for
            windows with the 3-D look.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYCAPTION">
            <summary>
            The height of a caption area, in pixels.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYCURSOR">
            <summary>
            The height of a cursor, in pixels. The system cannot create cursors of other sizes.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYDLGFRAME">
            <summary>
            This value is the same as SM_CYFIXEDFRAME.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYDOUBLECLK">
            <summary>
            The height of the rectangle around the location of a first click in a double-click
            sequence, in pixels. The second click must occur within the rectangle defined by
            SM_CXDOUBLECLK and SM_CYDOUBLECLK for the system to consider the two clicks a
            double-click. The two clicks must also occur within a specified time. To set the height
            of the double-click rectangle, call SystemParametersInfo with SPI_SETDOUBLECLKHEIGHT.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYDRAG">
            <summary>
            The number of pixels above and below a mouse-down point that the mouse pointer can move
            before a drag operation begins. This allows the user to click and release the mouse
            button easily without unintentionally starting a drag operation. If this value is
            negative, it is subtracted from above the mouse-down point and added below it.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYEDGE">
            <summary>
            The height of a 3-D border, in pixels. This is the 3-D counterpart of SM_CYBORDER.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYFIXEDFRAME">
            <summary>
            The thickness of the frame around the perimeter of a window that has a caption but is not
            sizable, in pixels. SM_CXFIXEDFRAME is the height of the horizontal border, and
            SM_CYFIXEDFRAME is the width of the vertical border. This value is the same as SM_CYDLGFRAME.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYFOCUSBORDER">
            <summary>
            The height of the top and bottom edges of the focus rectangle drawn byDrawFocusRect. This
            value is in pixels. Windows 2000: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYFRAME">
            <summary>
            This value is the same as SM_CYSIZEFRAME.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYFULLSCREEN">
            <summary>
            The height of the client area for a full-screen window on the primary display monitor, in
            pixels. To get the coordinates of the portion of the screen not obscured by the system
            taskbar or by application desktop toolbars, call the SystemParametersInfo function with
            the SPI_GETWORKAREA value.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYHSCROLL">
            <summary>
            The height of a horizontal scroll bar, in pixels.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYICON">
            <summary>
            The default height of an icon, in pixels. The LoadIcon function can load only icons with
            the dimensions SM_CXICON and SM_CYICON.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYICONSPACING">
            <summary>
            The height of a grid cell for items in large icon view, in pixels. Each item fits into a
            rectangle of size SM_CXICONSPACING by SM_CYICONSPACING when arranged. This value is
            always greater than or equal to SM_CYICON.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYKANJIWINDOW">
            <summary>
            For double byte character set versions of the system, this is the height of the Kanji
            window at the bottom of the screen, in pixels.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYMAXIMIZED">
            <summary>
            The default height, in pixels, of a maximized top-level window on the primary display monitor.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYMAXTRACK">
            <summary>
            The default maximum height of a window that has a caption and sizing borders, in pixels.
            This metric refers to the entire desktop. The user cannot drag the window frame to a size
            larger than these dimensions. A window can override this value by processing the
            WM_GETMINMAXINFO message.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYMENU">
            <summary>
            The height of a single-line menu bar, in pixels.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYMENUCHECK">
            <summary>
            The height of the default menu check-mark bitmap, in pixels.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYMENUSIZE">
            <summary>
            The height of menu bar buttons, such as the child window close button that is used in the
            multiple document interface, in pixels.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYMIN">
            <summary>
            The minimum height of a window, in pixels.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYMINIMIZED">
            <summary>
            The height of a minimized window, in pixels.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYMINSPACING">
            <summary>
            The height of a grid cell for a minimized window, in pixels. Each minimized window fits
            into a rectangle this size when arranged. This value is always greater than or equal to SM_CYMINIMIZED.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYMINTRACK">
            <summary>
            The minimum tracking height of a window, in pixels. The user cannot drag the window frame
            to a size smaller than these dimensions. A window can override this value by processing
            the WM_GETMINMAXINFO message.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYSCREEN">
            <summary>
            The height of the screen of the primary display monitor, in pixels. This is the same
            value obtained by calling GetDeviceCaps as follows: GetDeviceCaps( hdcPrimaryMonitor, VERTRES).
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYSIZE">
            <summary>
            The height of a button in a window caption or title bar, in pixels.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYSIZEFRAME">
            <summary>
            The thickness of the sizing border around the perimeter of a window that can be resized,
            in pixels. SM_CXSIZEFRAME is the width of the horizontal border, and SM_CYSIZEFRAME is
            the height of the vertical border. This value is the same as SM_CYFRAME.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYSMCAPTION">
            <summary>
            The height of a small caption, in pixels.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYSMICON">
            <summary>
            The recommended height of a small icon, in pixels. Small icons typically appear in window
            captions and in small icon view.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYSMSIZE">
            <summary>
            The height of small caption buttons, in pixels.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYVIRTUALSCREEN">
            <summary>
            The height of the virtual screen, in pixels. The virtual screen is the bounding rectangle
            of all display monitors. The SM_YVIRTUALSCREEN metric is the coordinates for the top of
            the virtual screen.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYVSCROLL">
            <summary>
            The height of the arrow bitmap on a vertical scroll bar, in pixels.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_CYVTHUMB">
            <summary>
            The height of the thumb box in a vertical scroll bar, in pixels.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_DBCSENABLED">
            <summary>
            Nonzero if User32.dll supports DBCS; otherwise, 0.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_DEBUG">
            <summary>
            Nonzero if the debug version of User.exe is installed; otherwise, 0.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_DIGITIZER">
            <summary>
            Nonzero if the current operating system is Windows 7 or Windows Server 2008 R2 and the
            Tablet PC Input service is started; otherwise, 0. The return value is a bitmask that
            specifies the type of digitizer input supported by the device. For more information, see
            Remarks. Windows Server 2008, Windows Vista, and Windows XP/2000: This value is not supported.
            </summary>
            <remarks>
            The SM_DIGITIZER setting specifies the type of digitizers that are installed on a device running Windows 7 or Windows Server 2008 R2.The return value is a bitmask that specifies one or more of the following values.
            Value Meaning
            NID_INTEGRATED_TOUCH
            0x01
            The device has an integrated touch digitizer.
            NID_EXTERNAL_TOUCH
            0x02
            The device has an external touch digitizer.
            NID_INTEGRATED_PEN
            0x04
            The device has an integrated pen digitizer.
            NID_EXTERNAL_PEN
            0x08
            The device has an external pen digitizer.
            NID_MULTI_INPUT
            0x40
            The device supports multiple sources of digitizer input.
            NID_READY
            0x80
            The device is ready to receive digitizer input.
            </remarks>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_IMMENABLED">
            <summary>
            Nonzero if Input Method Manager/Input Method Editor features are enabled; otherwise,
            0. SM_IMMENABLED indicates whether the system is ready to use a Unicode-based IME on a
            Unicode application. To ensure that a language-dependent IME works, check SM_DBCSENABLED
            and the system ANSI code page. Otherwise the ANSI-to-Unicode conversion may not be
            performed correctly, or some components like fonts or registry settings may not be present.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_MAXIMUMTOUCHES">
            <summary>
            Nonzero if there are digitizers in the system; otherwise, 0. SM_MAXIMUMTOUCHES returns
            the aggregate maximum of the maximum number of contacts supported by every digitizer in
            the system. If the system has only single-touch digitizers, the return value is 1. If the
            system has multi-touch digitizers, the return value is the number of simultaneous
            contacts the hardware can provide. Windows Server 2008, Windows Vista, and Windows
            XP/2000: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_MEDIACENTER">
            <summary>
            Nonzero if the current operating system is the Windows XP, Media Center Edition, 0 if not.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_MENUDROPALIGNMENT">
            <summary>
            Nonzero if drop-down menus are right-aligned with the corresponding menu-bar item; 0 if
            the menus are left-aligned.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_MIDEASTENABLED">
            <summary>
            Nonzero if the system is enabled for Hebrew and Arabic languages, 0 if not.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_MOUSEPRESENT">
            <summary>
            Nonzero if a mouse is installed; otherwise, 0. This value is rarely zero, because of
            support for virtual mice and because some systems detect the presence of the port instead
            of the presence of a mouse.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_MOUSEHORIZONTALWHEELPRESENT">
            <summary>
            Nonzero if a mouse with a horizontal scroll wheel is installed; otherwise 0.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_MOUSEWHEELPRESENT">
            <summary>
            Nonzero if a mouse with a vertical scroll wheel is installed; otherwise 0.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_NETWORK">
            <summary>
            The least significant bit is set if a network is present; otherwise, it is cleared. The
            other bits are reserved for future use.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_PENWINDOWS">
            <summary>
            Nonzero if the Microsoft Windows for Pen computing extensions are installed; zero otherwise.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_REMOTECONTROL">
            <summary>
            This system metric is used in a Terminal Services environment to determine if the current
            Terminal Server session is being remotely controlled. Its value is nonzero if the current
            session is remotely controlled; otherwise, 0. You can use terminal services management
            tools such as Terminal Services Manager (tsadmin.msc) and shadow.exe to control a remote
            session. When a session is being remotely controlled, another user can view the contents
            of that session and potentially interact with it.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_REMOTESESSION">
            <summary>
            This system metric is used in a Terminal Services environment. If the calling process is
            associated with a Terminal Services client session, the return value is nonzero. If the
            calling process is associated with the Terminal Services console session, the return
            value is 0. Windows Server 2003 and Windows XP: The console session is not necessarily
            the physical console. For more information, seeWTSGetActiveConsoleSessionId.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_SAMEDISPLAYFORMAT">
            <summary>
            Nonzero if all the display monitors have the same color format, otherwise, 0. Two
            displays can have the same bit depth, but different color formats. For example, the red,
            green, and blue pixels can be encoded with different numbers of bits, or those bits can
            be located in different places in a pixel color value.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_SECURE">
            <summary>
            This system metric should be ignored; it always returns 0.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_SERVERR2">
            <summary>
            The build number if the system is Windows Server 2003 R2; otherwise, 0.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_SHOWSOUNDS">
            <summary>
            Nonzero if the user requires an application to present information visually in situations
            where it would otherwise present the information only in audible form; otherwise, 0.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_SHUTTINGDOWN">
            <summary>
            Nonzero if the current session is shutting down; otherwise, 0. Windows 2000: This value
            is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_SLOWMACHINE">
            <summary>
            Nonzero if the computer has a low-end (slow) processor; otherwise, 0.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_STARTER">
            <summary>
            Nonzero if the current operating system is Windows 7 Starter Edition, Windows Vista
            Starter, or Windows XP Starter Edition; otherwise, 0.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_SWAPBUTTON">
            <summary>
            Nonzero if the meanings of the left and right mouse buttons are swapped; otherwise, 0.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_TABLETPC">
            <summary>
            Nonzero if the current operating system is the Windows XP Tablet PC edition or if the
            current operating system is Windows Vista or Windows 7 and the Tablet PC Input service is
            started; otherwise, 0. The SM_DIGITIZER setting indicates the type of digitizer input
            supported by a device running Windows 7 or Windows Server 2008 R2. For more information,
            see Remarks.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_XVIRTUALSCREEN">
            <summary>
            The coordinates for the left side of the virtual screen. The virtual screen is the
            bounding rectangle of all display monitors. The SM_CXVIRTUALSCREEN metric is the width of
            the virtual screen.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemMetric.SM_YVIRTUALSCREEN">
            <summary>
            The coordinates for the top of the virtual screen. The virtual screen is the bounding
            rectangle of all display monitors. The SM_CYVIRTUALSCREEN metric is the height of the
            virtual screen.
            </summary>
        </member>
        <member name="T:PInvoke.User32.SystemParametersInfoAction">
            <summary>
            Used to inform the <see cref="M:PInvoke.User32.SystemParametersInfo(PInvoke.User32.SystemParametersInfoAction,System.UInt32,System.Void*,PInvoke.User32.SystemParametersInfoFlags)"/> function of the action to be executed
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETBEEP">
            <summary>
            Determines whether the warning beeper is on. The pvParam parameter must point to a BOOL
            variable that receives TRUE if the beeper is on, or FALSE if it is off.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETBEEP">
            <summary>
            Turns the warning beeper on or off. The uiParam parameter specifies TRUE for on, or FALSE
            for off.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETMOUSE">
            <summary>
            Retrieves the two mouse threshold values and the mouse speed.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETMOUSE">
            <summary>
            Sets the two mouse threshold values and the mouse speed.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETBORDER">
            <summary>
            Retrieves the border multiplier factor that determines the width of a window's sizing
            border. The pvParam parameter must point to an integer variable that receives this value.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETBORDER">
            <summary>
            Sets the border multiplier factor that determines the width of a window's sizing border.
            The uiParam parameter specifies the new value.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETKEYBOARDSPEED">
            <summary>
            Retrieves the keyboard repeat-speed setting, which is a value in the range from 0
            (approximately 2.5 repetitions per second) through 31 (approximately 30 repetitions per
            second). The actual repeat rates are hardware-dependent and may vary from a linear scale
            by as much as 20%. The pvParam parameter must point to a DWORD variable that receives the setting
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETKEYBOARDSPEED">
            <summary>
            Sets the keyboard repeat-speed setting. The uiParam parameter must specify a value in the
            range from 0 (approximately 2.5 repetitions per second) through 31 (approximately 30
            repetitions per second). The actual repeat rates are hardware-dependent and may vary from
            a linear scale by as much as 20%. If uiParam is greater than 31, the parameter is set to 31.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_LANGDRIVER">
            <summary>
            Not implemented.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_ICONHORIZONTALSPACING">
            <summary>
            Sets or retrieves the width, in pixels, of an icon cell. The system uses this rectangle
            to arrange icons in large icon view. To set this value, set uiParam to the new value and
            set pvParam to null. You cannot set this value to less than SM_CXICON. To retrieve this
            value, pvParam must point to an integer that receives the current value.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETSCREENSAVETIMEOUT">
            <summary>
            Retrieves the screen saver time-out value, in seconds. The pvParam parameter must point
            to an integer variable that receives the value.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETSCREENSAVETIMEOUT">
            <summary>
            Sets the screen saver time-out value to the value of the uiParam parameter. This value is
            the amount of time, in seconds, that the system must be idle before the screen saver activates.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETSCREENSAVEACTIVE">
            <summary>
            Determines whether screen saving is enabled. The pvParam parameter must point to a bool
            variable that receives TRUE if screen saving is enabled, or FALSE otherwise. Does not
            work for Windows 7: http://msdn.microsoft.com/en-us/library/windows/desktop/ms724947(v=vs.85).aspx
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETSCREENSAVEACTIVE">
            <summary>
            Sets the state of the screen saver. The uiParam parameter specifies TRUE to activate
            screen saving, or FALSE to deactivate it.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETGRIDGRANULARITY">
            <summary>
            Retrieves the current granularity value of the desktop sizing grid. The pvParam parameter
            must point to an integer variable that receives the granularity.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETGRIDGRANULARITY">
            <summary>
            Sets the granularity of the desktop sizing grid to the value of the uiParam parameter.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETDESKWALLPAPER">
            <summary>
            Sets the desktop wallpaper. The value of the pvParam parameter determines the new
            wallpaper. To specify a wallpaper bitmap, set pvParam to point to a null-terminated
            string containing the name of a bitmap file. Setting pvParam to "" removes the wallpaper.
            Setting pvParam to SETWALLPAPER_DEFAULT or null reverts to the default wallpaper.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETDESKPATTERN">
            <summary>
            Sets the current desktop pattern by causing Windows to read the Pattern= setting from the
            WIN.INI file.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETKEYBOARDDELAY">
            <summary>
            Retrieves the keyboard repeat-delay setting, which is a value in the range from 0
            (approximately 250 ms delay) through 3 (approximately 1 second delay). The actual delay
            associated with each value may vary depending on the hardware. The pvParam parameter must
            point to an integer variable that receives the setting.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETKEYBOARDDELAY">
            <summary>
            Sets the keyboard repeat-delay setting. The uiParam parameter must specify 0, 1, 2, or 3,
            where zero sets the shortest delay (approximately 250 ms) and 3 sets the longest delay
            (approximately 1 second). The actual delay associated with each value may vary depending
            on the hardware.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_ICONVERTICALSPACING">
            <summary>
            Sets or retrieves the height, in pixels, of an icon cell. To set this value, set uiParam
            to the new value and set pvParam to null. You cannot set this value to less than
            SM_CYICON. To retrieve this value, pvParam must point to an integer that receives the
            current value.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETICONTITLEWRAP">
            <summary>
            Determines whether icon-title wrapping is enabled. The pvParam parameter must point to a
            bool variable that receives TRUE if enabled, or FALSE otherwise.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETICONTITLEWRAP">
            <summary>
            Turns icon-title wrapping on or off. The uiParam parameter specifies TRUE for on, or
            FALSE for off.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETMENUDROPALIGNMENT">
            <summary>
            Determines whether pop-up menus are left-aligned or right-aligned, relative to the
            corresponding menu-bar item. The pvParam parameter must point to a bool variable that
            receives TRUE if left-aligned, or FALSE otherwise.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETMENUDROPALIGNMENT">
            <summary>
            Sets the alignment value of pop-up menus. The uiParam parameter specifies TRUE for right
            alignment, or FALSE for left alignment.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETDOUBLECLKWIDTH">
            <summary>
            Sets the width of the double-click rectangle to the value of the uiParam parameter. The
            double-click rectangle is the rectangle within which the second click of a double-click
            must fall for it to be registered as a double-click. To retrieve the width of the
            double-click rectangle, call GetSystemMetrics with the SM_CXDOUBLECLK flag.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETDOUBLECLKHEIGHT">
            <summary>
            Sets the height of the double-click rectangle to the value of the uiParam parameter. The
            double-click rectangle is the rectangle within which the second click of a double-click
            must fall for it to be registered as a double-click. To retrieve the height of the
            double-click rectangle, call GetSystemMetrics with the SM_CYDOUBLECLK flag.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETICONTITLELOGFONT">
            <summary>
            Retrieves the logical font information for the current icon-title font. The uiParam
            parameter specifies the size of a LOGFONT structure, and the pvParam parameter must point
            to the LOGFONT structure to fill in.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETDOUBLECLICKTIME">
            <summary>
            Sets the double-click time for the mouse to the value of the uiParam parameter. The
            double-click time is the maximum number of milliseconds that can occur between the first
            and second clicks of a double-click. You can also call the SetDoubleClickTime function to
            set the double-click time. To get the current double-click time, call the
            GetDoubleClickTime function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETMOUSEBUTTONSWAP">
            <summary>
            Swaps or restores the meaning of the left and right mouse buttons. The uiParam parameter
            specifies TRUE to swap the meanings of the buttons, or FALSE to restore their original meanings.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETICONTITLELOGFONT">
            <summary>
            Sets the font that is used for icon titles. The uiParam parameter specifies the size of a
            LOGFONT structure, and the pvParam parameter must point to a LOGFONT structure.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETFASTTASKSWITCH">
            <summary>
            This flag is obsolete. Previous versions of the system use this flag to determine whether
            ALT+TAB fast task switching is enabled. For Windows 95, Windows 98, and Windows NT
            version 4.0 and later, fast task switching is always enabled.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETFASTTASKSWITCH">
            <summary>
            This flag is obsolete. Previous versions of the system use this flag to enable or disable
            ALT+TAB fast task switching. For Windows 95, Windows 98, and Windows NT version 4.0 and
            later, fast task switching is always enabled.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETDRAGFULLWINDOWS">
            <summary>
            Sets dragging of full windows either on or off. The uiParam parameter specifies TRUE for
            on, or FALSE for off. Windows 95: This flag is supported only if Windows Plus! is
            installed. See SPI_GETWINDOWSEXTENSION.
            </summary>
            <remarks>#if(WINVER >= 0x0400)</remarks>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETDRAGFULLWINDOWS">
            <summary>
            Determines whether dragging of full windows is enabled. The pvParam parameter must point
            to a BOOL variable that receives TRUE if enabled, or FALSE otherwise. Windows
            95: This flag is supported only if Windows Plus! is installed. See SPI_GETWINDOWSEXTENSION.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETNONCLIENTMETRICS">
            <summary>
            Retrieves the metrics associated with the nonclient area of nonminimized windows. The
            pvParam parameter must point to a NONCLIENTMETRICS structure that receives the
            information. Set the cbSize member of this structure and the uiParam parameter to sizeof(NONCLIENTMETRICS).
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETNONCLIENTMETRICS">
            <summary>
            Sets the metrics associated with the nonclient area of nonminimized windows. The pvParam
            parameter must point to a NONCLIENTMETRICS structure that contains the new parameters.
            Set the cbSize member of this structure and the uiParam parameter to
            sizeof(NONCLIENTMETRICS). Also, the lfHeight member of the LOGFONT structure must be a
            negative value.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETMINIMIZEDMETRICS">
            <summary>
            Retrieves the metrics associated with minimized windows. The pvParam parameter must point
            to a MINIMIZEDMETRICS structure that receives the information. Set the cbSize member of
            this structure and the uiParam parameter to sizeof(MINIMIZEDMETRICS).
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETMINIMIZEDMETRICS">
            <summary>
            Sets the metrics associated with minimized windows. The pvParam parameter must point to a
            MINIMIZEDMETRICS structure that contains the new parameters. Set the cbSize member of
            this structure and the uiParam parameter to sizeof(MINIMIZEDMETRICS).
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETICONMETRICS">
            <summary>
            Retrieves the metrics associated with icons. The pvParam parameter must point to an
            ICONMETRICS structure that receives the information. Set the cbSize member of this
            structure and the uiParam parameter to sizeof(ICONMETRICS).
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETICONMETRICS">
            <summary>
            Sets the metrics associated with icons. The pvParam parameter must point to an
            ICONMETRICS structure that contains the new parameters. Set the cbSize member of this
            structure and the uiParam parameter to sizeof(ICONMETRICS).
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETWORKAREA">
            <summary>
            Sets the size of the work area. The work area is the portion of the screen not obscured
            by the system taskbar or by application desktop toolbars. The pvParam parameter is a
            pointer to a RECT structure that specifies the new work area rectangle, expressed in
            virtual screen coordinates. In a system with multiple display monitors, the function sets
            the work area of the monitor that contains the specified rectangle.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETWORKAREA">
            <summary>
            Retrieves the size of the work area on the primary display monitor. The work area is the
            portion of the screen not obscured by the system taskbar or by application desktop
            toolbars. The pvParam parameter must point to a RECT structure that receives the
            coordinates of the work area, expressed in virtual screen coordinates. To get the work
            area of a monitor other than the primary display monitor, call the GetMonitorInfo function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETPENWINDOWS">
            <summary>
            Windows Me/98/95: Pen windows is being loaded or unloaded. The uiParam parameter is TRUE
            when loading and FALSE when unloading pen windows. The pvParam parameter is null.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETHIGHCONTRAST">
            <summary>
            Retrieves information about the HighContrast accessibility feature. The pvParam parameter
            must point to a HIGHCONTRAST structure that receives the information. Set the cbSize
            member of this structure and the uiParam parameter to sizeof(HIGHCONTRAST). For a general
            discussion, see remarks. Windows NT: This value is not supported.
            </summary>
            <remarks>
            There is a difference between the High Contrast color scheme and the High Contrast Mode.
            The High Contrast color scheme changes the system colors to colors that have obvious
            contrast; you switch to this color scheme by using the Display Options in the control
            panel. The High Contrast Mode, which uses SPI_GETHIGHCONTRAST and SPI_SETHIGHCONTRAST,
            advises applications to modify their appearance for visually-impaired users. It involves
            such things as audible warning to users and customized color scheme (using the
            Accessibility Options in the control panel). For more information, see HIGHCONTRAST on
            MSDN. For more information on general accessibility features, see Accessibility on MSDN.
            </remarks>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETHIGHCONTRAST">
            <summary>
            Sets the parameters of the HighContrast accessibility feature. The pvParam parameter must
            point to a HIGHCONTRAST structure that contains the new parameters. Set the cbSize member
            of this structure and the uiParam parameter to sizeof(HIGHCONTRAST). Windows NT: This
            value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETKEYBOARDPREF">
            <summary>
            Determines whether the user relies on the keyboard instead of the mouse, and wants
            applications to display keyboard interfaces that would otherwise be hidden. The pvParam
            parameter must point to a BOOL variable that receives TRUE if the user relies on the
            keyboard; or FALSE otherwise. Windows NT: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETKEYBOARDPREF">
            <summary>
            Sets the keyboard preference. The uiParam parameter specifies TRUE if the user relies on
            the keyboard instead of the mouse, and wants applications to display keyboard interfaces
            that would otherwise be hidden; uiParam is FALSE otherwise. Windows NT: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETSCREENREADER">
            <summary>
            Determines whether a screen reviewer utility is running. A screen reviewer utility
            directs textual information to an output device, such as a speech synthesizer or Braille
            display. When this flag is set, an application should provide textual information in
            situations where it would otherwise present the information graphically. The pvParam
            parameter is a pointer to a BOOL variable that receives TRUE if a screen reviewer utility
            is running, or FALSE otherwise. Windows NT: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETSCREENREADER">
            <summary>
            Determines whether a screen review utility is running. The uiParam parameter specifies
            TRUE for on, or FALSE for off. Windows NT: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETANIMATION">
            <summary>
            Retrieves the animation effects associated with user actions. The pvParam parameter must
            point to an ANIMATIONINFO structure that receives the information. Set the cbSize member
            of this structure and the uiParam parameter to sizeof(ANIMATIONINFO).
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETANIMATION">
            <summary>
            Sets the animation effects associated with user actions. The pvParam parameter must point
            to an ANIMATIONINFO structure that contains the new parameters. Set the cbSize member of
            this structure and the uiParam parameter to sizeof(ANIMATIONINFO).
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETFONTSMOOTHING">
            <summary>
            Determines whether the font smoothing feature is enabled. This feature uses font
            antialiasing to make font curves appear smoother by painting pixels at different gray
            levels. The pvParam parameter must point to a BOOL variable that receives TRUE if the
            feature is enabled, or FALSE if it is not. Windows 95: This flag is supported only if
            Windows Plus! is installed. See SPI_GETWINDOWSEXTENSION.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETFONTSMOOTHING">
            <summary>
            Enables or disables the font smoothing feature, which uses font antialiasing to make font
            curves appear smoother by painting pixels at different gray levels. To enable the
            feature, set the uiParam parameter to TRUE. To disable the feature, set uiParam to FALSE.
            Windows 95: This flag is supported only if Windows Plus! is installed. See SPI_GETWINDOWSEXTENSION.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETDRAGWIDTH">
            <summary>
            Sets the width, in pixels, of the rectangle used to detect the start of a drag operation.
            Set uiParam to the new value. To retrieve the drag width, call GetSystemMetrics with the
            SM_CXDRAG flag.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETDRAGHEIGHT">
            <summary>
            Sets the height, in pixels, of the rectangle used to detect the start of a drag
            operation. Set uiParam to the new value. To retrieve the drag height, call
            GetSystemMetrics with the SM_CYDRAG flag.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETHANDHELD">
            <summary>
            Used internally; applications should not use this value.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETLOWPOWERTIMEOUT">
            <summary>
            Retrieves the time-out value for the low-power phase of screen saving. The pvParam
            parameter must point to an integer variable that receives the value. This flag is
            supported for 32-bit applications only. Windows NT, Windows Me/98: This flag is supported
            for 16-bit and 32-bit applications. Windows 95: This flag is supported for 16-bit
            applications only.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETPOWEROFFTIMEOUT">
            <summary>
            Retrieves the time-out value for the power-off phase of screen saving. The pvParam
            parameter must point to an integer variable that receives the value. This flag is
            supported for 32-bit applications only. Windows NT, Windows Me/98: This flag is supported
            for 16-bit and 32-bit applications. Windows 95: This flag is supported for 16-bit
            applications only.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETLOWPOWERTIMEOUT">
            <summary>
            Sets the time-out value, in seconds, for the low-power phase of screen saving. The
            uiParam parameter specifies the new value. The pvParam parameter must be null. This flag
            is supported for 32-bit applications only. Windows NT, Windows Me/98: This flag is
            supported for 16-bit and 32-bit applications. Windows 95: This flag is supported for
            16-bit applications only.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETPOWEROFFTIMEOUT">
            <summary>
            Sets the time-out value, in seconds, for the power-off phase of screen saving. The
            uiParam parameter specifies the new value. The pvParam parameter must be null. This flag
            is supported for 32-bit applications only. Windows NT, Windows Me/98: This flag is
            supported for 16-bit and 32-bit applications. Windows 95: This flag is supported for
            16-bit applications only.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETLOWPOWERACTIVE">
            <summary>
            Determines whether the low-power phase of screen saving is enabled. The pvParam parameter
            must point to a BOOL variable that receives TRUE if enabled, or FALSE if disabled. This
            flag is supported for 32-bit applications only. Windows NT, Windows Me/98: This flag is
            supported for 16-bit and 32-bit applications. Windows 95: This flag is supported for
            16-bit applications only.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETPOWEROFFACTIVE">
            <summary>
            Determines whether the power-off phase of screen saving is enabled. The pvParam parameter
            must point to a BOOL variable that receives TRUE if enabled, or FALSE if disabled. This
            flag is supported for 32-bit applications only. Windows NT, Windows Me/98: This flag is
            supported for 16-bit and 32-bit applications. Windows 95: This flag is supported for
            16-bit applications only.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETLOWPOWERACTIVE">
            <summary>
            Activates or deactivates the low-power phase of screen saving. Set uiParam to 1 to
            activate, or zero to deactivate. The pvParam parameter must be null. This flag is
            supported for 32-bit applications only. Windows NT, Windows Me/98: This flag is supported
            for 16-bit and 32-bit applications. Windows 95: This flag is supported for 16-bit
            applications only.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETPOWEROFFACTIVE">
            <summary>
            Activates or deactivates the power-off phase of screen saving. Set uiParam to 1 to
            activate, or zero to deactivate. The pvParam parameter must be null. This flag is
            supported for 32-bit applications only. Windows NT, Windows Me/98: This flag is supported
            for 16-bit and 32-bit applications. Windows 95: This flag is supported for 16-bit
            applications only.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETCURSORS">
            <summary>
            Reloads the system cursors. Set the uiParam parameter to zero and the pvParam parameter
            to null.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETICONS">
            <summary>
            Reloads the system icons. Set the uiParam parameter to zero and the pvParam parameter to null.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETDEFAULTINPUTLANG">
            <summary>
            Retrieves the input locale identifier for the system default input language. The pvParam
            parameter must point to an HKL variable that receives this value. For more information,
            see Languages, Locales, and Keyboard Layouts on MSDN.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETDEFAULTINPUTLANG">
            <summary>
            Sets the default input language for the system shell and applications. The specified
            language must be displayable using the current system character set. The pvParam
            parameter must point to an HKL variable that contains the input locale identifier for the
            default language. For more information, see Languages, Locales, and Keyboard Layouts on MSDN.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETLANGTOGGLE">
            <summary>
            Sets the hot key set for switching between input languages. The uiParam and pvParam
            parameters are not used. The value sets the shortcut keys in the keyboard property sheets
            by reading the registry again. The registry must be set before this flag is used. the
            path in the registry is \HKEY_CURRENT_USER\keyboard layout\toggle. Valid values are "1" =
            ALT+SHIFT, "2" = CTRL+SHIFT, and "3" = none.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETWINDOWSEXTENSION">
            <summary>
            Windows 95: Determines whether the Windows extension, Windows Plus!, is installed. Set
            the uiParam parameter to 1. The pvParam parameter is not used. The function returns TRUE
            if the extension is installed, or FALSE if it is not.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETMOUSETRAILS">
            <summary>
            Enables or disables the Mouse Trails feature, which improves the visibility of mouse
            cursor movements by briefly showing a trail of cursors and quickly erasing them. To
            disable the feature, set the uiParam parameter to zero or 1. To enable the feature, set
            uiParam to a value greater than 1 to indicate the number of cursors drawn in the trail.
            Windows 2000/NT: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETMOUSETRAILS">
            <summary>
            Determines whether the Mouse Trails feature is enabled. This feature improves the
            visibility of mouse cursor movements by briefly showing a trail of cursors and quickly
            erasing them. The pvParam parameter must point to an integer variable that receives a
            value. If the value is zero or 1, the feature is disabled. If the value is greater than
            1, the feature is enabled and the value indicates the number of cursors drawn in the
            trail. The uiParam parameter is not used. Windows 2000/NT: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETSCREENSAVERRUNNING">
            <summary>
            Windows Me/98: Used internally; applications should not use this flag.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SCREENSAVERRUNNING">
            <summary>
            Same as SPI_SETSCREENSAVERRUNNING.
            </summary>
            <remarks>#endif /* WINVER >= 0x0400</remarks>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETFILTERKEYS">
            <summary>
            Retrieves information about the FilterKeys accessibility feature. The pvParam parameter
            must point to a FILTERKEYS structure that receives the information. Set the cbSize member
            of this structure and the uiParam parameter to sizeof(FILTERKEYS).
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETFILTERKEYS">
            <summary>
            Sets the parameters of the FilterKeys accessibility feature. The pvParam parameter must
            point to a FILTERKEYS structure that contains the new parameters. Set the cbSize member
            of this structure and the uiParam parameter to sizeof(FILTERKEYS).
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETTOGGLEKEYS">
            <summary>
            Retrieves information about the ToggleKeys accessibility feature. The pvParam parameter
            must point to a TOGGLEKEYS structure that receives the information. Set the cbSize member
            of this structure and the uiParam parameter to sizeof(TOGGLEKEYS).
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETTOGGLEKEYS">
            <summary>
            Sets the parameters of the ToggleKeys accessibility feature. The pvParam parameter must
            point to a TOGGLEKEYS structure that contains the new parameters. Set the cbSize member
            of this structure and the uiParam parameter to sizeof(TOGGLEKEYS).
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETMOUSEKEYS">
            <summary>
            Retrieves information about the MouseKeys accessibility feature. The pvParam parameter
            must point to a MOUSEKEYS structure that receives the information. Set the cbSize member
            of this structure and the uiParam parameter to sizeof(MOUSEKEYS).
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETMOUSEKEYS">
            <summary>
            Sets the parameters of the MouseKeys accessibility feature. The pvParam parameter must
            point to a MOUSEKEYS structure that contains the new parameters. Set the cbSize member of
            this structure and the uiParam parameter to sizeof(MOUSEKEYS).
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETSHOWSOUNDS">
            <summary>
            Determines whether the Show Sounds accessibility flag is on or off. If it is on, the user
            requires an application to present information visually in situations where it would
            otherwise present the information only in audible form. The pvParam parameter must point
            to a BOOL variable that receives TRUE if the feature is on, or FALSE if it is off. Using
            this value is equivalent to calling GetSystemMetrics (SM_SHOWSOUNDS). That is the
            recommended call.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETSHOWSOUNDS">
            <summary>
            Sets the parameters of the SoundSentry accessibility feature. The pvParam parameter must
            point to a SOUNDSENTRY structure that contains the new parameters. Set the cbSize member
            of this structure and the uiParam parameter to sizeof(SOUNDSENTRY).
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETSTICKYKEYS">
            <summary>
            Retrieves information about the StickyKeys accessibility feature. The pvParam parameter
            must point to a STICKYKEYS structure that receives the information. Set the cbSize member
            of this structure and the uiParam parameter to sizeof(STICKYKEYS).
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETSTICKYKEYS">
            <summary>
            Sets the parameters of the StickyKeys accessibility feature. The pvParam parameter must
            point to a STICKYKEYS structure that contains the new parameters. Set the cbSize member
            of this structure and the uiParam parameter to sizeof(STICKYKEYS).
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETACCESSTIMEOUT">
            <summary>
            Retrieves information about the time-out period associated with the accessibility
            features. The pvParam parameter must point to an ACCESSTIMEOUT structure that receives
            the information. Set the cbSize member of this structure and the uiParam parameter to sizeof(ACCESSTIMEOUT).
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETACCESSTIMEOUT">
            <summary>
            Sets the time-out period associated with the accessibility features. The pvParam
            parameter must point to an ACCESSTIMEOUT structure that contains the new parameters. Set
            the cbSize member of this structure and the uiParam parameter to sizeof(ACCESSTIMEOUT).
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETSERIALKEYS">
            <summary>
            Windows Me/98/95: Retrieves information about the SerialKeys accessibility feature. The
            pvParam parameter must point to a SERIALKEYS structure that receives the information. Set
            the cbSize member of this structure and the uiParam parameter to sizeof(SERIALKEYS).
            Windows Server 2003, Windows XP/2000/NT: Not supported. The user controls this feature
            through the control panel.
            </summary>
            <remarks>#if(WINVER >= 0x0400</remarks>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETSERIALKEYS">
            <summary>
            Windows Me/98/95: Sets the parameters of the SerialKeys accessibility feature. The
            pvParam parameter must point to a SERIALKEYS structure that contains the new parameters.
            Set the cbSize member of this structure and the uiParam parameter to sizeof(SERIALKEYS).
            Windows Server 2003, Windows XP/2000/NT: Not supported. The user controls this feature
            through the control panel.
            </summary>
            <remarks>#endif /* WINVER >= 0x0400 </remarks>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETSOUNDSENTRY">
            <summary>
            Retrieves information about the SoundSentry accessibility feature. The pvParam parameter
            must point to a SOUNDSENTRY structure that receives the information. Set the cbSize
            member of this structure and the uiParam parameter to sizeof(SOUNDSENTRY).
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETSOUNDSENTRY">
            <summary>
            Sets the parameters of the SoundSentry accessibility feature. The pvParam parameter must
            point to a SOUNDSENTRY structure that contains the new parameters. Set the cbSize member
            of this structure and the uiParam parameter to sizeof(SOUNDSENTRY).
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETSNAPTODEFBUTTON">
            <summary>
            Determines whether the snap-to-default-button feature is enabled. If enabled, the mouse
            cursor automatically moves to the default button, such as OK or Apply, of a dialog box.
            The pvParam parameter must point to a BOOL variable that receives TRUE if the feature is
            on, or FALSE if it is off. Windows 95: Not supported.
            </summary>
            <remarks>#if(WINVER >= 0x0400</remarks>
            SPI_GETSNAPTODEFBUTTON = 0x005F,
            <summary>
            Enables or disables the snap-to-default-button feature. If enabled, the mouse cursor
            automatically moves to the default button, such as OK or Apply, of a dialog box. Set the
            uiParam parameter to TRUE to enable the feature, or FALSE to disable it. Applications
            should use the ShowWindow function when displaying a dialog box so the dialog manager can
            position the mouse cursor. Windows 95: Not supported.
            </summary>
            <remarks>#endif /* _WIN32_WINNT >= 0x0400 */</remarks>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETMOUSEHOVERWIDTH">
            <summary>
            Retrieves the width, in pixels, of the rectangle within which the mouse pointer has to
            stay for TrackMouseEvent to generate a WM_MOUSEHOVER message. The pvParam parameter must
            point to a UINT variable that receives the width. Windows 95: Not supported.
            </summary>
            <remarks>#if (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)</remarks>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETMOUSEHOVERWIDTH">
            <summary>
            Retrieves the width, in pixels, of the rectangle within which the mouse pointer has to
            stay for TrackMouseEvent to generate a WM_MOUSEHOVER message. The pvParam parameter must
            point to a UINT variable that receives the width. Windows 95: Not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETMOUSEHOVERHEIGHT">
            <summary>
            Retrieves the height, in pixels, of the rectangle within which the mouse pointer has to
            stay for TrackMouseEvent to generate a WM_MOUSEHOVER message. The pvParam parameter must
            point to a UINT variable that receives the height. Windows 95: Not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETMOUSEHOVERHEIGHT">
            <summary>
            Sets the height, in pixels, of the rectangle within which the mouse pointer has to stay
            for TrackMouseEvent to generate a WM_MOUSEHOVER message. Set the uiParam parameter to the
            new height. Windows 95: Not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETMOUSEHOVERTIME">
            <summary>
            Retrieves the time, in milliseconds, that the mouse pointer has to stay in the hover
            rectangle for TrackMouseEvent to generate a WM_MOUSEHOVER message. The pvParam parameter
            must point to a UINT variable that receives the time. Windows 95: Not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETMOUSEHOVERTIME">
            <summary>
            Sets the time, in milliseconds, that the mouse pointer has to stay in the hover rectangle
            for TrackMouseEvent to generate a WM_MOUSEHOVER message. This is used only if you pass
            HOVER_DEFAULT in the dwHoverTime parameter in the call to TrackMouseEvent. Set the
            uiParam parameter to the new time. Windows 95: Not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETWHEELSCROLLLINES">
            <summary>
            Retrieves the number of lines to scroll when the mouse wheel is rotated. The pvParam
            parameter must point to a UINT variable that receives the number of lines. The default
            value is 3. Windows 95: Not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETWHEELSCROLLLINES">
            <summary>
            Sets the number of lines to scroll when the mouse wheel is rotated. The number of lines
            is set from the uiParam parameter. The number of lines is the suggested number of lines
            to scroll when the mouse wheel is rolled without using modifier keys. If the number is 0,
            then no scrolling should occur. If the number of lines to scroll is greater than the
            number of lines viewable, and in particular if it is WHEEL_PAGESCROLL (#defined as
            UINT_MAX), the scroll operation should be interpreted as clicking once in the page down
            or page up regions of the scroll bar. Windows 95: Not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETMENUSHOWDELAY">
            <summary>
            Retrieves the time, in milliseconds, that the system waits before displaying a shortcut
            menu when the mouse cursor is over a submenu item. The pvParam parameter must point to a
            DWORD variable that receives the time of the delay. Windows 95: Not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETMENUSHOWDELAY">
            <summary>
            Sets uiParam to the time, in milliseconds, that the system waits before displaying a
            shortcut menu when the mouse cursor is over a submenu item. Windows 95: Not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETSHOWIMEUI">
            <summary>
            Determines whether the IME status window is visible (on a per-user basis). The pvParam
            parameter must point to a BOOL variable that receives TRUE if the status window is
            visible, or FALSE if it is not. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETSHOWIMEUI">
            <summary>
            Sets whether the IME status window is visible or not on a per-user basis. The uiParam
            parameter specifies TRUE for on or FALSE for off. Windows NT, Windows 95: This value is
            not supported.
            </summary>
            <remarks>#endif</remarks>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETMOUSESPEED">
            <summary>
            Retrieves the current mouse speed. The mouse speed determines how far the pointer will
            move based on the distance the mouse moves. The pvParam parameter must point to an
            integer that receives a value which ranges between 1 (slowest) and 20 (fastest). A value
            of 10 is the default. The value can be set by an end user using the mouse control panel
            application or by an application using SPI_SETMOUSESPEED. Windows NT, Windows 95: This
            value is not supported.
            </summary>
            <remarks>#if(WINVER >= 0x0500</remarks>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETMOUSESPEED">
            <summary>
            Sets the current mouse speed. The pvParam parameter is an integer between 1 (slowest) and
            20 (fastest). A value of 10 is the default. This value is typically set using the mouse
            control panel application. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETSCREENSAVERRUNNING">
            <summary>
            Determines whether a screen saver is currently running on the window station of the
            calling process. The pvParam parameter must point to a BOOL variable that receives TRUE
            if a screen saver is currently running, or FALSE otherwise. Note that only the
            interactive window station, "WinSta0", can have a screen saver running. Windows NT,
            Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETDESKWALLPAPER">
            <summary>
            Retrieves the full path of the bitmap file for the desktop wallpaper. The pvParam
            parameter must point to a buffer that receives a null-terminated path string. Set the
            uiParam parameter to the size, in characters, of the pvParam buffer. The returned string
            will not exceed MAX_PATH characters. If there is no desktop wallpaper, the returned
            string is empty. Windows NT, Windows Me/98/95: This value is not supported.
            </summary>
            <remarks>#endif /* _WIN32_WINNT >= 0x0500 */</remarks>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETACTIVEWINDOWTRACKING">
            <summary>
            Determines whether active window tracking (activating the window the mouse is on) is on
            or off. The pvParam parameter must point to a BOOL variable that receives TRUE for on, or
            FALSE for off. Windows NT, Windows 95: This value is not supported.
            </summary>
            <remarks>#if(WINVER >= 0x0500</remarks>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETACTIVEWINDOWTRACKING">
            <summary>
            Sets active window tracking (activating the window the mouse is on) either on or off. Set
            pvParam to TRUE for on or FALSE for off. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETMENUANIMATION">
            <summary>
            Determines whether the menu animation feature is enabled. This master switch must be on
            to enable menu animation effects. The pvParam parameter must point to a BOOL variable
            that receives TRUE if animation is enabled and FALSE if it is disabled. If animation is
            enabled, SPI_GETMENUFADE indicates whether menus use fade or slide animation. Windows NT,
            Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETMENUANIMATION">
            <summary>
            Enables or disables menu animation. This master switch must be on for any menu animation
            to occur. The pvParam parameter is a BOOL variable; set pvParam to TRUE to enable
            animation and FALSE to disable animation. If animation is enabled, SPI_GETMENUFADE
            indicates whether menus use fade or slide animation. Windows NT, Windows 95: This value
            is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETCOMBOBOXANIMATION">
            <summary>
            Determines whether the slide-open effect for combo boxes is enabled. The pvParam
            parameter must point to a BOOL variable that receives TRUE for enabled, or FALSE for
            disabled. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETCOMBOBOXANIMATION">
            <summary>
            Enables or disables the slide-open effect for combo boxes. Set the pvParam parameter to
            TRUE to enable the gradient effect, or FALSE to disable it. Windows NT, Windows
            95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETLISTBOXSMOOTHSCROLLING">
            <summary>
            Determines whether the smooth-scrolling effect for list boxes is enabled. The pvParam
            parameter must point to a BOOL variable that receives TRUE for enabled, or FALSE for
            disabled. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETLISTBOXSMOOTHSCROLLING">
            <summary>
            Enables or disables the smooth-scrolling effect for list boxes. Set the pvParam parameter
            to TRUE to enable the smooth-scrolling effect, or FALSE to disable it. Windows NT,
            Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETGRADIENTCAPTIONS">
            <summary>
            Determines whether the gradient effect for window title bars is enabled. The pvParam
            parameter must point to a BOOL variable that receives TRUE for enabled, or FALSE for
            disabled. For more information about the gradient effect, see the GetSysColor function.
            Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETGRADIENTCAPTIONS">
            <summary>
            Enables or disables the gradient effect for window title bars. Set the pvParam parameter
            to TRUE to enable it, or FALSE to disable it. The gradient effect is possible only if the
            system has a color depth of more than 256 colors. For more information about the gradient
            effect, see the GetSysColor function. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETKEYBOARDCUES">
            <summary>
            Determines whether menu access keys are always underlined. The pvParam parameter must
            point to a BOOL variable that receives TRUE if menu access keys are always underlined,
            and FALSE if they are underlined only when the menu is activated by the keyboard. Windows
            NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETKEYBOARDCUES">
            <summary>
            Sets the underlining of menu access key letters. The pvParam parameter is a BOOL
            variable. Set pvParam to TRUE to always underline menu access keys, or FALSE to underline
            menu access keys only when the menu is activated from the keyboard. Windows NT, Windows
            95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETMENUUNDERLINES">
            <summary>
            Same as SPI_GETKEYBOARDCUES.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETMENUUNDERLINES">
            <summary>
            Same as SPI_SETKEYBOARDCUES.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETACTIVEWNDTRKZORDER">
            <summary>
            Determines whether windows activated through active window tracking will be brought to
            the top. The pvParam parameter must point to a BOOL variable that receives TRUE for on,
            or FALSE for off. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETACTIVEWNDTRKZORDER">
            <summary>
            Determines whether or not windows activated through active window tracking should be
            brought to the top. Set pvParam to TRUE for on or FALSE for off. Windows NT, Windows
            95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETHOTTRACKING">
            <summary>
            Determines whether hot tracking of user-interface elements, such as menu names on menu
            bars, is enabled. The pvParam parameter must point to a BOOL variable that receives TRUE
            for enabled, or FALSE for disabled. Hot tracking means that when the cursor moves over an
            item, it is highlighted but not selected. You can query this value to decide whether to
            use hot tracking in the user interface of your application. Windows NT, Windows 95: This
            value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETHOTTRACKING">
            <summary>
            Enables or disables hot tracking of user-interface elements such as menu names on menu
            bars. Set the pvParam parameter to TRUE to enable it, or FALSE to disable it.
            Hot-tracking means that when the cursor moves over an item, it is highlighted but not
            selected. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETMENUFADE">
            <summary>
            Determines whether menu fade animation is enabled. The pvParam parameter must point to a
            BOOL variable that receives TRUE when fade animation is enabled and FALSE when it is
            disabled. If fade animation is disabled, menus use slide animation. This flag is ignored
            unless menu animation is enabled, which you can do using the SPI_SETMENUANIMATION flag.
            For more information, see AnimateWindow. Windows NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETMENUFADE">
            <summary>
            Enables or disables menu fade animation. Set pvParam to TRUE to enable the menu fade
            effect or FALSE to disable it. If fade animation is disabled, menus use slide animation.
            he The menu fade effect is possible only if the system has a color depth of more than 256
            colors. This flag is ignored unless SPI_MENUANIMATION is also set. For more information,
            see AnimateWindow. Windows NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETSELECTIONFADE">
            <summary>
            Determines whether the selection fade effect is enabled. The pvParam parameter must point
            to a BOOL variable that receives TRUE if enabled or FALSE if disabled. The selection fade
            effect causes the menu item selected by the user to remain on the screen briefly while
            fading out after the menu is dismissed. Windows NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETSELECTIONFADE">
            <summary>
            Set pvParam to TRUE to enable the selection fade effect or FALSE to disable it. The
            selection fade effect causes the menu item selected by the user to remain on the screen
            briefly while fading out after the menu is dismissed. The selection fade effect is
            possible only if the system has a color depth of more than 256 colors. Windows NT,
            Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETTOOLTIPANIMATION">
            <summary>
            Determines whether ToolTip animation is enabled. The pvParam parameter must point to a
            BOOL variable that receives TRUE if enabled or FALSE if disabled. If ToolTip animation is
            enabled, SPI_GETTOOLTIPFADE indicates whether ToolTips use fade or slide animation.
            Windows NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETTOOLTIPANIMATION">
            <summary>
            Set pvParam to TRUE to enable ToolTip animation or FALSE to disable it. If enabled, you
            can use SPI_SETTOOLTIPFADE to specify fade or slide animation. Windows NT, Windows
            Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETTOOLTIPFADE">
            <summary>
            If SPI_SETTOOLTIPANIMATION is enabled, SPI_GETTOOLTIPFADE indicates whether ToolTip
            animation uses a fade effect or a slide effect. The pvParam parameter must point to a
            BOOL variable that receives TRUE for fade animation or FALSE for slide animation. For
            more information on slide and fade effects, see AnimateWindow. Windows NT, Windows
            Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETTOOLTIPFADE">
            <summary>
            If the SPI_SETTOOLTIPANIMATION flag is enabled, use SPI_SETTOOLTIPFADE to indicate
            whether ToolTip animation uses a fade effect or a slide effect. Set pvParam to TRUE for
            fade animation or FALSE for slide animation. The tooltip fade effect is possible only if
            the system has a color depth of more than 256 colors. For more information on the slide
            and fade effects, see the AnimateWindow function. Windows NT, Windows Me/98/95: This
            value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETCURSORSHADOW">
            <summary>
            Determines whether the cursor has a shadow around it. The pvParam parameter must point to
            a BOOL variable that receives TRUE if the shadow is enabled, FALSE if it is disabled.
            This effect appears only if the system has a color depth of more than 256 colors. Windows
            NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETCURSORSHADOW">
            <summary>
            Enables or disables a shadow around the cursor. The pvParam parameter is a BOOL variable.
            Set pvParam to TRUE to enable the shadow or FALSE to disable the shadow. This effect
            appears only if the system has a color depth of more than 256 colors. Windows NT, Windows
            Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETMOUSESONAR">
            <summary>
            Retrieves the state of the Mouse Sonar feature. The pvParam parameter must point to a
            BOOL variable that receives TRUE if enabled or FALSE otherwise. For more information, see
            About Mouse Input on MSDN. Windows 2000/NT, Windows 98/95: This value is not supported.
            </summary>
            <remarks>#if(WINVER >= 0x0501</remarks>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETMOUSESONAR">
            <summary>
            Turns the Sonar accessibility feature on or off. This feature briefly shows several
            concentric circles around the mouse pointer when the user presses and releases the CTRL
            key. The pvParam parameter specifies TRUE for on and FALSE for off. The default is off.
            For more information, see About Mouse Input. Windows 2000/NT, Windows 98/95: This value
            is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETMOUSECLICKLOCK">
            <summary>
            Retrieves the state of the Mouse ClickLock feature. The pvParam parameter must point to a
            BOOL variable that receives TRUE if enabled, or FALSE otherwise. For more information,
            see About Mouse Input. Windows 2000/NT, Windows 98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETMOUSECLICKLOCK">
            <summary>
            Turns the Mouse ClickLock accessibility feature on or off. This feature temporarily locks
            down the primary mouse button when that button is clicked and held down for the time
            specified by SPI_SETMOUSECLICKLOCKTIME. The uiParam parameter specifies TRUE for on, or
            FALSE for off. The default is off. For more information, see Remarks and About Mouse
            Input on MSDN. Windows 2000/NT, Windows 98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETMOUSEVANISH">
            <summary>
            Retrieves the state of the Mouse Vanish feature. The pvParam parameter must point to a
            BOOL variable that receives TRUE if enabled or FALSE otherwise. For more information, see
            About Mouse Input on MSDN. Windows 2000/NT, Windows 98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETMOUSEVANISH">
            <summary>
            Turns the Vanish feature on or off. This feature hides the mouse pointer when the user
            types; the pointer reappears when the user moves the mouse. The pvParam parameter
            specifies TRUE for on and FALSE for off. The default is off. For more information, see
            About Mouse Input on MSDN. Windows 2000/NT, Windows 98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETFLATMENU">
            <summary>
            Determines whether native User menus have flat menu appearance. The pvParam parameter
            must point to a BOOL variable that returns TRUE if the flat menu appearance is set, or
            FALSE otherwise. Windows 2000/NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETFLATMENU">
            <summary>
            Enables or disables flat menu appearance for native User menus. Set pvParam to TRUE to
            enable flat menu appearance or FALSE to disable it. When enabled, the menu bar uses
            COLOR_MENUBAR for the menubar background, COLOR_MENU for the menu-popup background,
            COLOR_MENUHILIGHT for the fill of the current menu selection, and COLOR_HILIGHT for the
            outline of the current menu selection. If disabled, menus are drawn using the same
            metrics and colors as in Windows 2000 and earlier. Windows 2000/NT, Windows Me/98/95:
            This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETDROPSHADOW">
            <summary>
            Determines whether the drop shadow effect is enabled. The pvParam parameter must point to
            a BOOL variable that returns TRUE if enabled or FALSE if disabled. Windows 2000/NT,
            Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETDROPSHADOW">
            <summary>
            Enables or disables the drop shadow effect. Set pvParam to TRUE to enable the drop shadow
            effect or FALSE to disable it. You must also have CS_DROPSHADOW in the window class
            style. Windows 2000/NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETBLOCKSENDINPUTRESETS">
            <summary>
            Retrieves a BOOL indicating whether an application can reset the screensaver's timer by
            calling the SendInput function to simulate keyboard or mouse input. The pvParam parameter
            must point to a BOOL variable that receives TRUE if the simulated input will be blocked,
            or FALSE otherwise.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETBLOCKSENDINPUTRESETS">
            <summary>
            Determines whether an application can reset the screensaver's timer by calling the
            SendInput function to simulate keyboard or mouse input. The uiParam parameter specifies
            TRUE if the screensaver will not be deactivated by simulated input, or FALSE if the
            screensaver will be deactivated by simulated input.
            </summary>
            <remarks>#endif /* _WIN32_WINNT >= 0x0501 */</remarks>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETUIEFFECTS">
            <summary>
            Determines whether UI effects are enabled or disabled. The pvParam parameter must point
            to a BOOL variable that receives TRUE if all UI effects are enabled, or FALSE if they are
            disabled. Windows NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETUIEFFECTS">
            <summary>
            Enables or disables UI effects. Set the pvParam parameter to TRUE to enable all UI
            effects or FALSE to disable all UI effects. Windows NT, Windows Me/98/95: This value is
            not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETFOREGROUNDLOCKTIMEOUT">
            <summary>
            Retrieves the amount of time following user input, in milliseconds, during which the
            system will not allow applications to force themselves into the foreground. The pvParam
            parameter must point to a DWORD variable that receives the time. Windows NT, Windows 95:
            This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETFOREGROUNDLOCKTIMEOUT">
            <summary>
            Sets the amount of time following user input, in milliseconds, during which the system
            does not allow applications to force themselves into the foreground. Set pvParam to the
            new timeout value. The calling thread must be able to change the foreground window,
            otherwise the call fails. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETACTIVEWNDTRKTIMEOUT">
            <summary>
            Retrieves the active window tracking delay, in milliseconds. The pvParam parameter must
            point to a DWORD variable that receives the time. Windows NT, Windows 95: This value is
            not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETACTIVEWNDTRKTIMEOUT">
            <summary>
            Sets the active window tracking delay. Set pvParam to the number of milliseconds to delay
            before activating the window under the mouse pointer. Windows NT, Windows 95: This value
            is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETFOREGROUNDFLASHCOUNT">
            <summary>
            Retrieves the number of times SetForegroundWindow will flash the taskbar button when
            rejecting a foreground switch request. The pvParam parameter must point to a DWORD
            variable that receives the value. Windows NT, Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETFOREGROUNDFLASHCOUNT">
            <summary>
            Sets the number of times SetForegroundWindow will flash the taskbar button when rejecting
            a foreground switch request. Set pvParam to the number of times to flash. Windows NT,
            Windows 95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETCARETWIDTH">
            <summary>
            Retrieves the caret width in edit controls, in pixels. The pvParam parameter must point
            to a DWORD that receives this value. Windows NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETCARETWIDTH">
            <summary>
            Sets the caret width in edit controls. Set pvParam to the desired width, in pixels. The
            default and minimum value is 1. Windows NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETMOUSECLICKLOCKTIME">
            <summary>
            Retrieves the time delay before the primary mouse button is locked. The pvParam parameter
            must point to DWORD that receives the time delay. This is only enabled if
            SPI_SETMOUSECLICKLOCK is set to TRUE. For more information, see About Mouse Input on
            MSDN. Windows 2000/NT, Windows 98/95: This value is not supported.
            </summary>
            <remarks>#if(WINVER >= 0x0500</remarks>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETMOUSECLICKLOCKTIME">
            <summary>
            Turns the Mouse ClickLock accessibility feature on or off. This feature temporarily locks
            down the primary mouse button when that button is clicked and held down for the time
            specified by SPI_SETMOUSECLICKLOCKTIME. The uiParam parameter specifies TRUE for on, or
            FALSE for off. The default is off. For more information, see Remarks and About Mouse
            Input on MSDN. Windows 2000/NT, Windows 98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETFONTSMOOTHINGTYPE">
            <summary>
            Retrieves the type of font smoothing. The pvParam parameter must point to a UINT that
            receives the information. Windows 2000/NT, Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETFONTSMOOTHINGTYPE">
            <summary>
            Sets the font smoothing type. The pvParam parameter points to a UINT that contains either
            FE_FONTSMOOTHINGSTANDARD, if standard anti-aliasing is used, or
            FE_FONTSMOOTHINGCLEARTYPE, if ClearType is used. The default is FE_FONTSMOOTHINGSTANDARD.
            When using this option, the fWinIni parameter must be set to SPIF_SENDWININICHANGE |
            SPIF_UPDATEINIFILE; otherwise, SystemParametersInfo fails.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETFONTSMOOTHINGCONTRAST">
            <summary>
            Retrieves a contrast value that is used in ClearType™ smoothing. The pvParam parameter
            must point to a UINT that receives the information. Windows 2000/NT, Windows Me/98/95:
            This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETFONTSMOOTHINGCONTRAST">
            <summary>
            Sets the contrast value used in ClearType smoothing. The pvParam parameter points to a
            UINT that holds the contrast value. Valid contrast values are from 1000 to 2200. The
            default value is 1400. When using this option, the fWinIni parameter must be set to
            SPIF_SENDWININICHANGE | SPIF_UPDATEINIFILE; otherwise, SystemParametersInfo fails.
            SPI_SETFONTSMOOTHINGTYPE must also be set to FE_FONTSMOOTHINGCLEARTYPE. Windows 2000/NT,
            Windows Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETFOCUSBORDERWIDTH">
            <summary>
            Retrieves the width, in pixels, of the left and right edges of the focus rectangle drawn
            with DrawFocusRect. The pvParam parameter must point to a UINT. Windows 2000/NT, Windows
            Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETFOCUSBORDERWIDTH">
            <summary>
            Sets the height of the left and right edges of the focus rectangle drawn with
            DrawFocusRect to the value of the pvParam parameter. Windows 2000/NT, Windows Me/98/95:
            This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETFOCUSBORDERHEIGHT">
            <summary>
            Retrieves the height, in pixels, of the top and bottom edges of the focus rectangle drawn
            with DrawFocusRect. The pvParam parameter must point to a UINT. Windows 2000/NT, Windows
            Me/98/95: This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETFOCUSBORDERHEIGHT">
            <summary>
            Sets the height of the top and bottom edges of the focus rectangle drawn with
            DrawFocusRect to the value of the pvParam parameter. Windows 2000/NT, Windows Me/98/95:
            This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETFONTSMOOTHINGORIENTATION">
            <summary>
            Not implemented.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoAction.SPI_SETFONTSMOOTHINGORIENTATION">
            <summary>
            Not implemented.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoFlags.SPIF_UPDATEINIFILE">
            <summary>
            Writes the new system-wide parameter setting to the user profile.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoFlags.SPIF_SENDCHANGE">
            <summary>
            Broadcasts the WM_SETTINGCHANGE message after updating the user profile.
            </summary>
        </member>
        <member name="F:PInvoke.User32.SystemParametersInfoFlags.SPIF_SENDWININICHANGE">
            <summary>
            Same as SPIF_SENDCHANGE.
            </summary>
        </member>
        <member name="T:PInvoke.User32.TextFormats">
            <summary>
            Values to pass to the <see cref="M:PInvoke.User32.DrawText(PInvoke.User32.SafeDCHandle,System.Char*,System.Int32,PInvoke.RECT*,PInvoke.User32.TextFormats)"/> method describing format the text.
            </summary>
        </member>
        <member name="F:PInvoke.User32.TextFormats.DT_TOP">
            <summary>
            Justifies the text to the top of the rectangle.
            </summary>
        </member>
        <member name="F:PInvoke.User32.TextFormats.DT_LEFT">
            <summary>
            Aligns text to the left.
            </summary>
        </member>
        <member name="F:PInvoke.User32.TextFormats.DT_CENTER">
            <summary>
            Centers text horizontally in the rectangle.
            </summary>
        </member>
        <member name="F:PInvoke.User32.TextFormats.DT_RIGHT">
            <summary>
            Aligns text to the right.
            </summary>
        </member>
        <member name="F:PInvoke.User32.TextFormats.DT_VCENTER">
            <summary>
            Centers text vertically. This value is used only with the DT_SINGLELINE value.
            </summary>
        </member>
        <member name="F:PInvoke.User32.TextFormats.DT_BOTTOM">
            <summary>
            Justifies the text to the bottom of the rectangle. This value is used only with the <see cref="F:PInvoke.User32.TextFormats.DT_SINGLELINE"/> value.
            </summary>
        </member>
        <member name="F:PInvoke.User32.TextFormats.DT_WORDBREAK">
            <summary>
            Breaks words. Lines are automatically broken between words if a word would extend past the edge of the rectangle specified by the lpRect parameter.
            A carriage return-line feed sequence also breaks the line.
            </summary>
            <remarks>f this is not specified, output is on one line.</remarks>
        </member>
        <member name="F:PInvoke.User32.TextFormats.DT_SINGLELINE">
            <summary>
            Displays text on a single line only. Carriage returns and line feeds do not break the line.
            </summary>
        </member>
        <member name="F:PInvoke.User32.TextFormats.DT_EXPANDTABS">
            <summary>
            Expands tab characters. The default number of characters per tab is eight.
            </summary>
            <remarks>The <see cref="F:PInvoke.User32.TextFormats.DT_WORD_ELLIPSIS"/>, <see cref="F:PInvoke.User32.TextFormats.DT_PATH_ELLIPSIS"/>, and <see cref="F:PInvoke.User32.TextFormats.DT_END_ELLIPSIS"/> values cannot be used with the DT_EXPANDTABS value.</remarks>
        </member>
        <member name="F:PInvoke.User32.TextFormats.DT_TABSTOP">
            <summary>
            Sets tab stops. Bits 15-8 (high-order byte of the low-order word) of the uFormat parameter specify the number of characters for each tab.
            The default number of characters per tab is eight.
            If you are using the <see cref="M:PInvoke.User32.DrawTextEx(PInvoke.User32.SafeDCHandle,System.Char*,System.Int32,PInvoke.RECT*,System.UInt32,PInvoke.User32.DRAWTEXTPARAMS*)"/> function, the <see cref="T:PInvoke.User32.DRAWTEXTPARAMS"/> structure pointed to by the lpDTParams parameter specifies the number of average character widths per tab stop.
            </summary>
            <remarks>The <see cref="F:PInvoke.User32.TextFormats.DT_CALCRECT"/>, <see cref="F:PInvoke.User32.TextFormats.DT_EXTERNALLEADING"/>, <see cref="F:PInvoke.User32.TextFormats.DT_INTERNAL"/>, <see cref="F:PInvoke.User32.TextFormats.DT_NOCLIP"/>, and <see cref="F:PInvoke.User32.TextFormats.DT_NOPREFIX"/> values cannot be used with the DT_TABSTOP value.</remarks>
        </member>
        <member name="F:PInvoke.User32.TextFormats.TABSTOP_1CHAR">
            <summary>
            Tab stops with 1 character length
            Auxiliary value to help map the <see cref="F:PInvoke.User32.TextFormats.DT_TABSTOP"/> settings for the number of tab charaters with <see cref="M:PInvoke.User32.DrawText(PInvoke.User32.SafeDCHandle,System.Char*,System.Int32,PInvoke.RECT*,PInvoke.User32.TextFormats)"/>
            </summary>
        </member>
        <member name="F:PInvoke.User32.TextFormats.TABSTOP_2CHAR">
            <summary>
            Tab stops with 2 characters length
            Auxiliary value to help map the <see cref="F:PInvoke.User32.TextFormats.DT_TABSTOP"/> settings for the number of tab charaters with <see cref="M:PInvoke.User32.DrawText(PInvoke.User32.SafeDCHandle,System.Char*,System.Int32,PInvoke.RECT*,PInvoke.User32.TextFormats)"/>
            </summary>
        </member>
        <member name="F:PInvoke.User32.TextFormats.TABSTOP_4CHAR">
            <summary>
            Tab stops with 4 characters length
            Auxiliary value to help map the <see cref="F:PInvoke.User32.TextFormats.DT_TABSTOP"/> settings for the number of tab charaters with <see cref="M:PInvoke.User32.DrawText(PInvoke.User32.SafeDCHandle,System.Char*,System.Int32,PInvoke.RECT*,PInvoke.User32.TextFormats)"/>
            </summary>
        </member>
        <member name="F:PInvoke.User32.TextFormats.TABSTOP_8CHAR">
            <summary>
            Tab stops with 8 characters length
            Auxiliary value to help map the <see cref="F:PInvoke.User32.TextFormats.DT_TABSTOP"/> settings for the number of tab charaters with <see cref="M:PInvoke.User32.DrawText(PInvoke.User32.SafeDCHandle,System.Char*,System.Int32,PInvoke.RECT*,PInvoke.User32.TextFormats)"/>
            </summary>
        </member>
        <member name="F:PInvoke.User32.TextFormats.TABSTOP_16CHAR">
            <summary>
            Tab stops with 16 characters length
            Auxiliary value to help map the <see cref="F:PInvoke.User32.TextFormats.DT_TABSTOP"/> settings for the number of tab charaters with <see cref="M:PInvoke.User32.DrawText(PInvoke.User32.SafeDCHandle,System.Char*,System.Int32,PInvoke.RECT*,PInvoke.User32.TextFormats)"/>
            </summary>
        </member>
        <member name="F:PInvoke.User32.TextFormats.TABSTOP_32CHAR">
            <summary>
            Tab stops with 32 characters length
            Auxiliary value to help map the <see cref="F:PInvoke.User32.TextFormats.DT_TABSTOP"/> settings for the number of tab charaters with <see cref="M:PInvoke.User32.DrawText(PInvoke.User32.SafeDCHandle,System.Char*,System.Int32,PInvoke.RECT*,PInvoke.User32.TextFormats)"/>
            </summary>
        </member>
        <member name="F:PInvoke.User32.TextFormats.TABSTOP_64CHAR">
            <summary>
            Tab stops with 64 characters length
            Auxiliary value to help map the <see cref="F:PInvoke.User32.TextFormats.DT_TABSTOP"/> settings for the number of tab charaters with <see cref="M:PInvoke.User32.DrawText(PInvoke.User32.SafeDCHandle,System.Char*,System.Int32,PInvoke.RECT*,PInvoke.User32.TextFormats)"/>
            </summary>
        </member>
        <member name="F:PInvoke.User32.TextFormats.TABSTOP_128CHAR">
            <summary>
            Tab stops with 128 characters length
            Auxiliary value to help map the <see cref="F:PInvoke.User32.TextFormats.DT_TABSTOP"/> settings for the number of tab charaters with <see cref="M:PInvoke.User32.DrawText(PInvoke.User32.SafeDCHandle,System.Char*,System.Int32,PInvoke.RECT*,PInvoke.User32.TextFormats)"/>
            </summary>
        </member>
        <member name="F:PInvoke.User32.TextFormats.DT_NOCLIP">
            <summary>
            Draws without clipping. <see cref="M:PInvoke.User32.DrawText(PInvoke.User32.SafeDCHandle,System.Char*,System.Int32,PInvoke.RECT*,PInvoke.User32.TextFormats)"/> is somewhat faster when DT_NOCLIP is used.
            </summary>
        </member>
        <member name="F:PInvoke.User32.TextFormats.DT_EXTERNALLEADING">
            <summary>
            Includes the font external leading in line height.
            Normally, external leading is not included in the height of a line of text.
            </summary>
        </member>
        <member name="F:PInvoke.User32.TextFormats.DT_CALCRECT">
            <summary>
            Determines the width and height of the rectangle.
            If there are multiple lines of text, <see cref="M:PInvoke.User32.DrawText(PInvoke.User32.SafeDCHandle,System.Char*,System.Int32,PInvoke.RECT*,PInvoke.User32.TextFormats)"/> uses the width of the rectangle pointed to by the lpRect parameter
            and extends the base of the rectangle to bound the last line of text.
            If the largest word is wider than the rectangle, the width is expanded.
            If the text is less than the width of the rectangle, the width is reduced.
            If there is only one line of text, <see cref="M:PInvoke.User32.DrawText(PInvoke.User32.SafeDCHandle,System.Char*,System.Int32,PInvoke.RECT*,PInvoke.User32.TextFormats)"/> modifies the right side of the rectangle so that it bounds the last character in the line.
            In either case, <see cref="M:PInvoke.User32.DrawText(PInvoke.User32.SafeDCHandle,System.Char*,System.Int32,PInvoke.RECT*,PInvoke.User32.TextFormats)"/> returns the height of the formatted text but does not draw the text.
            </summary>
        </member>
        <member name="F:PInvoke.User32.TextFormats.DT_NOPREFIX">
            <summary>
            Turns off processing of prefix characters. Normally, <see cref="M:PInvoke.User32.DrawText(PInvoke.User32.SafeDCHandle,System.Char*,System.Int32,PInvoke.RECT*,PInvoke.User32.TextFormats)"/> interprets the mnemonic-prefix character &amp; as a directive to underscore the character that follows,
            and the mnemonic-prefix characters &amp;&amp; as a directive to print a single &amp;.
            By specifying DT_NOPREFIX, this processing is turned off.
            </summary>
            <example>
            input string: "A&amp;bc&amp;&amp;d"
            normal: "Abc&amp;d"
            DT_NOPREFIX: "A&amp;bc&amp;&amp;d"
            </example>
            <remarks>Compare with <see cref="F:PInvoke.User32.TextFormats.DT_HIDEPREFIX"/> and <see cref="F:PInvoke.User32.TextFormats.DT_PREFIXONLY"/>.</remarks>
        </member>
        <member name="F:PInvoke.User32.TextFormats.DT_INTERNAL">
            <summary>
            Uses the system font to calculate text metrics.
            </summary>
        </member>
        <member name="F:PInvoke.User32.TextFormats.DT_EDITCONTROL">
            <summary>
            Duplicates the text-displaying characteristics of a multiline edit control.
            Specifically, the average character width is calculated in the same manner as for an edit control,
            and the function does not display a partially visible last line.
            </summary>
        </member>
        <member name="F:PInvoke.User32.TextFormats.DT_PATH_ELLIPSIS">
            <summary>
            For displayed text, replaces characters in the middle of the string with ellipses so that the result fits in the specified rectangle.
            If the string contains backslash (\) characters, DT_PATH_ELLIPSIS preserves as much as possible of the text after the last backslash.
            The string is not modified unless the <see cref="F:PInvoke.User32.TextFormats.DT_MODIFYSTRING"/> flag is specified.
            </summary>
            <remarks>Compare with <see cref="F:PInvoke.User32.TextFormats.DT_END_ELLIPSIS"/> and <see cref="F:PInvoke.User32.TextFormats.DT_WORD_ELLIPSIS"/>.</remarks>
        </member>
        <member name="F:PInvoke.User32.TextFormats.DT_END_ELLIPSIS">
            <summary>
            For displayed text, if the end of a string does not fit in the rectangle, it is truncated and ellipses are added.
            If a word that is not at the end of the string goes beyond the limits of the rectangle, it is truncated without ellipses.
            The string is not modified unless the <see cref="F:PInvoke.User32.TextFormats.DT_MODIFYSTRING"/> flag is specified.
            </summary>
            <remarks>Compare with <see cref="F:PInvoke.User32.TextFormats.DT_PATH_ELLIPSIS"/> and <see cref="F:PInvoke.User32.TextFormats.DT_WORD_ELLIPSIS"/>.</remarks>
        </member>
        <member name="F:PInvoke.User32.TextFormats.DT_MODIFYSTRING">
            <summary>
            Modifies the specified string to match the displayed text.
            </summary>
            <remarks>This value has no effect unless <see cref="F:PInvoke.User32.TextFormats.DT_END_ELLIPSIS"/> or <see cref="F:PInvoke.User32.TextFormats.DT_PATH_ELLIPSIS"/> is specified.</remarks>
        </member>
        <member name="F:PInvoke.User32.TextFormats.DT_RTLREADING">
            <summary>
            Layout in right-to-left reading order for bidirectional text when the font selected into the hdc is a Hebrew or Arabic font.
            The default reading order for all text is left-to-right.
            </summary>
        </member>
        <member name="F:PInvoke.User32.TextFormats.DT_WORD_ELLIPSIS">
            <summary>
            Truncates any word that does not fit in the rectangle and adds ellipses.
            </summary>
            <remarks>Compare with <see cref="F:PInvoke.User32.TextFormats.DT_END_ELLIPSIS"/> and <see cref="F:PInvoke.User32.TextFormats.DT_PATH_ELLIPSIS"/>.</remarks>
        </member>
        <member name="F:PInvoke.User32.TextFormats.DT_NOFULLWIDTHCHARBREAK">
            <summary>
            Prevents a line break at a DBCS (double-wide character string), so that the line breaking rule is equivalent to SBCS strings.
            For example, this can be used in Korean windows, for more readability of icon labels.
            </summary>
            <remarks>This value has no effect unless <see cref="F:PInvoke.User32.TextFormats.DT_WORDBREAK"/> is specified.</remarks>
        </member>
        <member name="F:PInvoke.User32.TextFormats.DT_HIDEPREFIX">
            <summary>
            Ignores the ampersand (&amp;) prefix character in the text. The letter that follows will not be underlined,
            but other mnemonic-prefix characters are still processed.
            </summary>
            <example>
            input string: "A&amp;b&amp;&amp;d"
            normal: "Abc&amp;d"
            DT_HIDEPREFIX: "Abc&amp;d"
            </example>
            <remarks>Compare with <see cref="F:PInvoke.User32.TextFormats.DT_NOPREFIX"/> and <see cref="F:PInvoke.User32.TextFormats.DT_PREFIXONLY"/>.</remarks>
        </member>
        <member name="F:PInvoke.User32.TextFormats.DT_PREFIXONLY">
            <summary>
            Draws only an underline at the position of the character following the ampersand (&amp;) prefix character.
            Does not draw any other characters in the string.
            </summary>
            <example>
            input string: "A&amp;b&amp;&amp;d"
            normal: "Abc&amp;d"
            DT_HIDEPREFIX: " _ "
            </example>
            <remarks>Compare with <see cref="F:PInvoke.User32.TextFormats.DT_HIDEPREFIX"/> and <see cref="F:PInvoke.User32.TextFormats.DT_NOPREFIX"/>.</remarks>
        </member>
        <member name="T:PInvoke.User32.USEROBJECTFLAGS">
            <summary>
            Contains information about a window station or desktop handle.
            </summary>
        </member>
        <member name="F:PInvoke.User32.USEROBJECTFLAGS.fInherit">
            <summary>
            If this member is TRUE, new processes inherit the handle. Otherwise, the handle is not inherited.
            </summary>
        </member>
        <member name="F:PInvoke.User32.USEROBJECTFLAGS.fReserved">
            <summary>
            Reserved for future use. This member must be FALSE.
            </summary>
        </member>
        <member name="F:PInvoke.User32.USEROBJECTFLAGS.dwFlags">
            <summary>
            Flags indicating object specific characteristics
            </summary>
        </member>
        <member name="T:PInvoke.User32.UserObjectFlagsEnum">
            <summary>
            Flags indicating user object specific characteristics
            </summary>
        </member>
        <member name="F:PInvoke.User32.UserObjectFlagsEnum.WSF_VISIBLE">
            <summary>
            For window stations, indicates that the window station has visible display surfaces
            </summary>
        </member>
        <member name="F:PInvoke.User32.UserObjectFlagsEnum.DF_ALLOWOTHERACCOUNTHOOK">
            <summary>
            For desktops, indicates that the desktop allows processes running in other accounts on the desktop to set hooks in this process.
            </summary>
        </member>
        <member name="T:PInvoke.User32.VirtualKey">
            <summary>Virtual-key codes</summary>
            <remarks>Defined in winuser.h from Windows SDK v6.1</remarks>
            <devremarks>
            APIs vary in the length they expect a parameter for virtual keys to be.
            Be sure to type the parameter as byte, ushort, or int as appropriate and document
            that the user should get the value from this enum and cast the result to ensure
            the method signature is compatible.
            </devremarks>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_NO_KEY">
            <summary>
            This is an addendum to use on functions in which you have to pass a zero value to represent no key code
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_LBUTTON">
            <summary>
            Left mouse button
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_RBUTTON">
            <summary>
            Right mouse button
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_CANCEL">
            <summary>
            Control-break processing
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_MBUTTON">
            <summary>
            Middle mouse button (three-button mouse)
            </summary>
            <remarks>NOT contiguous with L and R buttons</remarks>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_XBUTTON1">
            <summary>
            X1 mouse button
            </summary>
            <remarks>NOT contiguous with L and R buttons</remarks>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_XBUTTON2">
            <summary>
            X2 mouse button
            </summary>
            <remarks>NOT contiguous with L and R buttons</remarks>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_BACK">
            <summary>
            BACKSPACE key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_TAB">
            <summary>
            TAB key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_CLEAR">
            <summary>
            CLEAR key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_RETURN">
            <summary>
            RETURN key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_SHIFT">
            <summary>
            SHIFT key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_CONTROL">
            <summary>
            CONTROL key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_MENU">
            <summary>
            ALT key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_PAUSE">
            <summary>
            PAUSE key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_CAPITAL">
            <summary>
            CAPS LOCK key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_KANA">
            <summary>
            IME Kana mode
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_HANGEUL">
            <summary>
            IME Hanguel mode (maintained for compatibility; use <see cref="F:PInvoke.User32.VirtualKey.VK_HANGUL"/>)
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_HANGUL">
            <summary>
            IME Hangul mode
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_JUNJA">
            <summary>
            IME Junja mode
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_FINAL">
            <summary>
            IME final mode
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_HANJA">
            <summary>
            IME Hanja mode
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_KANJI">
            <summary>
            IME Kanji mode
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_ESCAPE">
            <summary>
            ESC key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_CONVERT">
            <summary>
            IME convert
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_NONCONVERT">
            <summary>
            IME nonconvert
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_ACCEPT">
            <summary>
            IME accept
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_MODECHANGE">
            <summary>
            IME mode change request
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_SPACE">
            <summary>
            SPACEBAR
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_PRIOR">
            <summary>
            PAGE UP key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_NEXT">
            <summary>
            PAGE DOWN key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_END">
            <summary>
            END key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_HOME">
            <summary>
            HOME key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_LEFT">
            <summary>
            LEFT ARROW key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_UP">
            <summary>
            UP ARROW key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_RIGHT">
            <summary>
            RIGHT ARROW key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_DOWN">
            <summary>
            DOWN ARROW key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_SELECT">
            <summary>
            SELECT key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_PRINT">
            <summary>
            PRINT key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_EXECUTE">
            <summary>
            EXECUTE key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_SNAPSHOT">
            <summary>
            PRINT SCREEN key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_INSERT">
            <summary>
            INS key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_DELETE">
            <summary>
            DEL key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_HELP">
            <summary>
            HELP key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_KEY_0">
            <summary>
            0 key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_KEY_1">
            <summary>
            1 key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_KEY_2">
            <summary>
            2 key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_KEY_3">
            <summary>
            3 key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_KEY_4">
            <summary>
            4 key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_KEY_5">
            <summary>
            5 key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_KEY_6">
            <summary>
            6 key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_KEY_7">
            <summary>
            7 key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_KEY_8">
            <summary>
            8 key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_KEY_9">
            <summary>
            9 key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_A">
            <summary>
            A key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_B">
            <summary>
            B key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_C">
            <summary>
            C key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_D">
            <summary>
            D key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_E">
            <summary>
            E key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_F">
            <summary>
            F key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_G">
            <summary>
            G key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_H">
            <summary>
            H key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_I">
            <summary>
            I key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_J">
            <summary>
            J key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_K">
            <summary>
            K key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_L">
            <summary>
            L key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_M">
            <summary>
            M key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_N">
            <summary>
            N key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_O">
            <summary>
            O key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_P">
            <summary>
            P key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_Q">
            <summary>
            Q key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_R">
            <summary>
            R key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_S">
            <summary>
            S key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_T">
            <summary>
            T key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_U">
            <summary>
            U key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_V">
            <summary>
            V key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_W">
            <summary>
            W key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_X">
            <summary>
            X key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_Y">
            <summary>
            Y key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_Z">
            <summary>
            Z key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_LWIN">
            <summary>
            Left Windows key (Natural keyboard)
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_RWIN">
            <summary>
            Right Windows key (Natural keyboard)
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_APPS">
            <summary>
            Applications key (Natural keyboard)
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_SLEEP">
            <summary>
            Computer Sleep key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_NUMPAD0">
            <summary>
            Numeric keypad 0 key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_NUMPAD1">
            <summary>
            Numeric keypad 1 key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_NUMPAD2">
            <summary>
            Numeric keypad 2 key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_NUMPAD3">
            <summary>
            Numeric keypad 3 key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_NUMPAD4">
            <summary>
            Numeric keypad 4 key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_NUMPAD5">
            <summary>
            Numeric keypad 5 key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_NUMPAD6">
            <summary>
            Numeric keypad 6 key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_NUMPAD7">
            <summary>
            Numeric keypad 7 key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_NUMPAD8">
            <summary>
            Numeric keypad 8 key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_NUMPAD9">
            <summary>
            Numeric keypad 9 key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_MULTIPLY">
            <summary>
            Multiply key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_ADD">
            <summary>
            Add key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_SEPARATOR">
            <summary>
            Separator key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_SUBTRACT">
            <summary>
            Subtract key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_DECIMAL">
            <summary>
            Decimal key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_DIVIDE">
            <summary>
            Divide key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_F1">
            <summary>
            F1 Key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_F2">
            <summary>
            F2 Key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_F3">
            <summary>
            F3 Key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_F4">
            <summary>
            F4 Key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_F5">
            <summary>
            F5 Key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_F6">
            <summary>
            F6 Key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_F7">
            <summary>
            F7 Key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_F8">
            <summary>
            F8 Key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_F9">
            <summary>
            F9 Key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_F10">
            <summary>
            F10 Key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_F11">
            <summary>
            F11 Key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_F12">
            <summary>
            F12 Key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_F13">
            <summary>
            F13 Key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_F14">
            <summary>
            F14 Key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_F15">
            <summary>
            F15 Key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_F16">
            <summary>
            F16 Key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_F17">
            <summary>
            F17 Key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_F18">
            <summary>
            F18 Key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_F19">
            <summary>
            F19 Key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_F20">
            <summary>
            F20 Key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_F21">
            <summary>
            F21 Key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_F22">
            <summary>
            F22 Key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_F23">
            <summary>
            F23 Key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_F24">
            <summary>
            F24 Key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_NUMLOCK">
            <summary>
            NUM LOCK key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_SCROLL">
            <summary>
            SCROLL LOCK key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_NEC_EQUAL">
            <summary>
            '=' key on numpad (NEC PC-9800 kbd definitions)
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_FJ_JISHO">
            <summary>
            'Dictionary' key (Fujitsu/OASYS kbd definitions)
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_FJ_MASSHOU">
            <summary>
            'Unregister word' key (Fujitsu/OASYS kbd definitions)
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_FJ_TOUROKU">
            <summary>
            'Register word' key (Fujitsu/OASYS kbd definitions)
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_FJ_LOYA">
            <summary>
            'Left OYAYUBI' key (Fujitsu/OASYS kbd definitions)
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_FJ_ROYA">
            <summary>
            'Right OYAYUBI' key (Fujitsu/OASYS kbd definitions)
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_LSHIFT">
            <summary>
            Left SHIFT key
            </summary>
            <remarks>Used only as parameters to <see cref="M:PInvoke.User32.GetAsyncKeyState(System.Int32)" /> and  <see cref="M:PInvoke.User32.GetKeyState(System.Int32)" />. * No other API or message will distinguish left and right keys in this way.</remarks>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_RSHIFT">
            <summary>
            Right SHIFT key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_LCONTROL">
            <summary>
            Left CONTROL key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_RCONTROL">
            <summary>
            Right CONTROL key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_LMENU">
            <summary>
            Left MENU key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_RMENU">
            <summary>
            Right MENU key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_BROWSER_BACK">
            <summary>
            Browser Back key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_BROWSER_FORWARD">
            <summary>
            Browser Forward  key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_BROWSER_REFRESH">
            <summary>
            Browser Refresh  key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_BROWSER_STOP">
            <summary>
            Browser Stop  key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_BROWSER_SEARCH">
            <summary>
            Browser Search  key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_BROWSER_FAVORITES">
            <summary>
            Browser Favorites  key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_BROWSER_HOME">
            <summary>
            Browser Start and Home key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_VOLUME_MUTE">
            <summary>
            Volume Mute key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_VOLUME_DOWN">
            <summary>
            Volume Down key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_VOLUME_UP">
            <summary>
            Volume Up key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_MEDIA_NEXT_TRACK">
            <summary>
            Next Track key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_MEDIA_PREV_TRACK">
            <summary>
            Previous Track key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_MEDIA_STOP">
            <summary>
            Stop Media key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_MEDIA_PLAY_PAUSE">
            <summary>
            Play/Pause Media key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_LAUNCH_MAIL">
            <summary>
            Start Mail key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_LAUNCH_MEDIA_SELECT">
            <summary>
            Select Media key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_LAUNCH_APP1">
            <summary>
            Start Application 1 key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_LAUNCH_APP2">
            <summary>
            Start Application 2 key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_1">
            <summary>
            Used for miscellaneous characters; it can vary by keyboard.
            </summary>
            <remarks>For the US standard keyboard, the ';:' key</remarks>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_PLUS">
            <summary>
            For any country/region, the '+' key.
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_COMMA">
            <summary>
            For any country/region, the ',' key.
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_MINUS">
            <summary>
            For any country/region, the '-' key.
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_PERIOD">
            <summary>
            For any country/region, the '.' key.
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_2">
            <summary>
            Used for miscellaneous characters; it can vary by keyboard.
            </summary>
            <remarks>For the US standard keyboard, the '/?' key</remarks>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_3">
            <summary>
            Used for miscellaneous characters; it can vary by keyboard.
            </summary>
            <remarks>For the US standard keyboard, the '`~' key</remarks>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_4">
            <summary>
            Used for miscellaneous characters; it can vary by keyboard.
            </summary>
            <remarks>For the US standard keyboard, the '[{' key</remarks>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_5">
            <summary>
            Used for miscellaneous characters; it can vary by keyboard.
            </summary>
            <remarks>For the US standard keyboard, the '\|' key</remarks>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_6">
            <summary>
            Used for miscellaneous characters; it can vary by keyboard.
            </summary>
            <remarks>For the US standard keyboard, the ']}' key</remarks>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_7">
            <summary>
            Used for miscellaneous characters; it can vary by keyboard.
            </summary>
            <remarks>For the US standard keyboard, the 'single-quote/double-quote' (''"') key</remarks>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_8">
            <summary>
            Used for miscellaneous characters; it can vary by keyboard.
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_AX">
            <summary>
            OEM specific
            </summary>
            <remarks>'AX' key on Japanese AX kbd</remarks>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_102">
            <summary>
            Either the angle bracket ("<![CDATA[<>]]>") key or the backslash ("\|") key on the RT 102-key keyboard
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_ICO_HELP">
            <summary>
            OEM specific
            </summary>
            <remarks>Help key on ICO</remarks>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_ICO_00">
            <summary>
            OEM specific
            </summary>
            <remarks>00 key on ICO</remarks>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_PROCESSKEY">
            <summary>
            IME PROCESS key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_ICO_CLEAR">
            <summary>
            OEM specific
            </summary>
            <remarks>Clear key on ICO</remarks>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_PACKET">
            <summary>
            Used to pass Unicode characters as if they were keystrokes. The VK_PACKET key is the low word of a 32-bit Virtual Key value used for non-keyboard input methods.
            </summary>
            <remarks>For more information, see Remark in <see cref="T:PInvoke.User32.KEYBDINPUT"/>, <see cref="M:PInvoke.User32.SendInput(System.Int32,PInvoke.User32.INPUT*,System.Int32)"/>, <see cref="F:PInvoke.User32.WindowMessage.WM_KEYDOWN"/>, and <see cref="F:PInvoke.User32.WindowMessage.WM_KEYUP"/></remarks>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_RESET">
            <summary>
            Nokia/Ericsson definition
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_JUMP">
            <summary>
            Nokia/Ericsson definition
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_PA1">
            <summary>
            Nokia/Ericsson definition
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_PA2">
            <summary>
            Nokia/Ericsson definition
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_PA3">
            <summary>
            Nokia/Ericsson definition
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_WSCTRL">
            <summary>
            Nokia/Ericsson definition
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_CUSEL">
            <summary>
            Nokia/Ericsson definition
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_ATTN">
            <summary>
            Nokia/Ericsson definition
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_FINISH">
            <summary>
            Nokia/Ericsson definition
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_COPY">
            <summary>
            Nokia/Ericsson definition
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_AUTO">
            <summary>
            Nokia/Ericsson definition
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_ENLW">
            <summary>
            Nokia/Ericsson definition
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_BACKTAB">
            <summary>
            Nokia/Ericsson definition
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_ATTN">
            <summary>
            Attn key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_CRSEL">
            <summary>
            CrSel key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_EXSEL">
            <summary>
            ExSel key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_EREOF">
            <summary>
            Erase EOF key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_PLAY">
            <summary>
            Play key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_ZOOM">
            <summary>
            Zoom key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_NONAME">
            <summary>
            Reserved constant by Windows headers definition
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_PA1">
            <summary>
            PA1 key
            </summary>
        </member>
        <member name="F:PInvoke.User32.VirtualKey.VK_OEM_CLEAR">
            <summary>
            Clear key
            </summary>
        </member>
        <member name="T:PInvoke.User32.WindowMessage">
            <summary>
            Windows Messages
            Defined in winuser.h from Windows SDK v6.1
            Documentation pulled from MSDN.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_NULL">
            <summary>
            The WM_NULL message performs no operation. An application sends the WM_NULL message if it wants to post a message that the recipient window will ignore.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_CREATE">
            <summary>
            The WM_CREATE message is sent when an application requests that a window be created by calling the CreateWindowEx or CreateWindow function. (The message is sent before the function returns.) The window procedure of the new window receives this message after the window is created, but before the window becomes visible.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_DESTROY">
            <summary>
            The WM_DESTROY message is sent when a window is being destroyed. It is sent to the window procedure of the window being destroyed after the window is removed from the screen.
            This message is sent first to the window being destroyed and then to the child windows (if any) as they are destroyed. During the processing of the message, it can be assumed that all child windows still exist.
            /// </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MOVE">
            <summary>
            The WM_MOVE message is sent after a window has been moved.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_SIZE">
            <summary>
            The WM_SIZE message is sent to a window after its size has changed.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_ACTIVATE">
            <summary>
            The WM_ACTIVATE message is sent to both the window being activated and the window being deactivated. If the windows use the same input queue, the message is sent synchronously, first to the window procedure of the top-level window being deactivated, then to the window procedure of the top-level window being activated. If the windows use different input queues, the message is sent asynchronously, so the window is activated immediately.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_SETFOCUS">
            <summary>
            The WM_SETFOCUS message is sent to a window after it has gained the keyboard focus.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_KILLFOCUS">
            <summary>
            The WM_KILLFOCUS message is sent to a window immediately before it loses the keyboard focus.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_ENABLE">
            <summary>
            The WM_ENABLE message is sent when an application changes the enabled state of a window. It is sent to the window whose enabled state is changing. This message is sent before the EnableWindow function returns, but after the enabled state (WS_DISABLED style bit) of the window has changed.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_SETREDRAW">
            <summary>
            An application sends the WM_SETREDRAW message to a window to allow changes in that window to be redrawn or to prevent changes in that window from being redrawn.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_SETTEXT">
            <summary>
            An application sends a WM_SETTEXT message to set the text of a window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_GETTEXT">
            <summary>
            An application sends a WM_GETTEXT message to copy the text that corresponds to a window into a buffer provided by the caller.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_GETTEXTLENGTH">
            <summary>
            An application sends a WM_GETTEXTLENGTH message to determine the length, in characters, of the text associated with a window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_PAINT">
            <summary>
            The WM_PAINT message is sent when the system or another application makes a request to paint a portion of an application's window. The message is sent when the UpdateWindow or RedrawWindow function is called, or by the DispatchMessage function when the application obtains a WM_PAINT message by using the GetMessage or PeekMessage function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_CLOSE">
            <summary>
            The WM_CLOSE message is sent as a signal that a window or an application should terminate.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_QUERYENDSESSION">
            <summary>
            The WM_QUERYENDSESSION message is sent when the user chooses to end the session or when an application calls one of the system shutdown functions. If any application returns zero, the session is not ended. The system stops sending WM_QUERYENDSESSION messages as soon as one application returns zero.
            After processing this message, the system sends the WM_ENDSESSION message with the wParam parameter set to the results of the WM_QUERYENDSESSION message.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_QUERYOPEN">
            <summary>
            The WM_QUERYOPEN message is sent to an icon when the user requests that the window be restored to its previous size and position.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_ENDSESSION">
            <summary>
            The WM_ENDSESSION message is sent to an application after the system processes the results of the WM_QUERYENDSESSION message. The WM_ENDSESSION message informs the application whether the session is ending.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_QUIT">
            <summary>
            The WM_QUIT message indicates a request to terminate an application and is generated when the application calls the PostQuitMessage function. It causes the GetMessage function to return zero.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_ERASEBKGND">
            <summary>
            The WM_ERASEBKGND message is sent when the window background must be erased (for example, when a window is resized). The message is sent to prepare an invalidated portion of a window for painting.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_SYSCOLORCHANGE">
            <summary>
            This message is sent to all top-level windows when a change is made to a system color setting.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_SHOWWINDOW">
            <summary>
            The WM_SHOWWINDOW message is sent to a window when the window is about to be hidden or shown.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_WININICHANGE">
            <summary>
            An application sends the WM_WININICHANGE message to all top-level windows after making a change to the WIN.INI file. The SystemParametersInfo function sends this message after an application uses the function to change a setting in WIN.INI.
            Note  The WM_WININICHANGE message is provided only for compatibility with earlier versions of the system. Applications should use the WM_SETTINGCHANGE message.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_SETTINGCHANGE">
            <summary>
            An application sends the WM_WININICHANGE message to all top-level windows after making a change to the WIN.INI file. The SystemParametersInfo function sends this message after an application uses the function to change a setting in WIN.INI.
            Note  The WM_WININICHANGE message is provided only for compatibility with earlier versions of the system. Applications should use the WM_SETTINGCHANGE message.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_DEVMODECHANGE">
            <summary>
            The WM_DEVMODECHANGE message is sent to all top-level windows whenever the user changes device-mode settings.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_ACTIVATEAPP">
            <summary>
            The WM_ACTIVATEAPP message is sent when a window belonging to a different application than the active window is about to be activated. The message is sent to the application whose window is being activated and to the application whose window is being deactivated.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_FONTCHANGE">
            <summary>
            An application sends the WM_FONTCHANGE message to all top-level windows in the system after changing the pool of font resources.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_TIMECHANGE">
            <summary>
            A message that is sent whenever there is a change in the system time.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_CANCELMODE">
            <summary>
            The WM_CANCELMODE message is sent to cancel certain modes, such as mouse capture. For example, the system sends this message to the active window when a dialog box or message box is displayed. Certain functions also send this message explicitly to the specified window regardless of whether it is the active window. For example, the EnableWindow function sends this message when disabling the specified window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_SETCURSOR">
            <summary>
            The WM_SETCURSOR message is sent to a window if the mouse causes the cursor to move within a window and mouse input is not captured.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MOUSEACTIVATE">
            <summary>
            The WM_MOUSEACTIVATE message is sent when the cursor is in an inactive window and the user presses a mouse button. The parent window receives this message only if the child window passes it to the DefWindowProc function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_CHILDACTIVATE">
            <summary>
            The WM_CHILDACTIVATE message is sent to a child window when the user clicks the window's title bar or when the window is activated, moved, or sized.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_QUEUESYNC">
            <summary>
            The WM_QUEUESYNC message is sent by a computer-based training (CBT) application to separate user-input messages from other messages sent through the WH_JOURNALPLAYBACK Hook procedure.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_GETMINMAXINFO">
            <summary>
            The WM_GETMINMAXINFO message is sent to a window when the size or position of the window is about to change. An application can use this message to override the window's default maximized size and position, or its default minimum or maximum tracking size.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_PAINTICON">
            <summary>
            Windows NT 3.51 and earlier: The WM_PAINTICON message is sent to a minimized window when the icon is to be painted. This message is not sent by newer versions of Microsoft Windows, except in unusual circumstances explained in the Remarks.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_ICONERASEBKGND">
            <summary>
            Windows NT 3.51 and earlier: The WM_ICONERASEBKGND message is sent to a minimized window when the background of the icon must be filled before painting the icon. A window receives this message only if a class icon is defined for the window; otherwise, WM_ERASEBKGND is sent. This message is not sent by newer versions of Windows.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_NEXTDLGCTL">
            <summary>
            The WM_NEXTDLGCTL message is sent to a dialog box procedure to set the keyboard focus to a different control in the dialog box.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_SPOOLERSTATUS">
            <summary>
            The WM_SPOOLERSTATUS message is sent from Print Manager whenever a job is added to or removed from the Print Manager queue.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_DRAWITEM">
            <summary>
            The WM_DRAWITEM message is sent to the parent window of an owner-drawn button, combo box, list box, or menu when a visual aspect of the button, combo box, list box, or menu has changed.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MEASUREITEM">
            <summary>
            The WM_MEASUREITEM message is sent to the owner window of a combo box, list box, list view control, or menu item when the control or menu is created.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_DELETEITEM">
            <summary>
            Sent to the owner of a list box or combo box when the list box or combo box is destroyed or when items are removed by the LB_DELETESTRING, LB_RESETCONTENT, CB_DELETESTRING, or CB_RESETCONTENT message. The system sends a WM_DELETEITEM message for each deleted item. The system sends the WM_DELETEITEM message for any deleted list box or combo box item with nonzero item data.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_VKEYTOITEM">
            <summary>
            Sent by a list box with the LBS_WANTKEYBOARDINPUT style to its owner in response to a WM_KEYDOWN message.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_CHARTOITEM">
            <summary>
            Sent by a list box with the LBS_WANTKEYBOARDINPUT style to its owner in response to a WM_CHAR message.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_SETFONT">
            <summary>
            An application sends a WM_SETFONT message to specify the font that a control is to use when drawing text.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_GETFONT">
            <summary>
            An application sends a WM_GETFONT message to a control to retrieve the font with which the control is currently drawing its text.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_SETHOTKEY">
            <summary>
            An application sends a WM_SETHOTKEY message to a window to associate a hot key with the window. When the user presses the hot key, the system activates the window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_GETHOTKEY">
            <summary>
            An application sends a WM_GETHOTKEY message to determine the hot key associated with a window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_QUERYDRAGICON">
            <summary>
            The WM_QUERYDRAGICON message is sent to a minimized (iconic) window. The window is about to be dragged by the user but does not have an icon defined for its class. An application can return a handle to an icon or cursor. The system displays this cursor or icon while the user drags the icon.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_COMPAREITEM">
            <summary>
            The system sends the WM_COMPAREITEM message to determine the relative position of a new item in the sorted list of an owner-drawn combo box or list box. Whenever the application adds a new item, the system sends this message to the owner of a combo box or list box created with the CBS_SORT or LBS_SORT style.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_GETOBJECT">
            <summary>
            Active Accessibility sends the WM_GETOBJECT message to obtain information about an accessible object contained in a server application.
            Applications never send this message directly. It is sent only by Active Accessibility in response to calls to AccessibleObjectFromPoint, AccessibleObjectFromEvent, or AccessibleObjectFromWindow. However, server applications handle this message.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_COMPACTING">
            <summary>
            The WM_COMPACTING message is sent to all top-level windows when the system detects more than 12.5 percent of system time over a 30- to 60-second interval is being spent compacting memory. This indicates that system memory is low.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_COMMNOTIFY">
            <summary>
            WM_COMMNOTIFY is Obsolete for Win32-Based Applications
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_WINDOWPOSCHANGING">
            <summary>
            The WM_WINDOWPOSCHANGING message is sent to a window whose size, position, or place in the Z order is about to change as a result of a call to the SetWindowPos function or another window-management function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_WINDOWPOSCHANGED">
            <summary>
            The WM_WINDOWPOSCHANGED message is sent to a window whose size, position, or place in the Z order has changed as a result of a call to the SetWindowPos function or another window-management function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_POWER">
            <summary>
            Notifies applications that the system, typically a battery-powered personal computer, is about to enter a suspended mode.
            Use: POWERBROADCAST
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_COPYDATA">
            <summary>
            An application sends the WM_COPYDATA message to pass data to another application.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_CANCELJOURNAL">
            <summary>
            The WM_CANCELJOURNAL message is posted to an application when a user cancels the application's journaling activities. The message is posted with a NULL window handle.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_NOTIFY">
            <summary>
            Sent by a common control to its parent window when an event has occurred or the control requires some information.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_INPUTLANGCHANGEREQUEST">
            <summary>
            The WM_INPUTLANGCHANGEREQUEST message is posted to the window with the focus when the user chooses a new input language, either with the hotkey (specified in the Keyboard control panel application) or from the indicator on the system taskbar. An application can accept the change by passing the message to the DefWindowProc function or reject the change (and prevent it from taking place) by returning immediately.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_INPUTLANGCHANGE">
            <summary>
            The WM_INPUTLANGCHANGE message is sent to the topmost affected window after an application's input language has been changed. You should make any application-specific settings and pass the message to the DefWindowProc function, which passes the message to all first-level child windows. These child windows can pass the message to DefWindowProc to have it pass the message to their child windows, and so on.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_TCARD">
            <summary>
            Sent to an application that has initiated a training card with Microsoft Windows Help. The message informs the application when the user clicks an authorable button. An application initiates a training card by specifying the HELP_TCARD command in a call to the WinHelp function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_HELP">
            <summary>
            Indicates that the user pressed the F1 key. If a menu is active when F1 is pressed, WM_HELP is sent to the window associated with the menu; otherwise, WM_HELP is sent to the window that has the keyboard focus. If no window has the keyboard focus, WM_HELP is sent to the currently active window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_USERCHANGED">
            <summary>
            The WM_USERCHANGED message is sent to all windows after the user has logged on or off. When the user logs on or off, the system updates the user-specific settings. The system sends this message immediately after updating the settings.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_NOTIFYFORMAT">
            <summary>
            Determines if a window accepts ANSI or Unicode structures in the WM_NOTIFY notification message. WM_NOTIFYFORMAT messages are sent from a common control to its parent window and from the parent window to the common control.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_CONTEXTMENU">
            <summary>
            The WM_CONTEXTMENU message notifies a window that the user clicked the right mouse button (right-clicked) in the window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_STYLECHANGING">
            <summary>
            The WM_STYLECHANGING message is sent to a window when the SetWindowLong function is about to change one or more of the window's styles.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_STYLECHANGED">
            <summary>
            The WM_STYLECHANGED message is sent to a window after the SetWindowLong function has changed one or more of the window's styles
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_DISPLAYCHANGE">
            <summary>
            The WM_DISPLAYCHANGE message is sent to all windows when the display resolution has changed.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_GETICON">
            <summary>
            The WM_GETICON message is sent to a window to retrieve a handle to the large or small icon associated with a window. The system displays the large icon in the ALT+TAB dialog, and the small icon in the window caption.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_SETICON">
            <summary>
            An application sends the WM_SETICON message to associate a new large or small icon with a window. The system displays the large icon in the ALT+TAB dialog box, and the small icon in the window caption.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_NCCREATE">
            <summary>
            The WM_NCCREATE message is sent prior to the WM_CREATE message when a window is first created.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_NCDESTROY">
            <summary>
            The WM_NCDESTROY message informs a window that its nonclient area is being destroyed. The DestroyWindow function sends the WM_NCDESTROY message to the window following the WM_DESTROY message. WM_DESTROY is used to free the allocated memory object associated with the window.
            The WM_NCDESTROY message is sent after the child windows have been destroyed. In contrast, WM_DESTROY is sent before the child windows are destroyed.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_NCCALCSIZE">
            <summary>
            The WM_NCCALCSIZE message is sent when the size and position of a window's client area must be calculated. By processing this message, an application can control the content of the window's client area when the size or position of the window changes.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_NCHITTEST">
            <summary>
            The WM_NCHITTEST message is sent to a window when the cursor moves, or when a mouse button is pressed or released. If the mouse is not captured, the message is sent to the window beneath the cursor. Otherwise, the message is sent to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_NCPAINT">
            <summary>
            The WM_NCPAINT message is sent to a window when its frame must be painted.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_NCACTIVATE">
            <summary>
            The WM_NCACTIVATE message is sent to a window when its nonclient area needs to be changed to indicate an active or inactive state.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_GETDLGCODE">
            <summary>
            The WM_GETDLGCODE message is sent to the window procedure associated with a control. By default, the system handles all keyboard input to the control; the system interprets certain types of keyboard input as dialog box navigation keys. To override this default behavior, the control can respond to the WM_GETDLGCODE message to indicate the types of input it wants to process itself.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_SYNCPAINT">
            <summary>
            The WM_SYNCPAINT message is used to synchronize painting while avoiding linking independent GUI threads.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_NCMOUSEMOVE">
            <summary>
            The WM_NCMOUSEMOVE message is posted to a window when the cursor is moved within the nonclient area of the window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_NCLBUTTONDOWN">
            <summary>
            The WM_NCLBUTTONDOWN message is posted when the user presses the left mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_NCLBUTTONUP">
            <summary>
            The WM_NCLBUTTONUP message is posted when the user releases the left mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_NCLBUTTONDBLCLK">
            <summary>
            The WM_NCLBUTTONDBLCLK message is posted when the user double-clicks the left mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_NCRBUTTONDOWN">
            <summary>
            The WM_NCRBUTTONDOWN message is posted when the user presses the right mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_NCRBUTTONUP">
            <summary>
            The WM_NCRBUTTONUP message is posted when the user releases the right mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_NCRBUTTONDBLCLK">
            <summary>
            The WM_NCRBUTTONDBLCLK message is posted when the user double-clicks the right mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_NCMBUTTONDOWN">
            <summary>
            The WM_NCMBUTTONDOWN message is posted when the user presses the middle mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_NCMBUTTONUP">
            <summary>
            The WM_NCMBUTTONUP message is posted when the user releases the middle mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_NCMBUTTONDBLCLK">
            <summary>
            The WM_NCMBUTTONDBLCLK message is posted when the user double-clicks the middle mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_NCXBUTTONDOWN">
            <summary>
            The WM_NCXBUTTONDOWN message is posted when the user presses the first or second X button while the cursor is in the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_NCXBUTTONUP">
            <summary>
            The WM_NCXBUTTONUP message is posted when the user releases the first or second X button while the cursor is in the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_NCXBUTTONDBLCLK">
            <summary>
            The WM_NCXBUTTONDBLCLK message is posted when the user double-clicks the first or second X button while the cursor is in the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_BM_CLICK">
            <summary>
            The WM_INPUT_DEVICE_CHANGE message is sent to the window that registered to receive raw input. A window receives this message through its WindowProc function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_INPUT_DEVICE_CHANGE">
            <summary>
            The WM_INPUT_DEVICE_CHANGE message is sent to the window that registered to receive raw input. A window receives this message through its WindowProc function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_INPUT">
            <summary>
            The WM_INPUT message is sent to the window that is getting raw input.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_KEYFIRST">
            <summary>
            This message filters for keyboard messages.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_KEYDOWN">
            <summary>
            The WM_KEYDOWN message is posted to the window with the keyboard focus when a nonsystem key is pressed. A nonsystem key is a key that is pressed when the ALT key is not pressed.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_KEYUP">
            <summary>
            The WM_KEYUP message is posted to the window with the keyboard focus when a nonsystem key is released. A nonsystem key is a key that is pressed when the ALT key is not pressed, or a keyboard key that is pressed when a window has the keyboard focus.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_CHAR">
            <summary>
            The WM_CHAR message is posted to the window with the keyboard focus when a WM_KEYDOWN message is translated by the TranslateMessage function. The WM_CHAR message contains the character code of the key that was pressed.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_DEADCHAR">
            <summary>
            The WM_DEADCHAR message is posted to the window with the keyboard focus when a WM_KEYUP message is translated by the TranslateMessage function. WM_DEADCHAR specifies a character code generated by a dead key. A dead key is a key that generates a character, such as the umlaut (double-dot), that is combined with another character to form a composite character. For example, the umlaut-O character (Ö) is generated by typing the dead key for the umlaut character, and then typing the O key.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_SYSKEYDOWN">
            <summary>
            The WM_SYSKEYDOWN message is posted to the window with the keyboard focus when the user presses the F10 key (which activates the menu bar) or holds down the ALT key and then presses another key. It also occurs when no window currently has the keyboard focus; in this case, the WM_SYSKEYDOWN message is sent to the active window. The window that receives the message can distinguish between these two contexts by checking the context code in the lParam parameter.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_SYSKEYUP">
            <summary>
            The WM_SYSKEYUP message is posted to the window with the keyboard focus when the user releases a key that was pressed while the ALT key was held down. It also occurs when no window currently has the keyboard focus; in this case, the WM_SYSKEYUP message is sent to the active window. The window that receives the message can distinguish between these two contexts by checking the context code in the lParam parameter.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_SYSCHAR">
            <summary>
            The WM_SYSCHAR message is posted to the window with the keyboard focus when a WM_SYSKEYDOWN message is translated by the TranslateMessage function. It specifies the character code of a system character key — that is, a character key that is pressed while the ALT key is down.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_SYSDEADCHAR">
            <summary>
            The WM_SYSDEADCHAR message is sent to the window with the keyboard focus when a WM_SYSKEYDOWN message is translated by the TranslateMessage function. WM_SYSDEADCHAR specifies the character code of a system dead key — that is, a dead key that is pressed while holding down the ALT key.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_UNICHAR">
            <summary>
            The WM_UNICHAR message is posted to the window with the keyboard focus when a WM_KEYDOWN message is translated by the TranslateMessage function. The WM_UNICHAR message contains the character code of the key that was pressed.
            The WM_UNICHAR message is equivalent to WM_CHAR, but it uses Unicode Transformation Format (UTF)-32, whereas WM_CHAR uses UTF-16. It is designed to send or post Unicode characters to ANSI windows and it can can handle Unicode Supplementary Plane characters.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_KEYLAST">
            <summary>
            This message filters for keyboard messages.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_IME_STARTCOMPOSITION">
            <summary>
            Sent immediately before the IME generates the composition string as a result of a keystroke. A window receives this message through its WindowProc function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_IME_ENDCOMPOSITION">
            <summary>
            Sent to an application when the IME ends composition. A window receives this message through its WindowProc function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_IME_COMPOSITION">
            <summary>
            Sent to an application when the IME changes composition status as a result of a keystroke. A window receives this message through its WindowProc function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_INITDIALOG">
            <summary>
            The WM_INITDIALOG message is sent to the dialog box procedure immediately before a dialog box is displayed. Dialog box procedures typically use this message to initialize controls and carry out any other initialization tasks that affect the appearance of the dialog box.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_COMMAND">
            <summary>
            The WM_COMMAND message is sent when the user selects a command item from a menu, when a control sends a notification message to its parent window, or when an accelerator keystroke is translated.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_SYSCOMMAND">
            <summary>
            A window receives this message when the user chooses a command from the Window menu, clicks the maximize button, minimize button, restore button, close button, or moves the form. You can stop the form from moving by filtering this out.
            <remarks>See <see cref="T:PInvoke.User32.SysCommands"/> for wParam.</remarks>
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_TIMER">
            <summary>
            The WM_TIMER message is posted to the installing thread's message queue when a timer expires. The message is posted by the GetMessage or PeekMessage function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_HSCROLL">
            <summary>
            The WM_HSCROLL message is sent to a window when a scroll event occurs in the window's standard horizontal scroll bar. This message is also sent to the owner of a horizontal scroll bar control when a scroll event occurs in the control.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_VSCROLL">
            <summary>
            The WM_VSCROLL message is sent to a window when a scroll event occurs in the window's standard vertical scroll bar. This message is also sent to the owner of a vertical scroll bar control when a scroll event occurs in the control.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_INITMENU">
            <summary>
            The WM_INITMENU message is sent when a menu is about to become active. It occurs when the user clicks an item on the menu bar or presses a menu key. This allows the application to modify the menu before it is displayed.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_INITMENUPOPUP">
            <summary>
            The WM_INITMENUPOPUP message is sent when a drop-down menu or submenu is about to become active. This allows an application to modify the menu before it is displayed, without changing the entire menu.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MENUSELECT">
            <summary>
            The WM_MENUSELECT message is sent to a menu's owner window when the user selects a menu item.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MENUCHAR">
            <summary>
            The WM_MENUCHAR message is sent when a menu is active and the user presses a key that does not correspond to any mnemonic or accelerator key. This message is sent to the window that owns the menu.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_ENTERIDLE">
            <summary>
            The WM_ENTERIDLE message is sent to the owner window of a modal dialog box or menu that is entering an idle state. A modal dialog box or menu enters an idle state when no messages are waiting in its queue after it has processed one or more previous messages.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MENURBUTTONUP">
            <summary>
            The WM_MENURBUTTONUP message is sent when the user releases the right mouse button while the cursor is on a menu item.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MENUDRAG">
            <summary>
            The WM_MENUDRAG message is sent to the owner of a drag-and-drop menu when the user drags a menu item.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MENUGETOBJECT">
            <summary>
            The WM_MENUGETOBJECT message is sent to the owner of a drag-and-drop menu when the mouse cursor enters a menu item or moves from the center of the item to the top or bottom of the item.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_UNINITMENUPOPUP">
            <summary>
            The WM_UNINITMENUPOPUP message is sent when a drop-down menu or submenu has been destroyed.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MENUCOMMAND">
            <summary>
            The WM_MENUCOMMAND message is sent when the user makes a selection from a menu.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_CHANGEUISTATE">
            <summary>
            An application sends the WM_CHANGEUISTATE message to indicate that the user interface (UI) state should be changed.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_UPDATEUISTATE">
            <summary>
            An application sends the WM_UPDATEUISTATE message to change the user interface (UI) state for the specified window and all its child windows.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_QUERYUISTATE">
            <summary>
            An application sends the WM_QUERYUISTATE message to retrieve the user interface (UI) state for a window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_CTLCOLORMSGBOX">
            <summary>
            The WM_CTLCOLORMSGBOX message is sent to the owner window of a message box before Windows draws the message box. By responding to this message, the owner window can set the text and background colors of the message box by using the given display device context handle.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_CTLCOLOREDIT">
            <summary>
            An edit control that is not read-only or disabled sends the WM_CTLCOLOREDIT message to its parent window when the control is about to be drawn. By responding to this message, the parent window can use the specified device context handle to set the text and background colors of the edit control.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_CTLCOLORLISTBOX">
            <summary>
            Sent to the parent window of a list box before the system draws the list box. By responding to this message, the parent window can set the text and background colors of the list box by using the specified display device context handle.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_CTLCOLORBTN">
            <summary>
            The WM_CTLCOLORBTN message is sent to the parent window of a button before drawing the button. The parent window can change the button's text and background colors. However, only owner-drawn buttons respond to the parent window processing this message.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_CTLCOLORDLG">
            <summary>
            The WM_CTLCOLORDLG message is sent to a dialog box before the system draws the dialog box. By responding to this message, the dialog box can set its text and background colors using the specified display device context handle.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_CTLCOLORSCROLLBAR">
            <summary>
            The WM_CTLCOLORSCROLLBAR message is sent to the parent window of a scroll bar control when the control is about to be drawn. By responding to this message, the parent window can use the display context handle to set the background color of the scroll bar control.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_CTLCOLORSTATIC">
            <summary>
            A static control, or an edit control that is read-only or disabled, sends the WM_CTLCOLORSTATIC message to its parent window when the control is about to be drawn. By responding to this message, the parent window can use the specified device context handle to set the text and background colors of the static control.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MOUSEFIRST">
            <summary>
            Use WM_MOUSEFIRST to specify the first mouse message. Use the PeekMessage() Function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MOUSEMOVE">
            <summary>
            The WM_MOUSEMOVE message is posted to a window when the cursor moves. If the mouse is not captured, the message is posted to the window that contains the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_LBUTTONDOWN">
            <summary>
            The WM_LBUTTONDOWN message is posted when the user presses the left mouse button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_LBUTTONUP">
            <summary>
            The WM_LBUTTONUP message is posted when the user releases the left mouse button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_LBUTTONDBLCLK">
            <summary>
            The WM_LBUTTONDBLCLK message is posted when the user double-clicks the left mouse button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_RBUTTONDOWN">
            <summary>
            The WM_RBUTTONDOWN message is posted when the user presses the right mouse button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_RBUTTONUP">
            <summary>
            The WM_RBUTTONUP message is posted when the user releases the right mouse button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_RBUTTONDBLCLK">
            <summary>
            The WM_RBUTTONDBLCLK message is posted when the user double-clicks the right mouse button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MBUTTONDOWN">
            <summary>
            The WM_MBUTTONDOWN message is posted when the user presses the middle mouse button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MBUTTONUP">
            <summary>
            The WM_MBUTTONUP message is posted when the user releases the middle mouse button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MBUTTONDBLCLK">
            <summary>
            The WM_MBUTTONDBLCLK message is posted when the user double-clicks the middle mouse button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MOUSEWHEEL">
            <summary>
            The WM_MOUSEWHEEL message is sent to the focus window when the mouse wheel is rotated. The DefWindowProc function propagates the message to the window's parent. There should be no internal forwarding of the message, since DefWindowProc propagates it up the parent chain until it finds a window that processes it.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_XBUTTONDOWN">
            <summary>
            The WM_XBUTTONDOWN message is posted when the user presses the first or second X button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_XBUTTONUP">
            <summary>
            The WM_XBUTTONUP message is posted when the user releases the first or second X button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_XBUTTONDBLCLK">
            <summary>
            The WM_XBUTTONDBLCLK message is posted when the user double-clicks the first or second X button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MOUSEHWHEEL">
            <summary>
            The WM_MOUSEHWHEEL message is sent to the focus window when the mouse's horizontal scroll wheel is tilted or rotated. The DefWindowProc function propagates the message to the window's parent. There should be no internal forwarding of the message, since DefWindowProc propagates it up the parent chain until it finds a window that processes it.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MOUSELAST">
            <summary>
            Use WM_MOUSELAST to specify the last mouse message. Used with PeekMessage() Function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_PARENTNOTIFY">
            <summary>
            The WM_PARENTNOTIFY message is sent to the parent of a child window when the child window is created or destroyed, or when the user clicks a mouse button while the cursor is over the child window. When the child window is being created, the system sends WM_PARENTNOTIFY just before the CreateWindow or CreateWindowEx function that creates the window returns. When the child window is being destroyed, the system sends the message before any processing to destroy the window takes place.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_ENTERMENULOOP">
            <summary>
            The WM_ENTERMENULOOP message informs an application's main window procedure that a menu modal loop has been entered.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_EXITMENULOOP">
            <summary>
            The WM_EXITMENULOOP message informs an application's main window procedure that a menu modal loop has been exited.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_NEXTMENU">
            <summary>
            The WM_NEXTMENU message is sent to an application when the right or left arrow key is used to switch between the menu bar and the system menu.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_SIZING">
            <summary>
            The WM_SIZING message is sent to a window that the user is resizing. By processing this message, an application can monitor the size and position of the drag rectangle and, if needed, change its size or position.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_CAPTURECHANGED">
            <summary>
            The WM_CAPTURECHANGED message is sent to the window that is losing the mouse capture.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MOVING">
            <summary>
            The WM_MOVING message is sent to a window that the user is moving. By processing this message, an application can monitor the position of the drag rectangle and, if needed, change its position.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_POWERBROADCAST">
            <summary>
            Notifies applications that a power-management event has occurred.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_DEVICECHANGE">
            <summary>
            Notifies an application of a change to the hardware configuration of a device or the computer.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MDICREATE">
            <summary>
            An application sends the WM_MDICREATE message to a multiple-document interface (MDI) client window to create an MDI child window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MDIDESTROY">
            <summary>
            An application sends the WM_MDIDESTROY message to a multiple-document interface (MDI) client window to close an MDI child window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MDIACTIVATE">
            <summary>
            An application sends the WM_MDIACTIVATE message to a multiple-document interface (MDI) client window to instruct the client window to activate a different MDI child window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MDIRESTORE">
            <summary>
            An application sends the WM_MDIRESTORE message to a multiple-document interface (MDI) client window to restore an MDI child window from maximized or minimized size.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MDINEXT">
            <summary>
            An application sends the WM_MDINEXT message to a multiple-document interface (MDI) client window to activate the next or previous child window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MDIMAXIMIZE">
            <summary>
            An application sends the WM_MDIMAXIMIZE message to a multiple-document interface (MDI) client window to maximize an MDI child window. The system resizes the child window to make its client area fill the client window. The system places the child window's window menu icon in the rightmost position of the frame window's menu bar, and places the child window's restore icon in the leftmost position. The system also appends the title bar text of the child window to that of the frame window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MDITILE">
            <summary>
            An application sends the WM_MDITILE message to a multiple-document interface (MDI) client window to arrange all of its MDI child windows in a tile format.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MDICASCADE">
            <summary>
            An application sends the WM_MDICASCADE message to a multiple-document interface (MDI) client window to arrange all its child windows in a cascade format.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MDIICONARRANGE">
            <summary>
            An application sends the WM_MDIICONARRANGE message to a multiple-document interface (MDI) client window to arrange all minimized MDI child windows. It does not affect child windows that are not minimized.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MDIGETACTIVE">
            <summary>
            An application sends the WM_MDIGETACTIVE message to a multiple-document interface (MDI) client window to retrieve the handle to the active MDI child window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MDISETMENU">
            <summary>
            An application sends the WM_MDISETMENU message to a multiple-document interface (MDI) client window to replace the entire menu of an MDI frame window, to replace the window menu of the frame window, or both.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_ENTERSIZEMOVE">
            <summary>
            The WM_ENTERSIZEMOVE message is sent one time to a window after it enters the moving or sizing modal loop. The window enters the moving or sizing modal loop when the user clicks the window's title bar or sizing border, or when the window passes the WM_SYSCOMMAND message to the DefWindowProc function and the wParam parameter of the message specifies the SC_MOVE or SC_SIZE value. The operation is complete when DefWindowProc returns.
            The system sends the WM_ENTERSIZEMOVE message regardless of whether the dragging of full windows is enabled.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_EXITSIZEMOVE">
            <summary>
            The WM_EXITSIZEMOVE message is sent one time to a window, after it has exited the moving or sizing modal loop. The window enters the moving or sizing modal loop when the user clicks the window's title bar or sizing border, or when the window passes the WM_SYSCOMMAND message to the DefWindowProc function and the wParam parameter of the message specifies the SC_MOVE or SC_SIZE value. The operation is complete when DefWindowProc returns.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_DROPFILES">
            <summary>
            Sent when the user drops a file on the window of an application that has registered itself as a recipient of dropped files.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MDIREFRESHMENU">
            <summary>
            An application sends the WM_MDIREFRESHMENU message to a multiple-document interface (MDI) client window to refresh the window menu of the MDI frame window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_IME_SETCONTEXT">
            <summary>
            Sent to an application when a window is activated. A window receives this message through its WindowProc function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_IME_NOTIFY">
            <summary>
            Sent to an application to notify it of changes to the IME window. A window receives this message through its WindowProc function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_IME_CONTROL">
            <summary>
            Sent by an application to direct the IME window to carry out the requested command. The application uses this message to control the IME window that it has created. To send this message, the application calls the SendMessage function with the following parameters.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_IME_COMPOSITIONFULL">
            <summary>
            Sent to an application when the IME window finds no space to extend the area for the composition window. A window receives this message through its WindowProc function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_IME_SELECT">
            <summary>
            Sent to an application when the operating system is about to change the current IME. A window receives this message through its WindowProc function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_IME_CHAR">
            <summary>
            Sent to an application when the IME gets a character of the conversion result. A window receives this message through its WindowProc function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_IME_REQUEST">
            <summary>
            Sent to an application to provide commands and request information. A window receives this message through its WindowProc function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_IME_KEYDOWN">
            <summary>
            Sent to an application by the IME to notify the application of a key press and to keep message order. A window receives this message through its WindowProc function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_IME_KEYUP">
            <summary>
            Sent to an application by the IME to notify the application of a key release and to keep message order. A window receives this message through its WindowProc function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MOUSEHOVER">
            <summary>
            The WM_MOUSEHOVER message is posted to a window when the cursor hovers over the client area of the window for the period of time specified in a prior call to TrackMouseEvent.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_MOUSELEAVE">
            <summary>
            The WM_MOUSELEAVE message is posted to a window when the cursor leaves the client area of the window specified in a prior call to TrackMouseEvent.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_NCMOUSEHOVER">
            <summary>
            The WM_NCMOUSEHOVER message is posted to a window when the cursor hovers over the nonclient area of the window for the period of time specified in a prior call to TrackMouseEvent.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_NCMOUSELEAVE">
            <summary>
            The WM_NCMOUSELEAVE message is posted to a window when the cursor leaves the nonclient area of the window specified in a prior call to TrackMouseEvent.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_WTSSESSION_CHANGE">
            <summary>
            The WM_WTSSESSION_CHANGE message notifies applications of changes in session state.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_DPICHANGED">
            <summary>
            The WM_DISPLAYCHANGE message is sent when the effective dots per inch (dpi) for a window has changed. The DPI is the scale factor for a window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_DPICHANGED_BEFOREPARENT">
            <summary>
            For Per Monitor v2 top-level windows, this message is sent to all HWNDs in the child HWDN tree of the window that is undergoing a DPI change. This message occurs before the top-level window receives <see cref="F:PInvoke.User32.WindowMessage.WM_DPICHANGED"/>, and traverses the child tree from the bottom up.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_DPICHANGED_AFTERPARENT">
            <summary>
            For Per Monitor v2 top-level windows, this message is sent to all HWNDs in the child HWDN tree of the window that is undergoing a DPI change. This message occurs after the top-level window receives <see cref="F:PInvoke.User32.WindowMessage.WM_DPICHANGED"/>, and traverses the child tree from the top down.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_GETDPISCALEDSIZE">
            <summary>
            The WM_GETDPISCALEDSIZE message tells the operating system that the window will be sized to dimensions other than the default.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_CUT">
            <summary>
            An application sends a WM_CUT message to an edit control or combo box to delete (cut) the current selection, if any, in the edit control and copy the deleted text to the clipboard in CF_TEXT format.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_COPY">
            <summary>
            An application sends the WM_COPY message to an edit control or combo box to copy the current selection to the clipboard in CF_TEXT format.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_PASTE">
            <summary>
            An application sends a WM_PASTE message to an edit control or combo box to copy the current content of the clipboard to the edit control at the current caret position. Data is inserted only if the clipboard contains data in CF_TEXT format.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_CLEAR">
            <summary>
            An application sends a WM_CLEAR message to an edit control or combo box to delete (clear) the current selection, if any, from the edit control.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_UNDO">
            <summary>
            An application sends a WM_UNDO message to an edit control to undo the last operation. When this message is sent to an edit control, the previously deleted text is restored or the previously added text is deleted.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_RENDERFORMAT">
            <summary>
            The WM_RENDERFORMAT message is sent to the clipboard owner if it has delayed rendering a specific clipboard format and if an application has requested data in that format. The clipboard owner must render data in the specified format and place it on the clipboard by calling the SetClipboardData function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_RENDERALLFORMATS">
            <summary>
            The WM_RENDERALLFORMATS message is sent to the clipboard owner before it is destroyed, if the clipboard owner has delayed rendering one or more clipboard formats. For the content of the clipboard to remain available to other applications, the clipboard owner must render data in all the formats it is capable of generating, and place the data on the clipboard by calling the SetClipboardData function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_DESTROYCLIPBOARD">
            <summary>
            The WM_DESTROYCLIPBOARD message is sent to the clipboard owner when a call to the EmptyClipboard function empties the clipboard.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_DRAWCLIPBOARD">
            <summary>
            The WM_DRAWCLIPBOARD message is sent to the first window in the clipboard viewer chain when the content of the clipboard changes. This enables a clipboard viewer window to display the new content of the clipboard.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_PAINTCLIPBOARD">
            <summary>
            The WM_PAINTCLIPBOARD message is sent to the clipboard owner by a clipboard viewer window when the clipboard contains data in the CF_OWNERDISPLAY format and the clipboard viewer's client area needs repainting.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_VSCROLLCLIPBOARD">
            <summary>
            The WM_VSCROLLCLIPBOARD message is sent to the clipboard owner by a clipboard viewer window when the clipboard contains data in the CF_OWNERDISPLAY format and an event occurs in the clipboard viewer's vertical scroll bar. The owner should scroll the clipboard image and update the scroll bar values.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_SIZECLIPBOARD">
            <summary>
            The WM_SIZECLIPBOARD message is sent to the clipboard owner by a clipboard viewer window when the clipboard contains data in the CF_OWNERDISPLAY format and the clipboard viewer's client area has changed size.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_ASKCBFORMATNAME">
            <summary>
            The WM_ASKCBFORMATNAME message is sent to the clipboard owner by a clipboard viewer window to request the name of a CF_OWNERDISPLAY clipboard format.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_CHANGECBCHAIN">
            <summary>
            The WM_CHANGECBCHAIN message is sent to the first window in the clipboard viewer chain when a window is being removed from the chain.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_HSCROLLCLIPBOARD">
            <summary>
            The WM_HSCROLLCLIPBOARD message is sent to the clipboard owner by a clipboard viewer window. This occurs when the clipboard contains data in the CF_OWNERDISPLAY format and an event occurs in the clipboard viewer's horizontal scroll bar. The owner should scroll the clipboard image and update the scroll bar values.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_QUERYNEWPALETTE">
            <summary>
            This message informs a window that it is about to receive the keyboard focus, giving the window the opportunity to realize its logical palette when it receives the focus.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_PALETTEISCHANGING">
            <summary>
            The WM_PALETTEISCHANGING message informs applications that an application is going to realize its logical palette.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_PALETTECHANGED">
            <summary>
            This message is sent by the OS to all top-level and overlapped windows after the window with the keyboard focus realizes its logical palette.
            This message enables windows that do not have the keyboard focus to realize their logical palettes and update their client areas.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_HOTKEY">
            <summary>
            The WM_HOTKEY message is posted when the user presses a hot key registered by the RegisterHotKey function. The message is placed at the top of the message queue associated with the thread that registered the hot key.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_PRINT">
            <summary>
            The WM_PRINT message is sent to a window to request that it draw itself in the specified device context, most commonly in a printer device context.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_PRINTCLIENT">
            <summary>
            The WM_PRINTCLIENT message is sent to a window to request that it draw its client area in the specified device context, most commonly in a printer device context.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_APPCOMMAND">
            <summary>
            The WM_APPCOMMAND message notifies a window that the user generated an application command event, for example, by clicking an application command button using the mouse or typing an application command key on the keyboard.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_THEMECHANGED">
            <summary>
            The WM_THEMECHANGED message is broadcast to every window following a theme change event. Examples of theme change events are the activation of a theme, the deactivation of a theme, or a transition from one theme to another.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_CLIPBOARDUPDATE">
            <summary>
            Sent when the contents of the clipboard have changed.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_DWMCOMPOSITIONCHANGED">
            <summary>
            The system will send a window the WM_DWMCOMPOSITIONCHANGED message to indicate that the availability of desktop composition has changed.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_DWMNCRENDERINGCHANGED">
            <summary>
            WM_DWMNCRENDERINGCHANGED is called when the non-client area rendering status of a window has changed. Only windows that have set the flag DWM_BLURBEHIND.fTransitionOnMaximized to true will get this message.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_DWMCOLORIZATIONCOLORCHANGED">
            <summary>
            Sent to all top-level windows when the colorization color has changed.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_DWMWINDOWMAXIMIZEDCHANGE">
            <summary>
            WM_DWMWINDOWMAXIMIZEDCHANGE will let you know when a DWM composed window is maximized. You also have to register for this message as well. You'd have other window go opaque when this message is sent.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_GETTITLEBARINFOEX">
            <summary>
            Sent to request extended title bar information. A window receives this message through its WindowProc function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_APP">
            <summary>
            The WM_APP constant is used by applications to help define private messages, usually of the form WM_APP+X, where X is an integer value.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_USER">
            <summary>
            The WM_USER constant is used by applications to help define private messages for use by private window classes, usually of the form WM_USER+X, where X is an integer value.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_CPL_LAUNCH">
            <summary>
            An application sends the WM_CPL_LAUNCH message to Windows Control Panel to request that a Control Panel application be started.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_CPL_LAUNCHED">
            <summary>
            The WM_CPL_LAUNCHED message is sent when a Control Panel application, started by the WM_CPL_LAUNCH message, has closed. The WM_CPL_LAUNCHED message is sent to the window identified by the wParam parameter of the WM_CPL_LAUNCH message that started the application.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_SYSTIMER">
            <summary>
            WM_SYSTIMER is a well-known yet still undocumented message. Windows uses WM_SYSTIMER for internal actions like scrolling.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_HSHELL_ACCESSIBILITYSTATE">
            <summary>
            The accessibility state has changed.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_HSHELL_ACTIVATESHELLWINDOW">
            <summary>
            The shell should activate its main window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_HSHELL_APPCOMMAND">
            <summary>
            The user completed an input event (for example, pressed an application command button on the mouse or an application command key on the keyboard), and the application did not handle the WM_APPCOMMAND message generated by that input.
            If the Shell procedure handles the WM_COMMAND message, it should not call CallNextHookEx. See the Return Value section for more information.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_HSHELL_GETMINRECT">
            <summary>
            A window is being minimized or maximized. The system needs the coordinates of the minimized rectangle for the window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_HSHELL_LANGUAGE">
            <summary>
            Keyboard language was changed or a new keyboard layout was loaded.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_HSHELL_REDRAW">
            <summary>
            The title of a window in the task bar has been redrawn.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_HSHELL_TASKMAN">
            <summary>
            The user has selected the task list. A shell application that provides a task list should return TRUE to prevent Windows from starting its task list.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_HSHELL_WINDOWCREATED">
            <summary>
            A top-level, unowned window has been created. The window exists when the system calls this hook.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_HSHELL_WINDOWDESTROYED">
            <summary>
            A top-level, unowned window is about to be destroyed. The window still exists when the system calls this hook.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_HSHELL_WINDOWACTIVATED">
            <summary>
            The activation has changed to a different top-level, unowned window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowMessage.WM_HSHELL_WINDOWREPLACED">
            <summary>
            A top-level window is being replaced. The window exists when the system calls this hook.
            </summary>
        </member>
        <member name="T:PInvoke.User32.WINDOWPLACEMENT">
            <summary>
            Contains information about the placement of a window on the screen.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WINDOWPLACEMENT.length">
            <summary>
            The length of the structure, in bytes. Before calling the GetWindowPlacement or SetWindowPlacement functions,
            set this member to sizeof(WINDOWPLACEMENT).
            <para>GetWindowPlacement and SetWindowPlacement fail if this member is not set correctly.</para>
            </summary>
        </member>
        <member name="F:PInvoke.User32.WINDOWPLACEMENT.flags">
            <summary>The flags that control the position of the minimized window and the method by which the window is restored.</summary>
        </member>
        <member name="F:PInvoke.User32.WINDOWPLACEMENT.showCmd">
            <summary>The current show state of the window.</summary>
        </member>
        <member name="F:PInvoke.User32.WINDOWPLACEMENT.ptMinPosition">
            <summary>The coordinates of the window's upper-left corner when the window is minimized.</summary>
        </member>
        <member name="F:PInvoke.User32.WINDOWPLACEMENT.ptMaxPosition">
            <summary>The coordinates of the window's upper-left corner when the window is maximized.</summary>
        </member>
        <member name="F:PInvoke.User32.WINDOWPLACEMENT.rcNormalPosition">
            <summary>The window's coordinates when the window is in the restored position.</summary>
        </member>
        <member name="M:PInvoke.User32.WINDOWPLACEMENT.Create">
            <summary>
            Create a new instance of <see cref="T:PInvoke.User32.WINDOWPLACEMENT"/> with <see cref="F:PInvoke.User32.WINDOWPLACEMENT.length"/> set to the correct value.
            </summary>
            <returns>A new instance of <see cref="T:PInvoke.User32.WINDOWPLACEMENT"/> with <see cref="F:PInvoke.User32.WINDOWPLACEMENT.length"/> set to the correct value.</returns>
        </member>
        <member name="T:PInvoke.User32.WindowPlacementFlags">
            <summary>Flags for the flags member of <see cref="T:PInvoke.User32.WINDOWPLACEMENT" /> structure.</summary>
        </member>
        <member name="F:PInvoke.User32.WindowPlacementFlags.WPF_SETMINPOSITION">
            <summary>
            The coordinates of the minimized window may be specified.
            <para>
            This flag must be specified if the coordinates are set in the <see cref="F:PInvoke.User32.WINDOWPLACEMENT.ptMinPosition" />
            member.
            </para>
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowPlacementFlags.WPF_RESTORETOMAXIMIZED">
            <summary>
            The restored window will be maximized, regardless of whether it was maximized before it was minimized. This setting is
            only valid the next time the window is restored. It does not change the default restoration behavior.
            <para>
            This flag is only valid when the <see cref="F:PInvoke.User32.WindowShowStyle.SW_SHOWMINIMIZED" /> value is specified for the
            <see cref="F:PInvoke.User32.WINDOWPLACEMENT.showCmd" /> member.
            </para>
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowPlacementFlags.WPF_ASYNCWINDOWPLACEMENT">
            <summary>
            If the calling thread and the thread that owns the window are attached to different input queues, the system
            posts the request to the thread that owns the window. This prevents the calling thread from blocking its execution
            while other threads process the request.
            </summary>
        </member>
        <member name="T:PInvoke.User32.WindowsEventHookFlags">
            <summary>Flag values that specify the location of the hook function and of the events to be skipped. <see cref="M:PInvoke.User32.SetWinEventHook(PInvoke.User32.WindowsEventHookType,PInvoke.User32.WindowsEventHookType,System.IntPtr,System.IntPtr,System.Int32,System.Int32,PInvoke.User32.WindowsEventHookFlags)" />.</summary>
        </member>
        <member name="F:PInvoke.User32.WindowsEventHookFlags.WINEVENT_OUTOFCONTEXT">
            <summary>
                The callback function is not mapped into the address space of the process that generates the
                event. Because the hook function is called across process boundaries, the system must queue
                events. Although this method is asynchronous, events are guaranteed to be in sequential order.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowsEventHookFlags.WINEVENT_SKIPOWNTHREAD">
            <summary>
                Prevents this instance of the hook from receiving the events that are generated by the thread that
                is registering this hook.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowsEventHookFlags.WINEVENT_SKIPOWNPROCESS">
            <summary>
                Prevents this instance of the hook from receiving the events that are generated by threads in this process.
                This flag does not prevent threads from generating events.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowsEventHookFlags.WINEVENT_INCONTEXT">
            <summary>
                The DLL that contains the callback function is mapped into the address space of the
                process that generates the event. With this flag, the system sends event notifications
                to the callback function as they occur. The hook function must be in a DLL when this flag
                is specified. This flag has no effect when both the calling process and the generating process
                are not 32-bit or 64-bit processes, or when the generating process is a console application.
            </summary>
        </member>
        <member name="T:PInvoke.User32.WindowsEventHookType">
            <summary>
                The type of hook procedure to be installed by <see cref="M:PInvoke.User32.SetWinEventHook(PInvoke.User32.WindowsEventHookType,PInvoke.User32.WindowsEventHookType,System.IntPtr,System.IntPtr,System.Int32,System.Int32,PInvoke.User32.WindowsEventHookFlags)" />.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowsEventHookType.EVENT_AIA_START">
            <summary>
                The range of WinEvent constant values specified by the Accessibility Interoperability Alliance (AIA) for use across the industry.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowsEventHookType.EVENT_MIN">
            <summary>
                The lowest possible event values.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowsEventHookType.EVENT_MAX">
            <summary>
                The highest possible event values.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowsEventHookType.EVENT_OBJECT_ACCELERATORCHANGE">
            <summary>
                An object's KeyboardShortcut property has changed. Server applications send this event
                for their accessible objects.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowsEventHookType.EVENT_OBJECT_CONTENTSCROLLED">
            <summary>
                A window object's scrolling has ended. Unlike <see cref="F:PInvoke.User32.WindowsEventHookType.EVENT_SYSTEM_SCROLLINGEND"/>, this event is
                associated with the scrolling window. Whether the scrolling is horizontal or vertical scrolling,
                this event should be sent whenever the scroll action is completed.
                The hwnd parameter of the WinEventProc callback function describes the scrolling window;
                the idObject parameter is OBJID_CLIENT, and the idChild parameter is CHILDID_SELF.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowsEventHookType.EVENT_OBJECT_CREATE">
            <summary>
                An object has been created. The system sends this event for the following user interface elements: caret,
                header control, list-view control, tab control, toolbar control, tree view control, and window object.
                Server applications send this event for their accessible objects.
                Before sending the event for the parent object, servers must send it for all of an object's child objects.
                Servers must ensure that all child objects are fully created and ready to accept IAccessible calls from
                clients before the parent object sends this event.
                Because a parent object is created after its child objects, clients must make sure that an object's parent
                has been created before calling IAccessible::get_accParent, particularly if in-context hook functions are
                used.
            </summary>
        </member>
        <member name="T:PInvoke.User32.WindowsHookType">
            <summary>The type of hook procedure to be installed by <see cref="M:PInvoke.User32.SetWindowsHookEx(PInvoke.User32.WindowsHookType,System.IntPtr,System.IntPtr,System.Int32)" />.</summary>
        </member>
        <member name="F:PInvoke.User32.WindowsHookType.WH_MSGFILTER">
            <summary>
                Installs a hook procedure that monitors messages generated as a result of an input event in a dialog box,
                message box, menu, or scroll bar.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowsHookType.WH_JOURNALRECORD">
            <summary>
                Installs a hook procedure that records input messages posted to the system message queue. This hook is useful
                for recording macros.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowsHookType.WH_JOURNALPLAYBACK">
            <summary>Installs a hook procedure that posts messages previously recorded by a WH_JOURNALRECORD hook procedure.</summary>
        </member>
        <member name="F:PInvoke.User32.WindowsHookType.WH_KEYBOARD">
            <summary>Installs a hook procedure that monitors keystroke messages.</summary>
        </member>
        <member name="F:PInvoke.User32.WindowsHookType.WH_GETMESSAGE">
            <summary>Installs a hook procedure that monitors messages posted to a message queue.</summary>
        </member>
        <member name="F:PInvoke.User32.WindowsHookType.WH_CALLWNDPROC">
            <summary>
                Installs a hook procedure that monitors messages before the system sends them to the destination window
                procedure.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowsHookType.WH_CBT">
            <summary>Installs a hook procedure that receives notifications useful to a CBT application.</summary>
        </member>
        <member name="F:PInvoke.User32.WindowsHookType.WH_SYSMSGFILTER">
            <summary>
                nstalls a hook procedure that monitors messages generated as a result of an input event in a dialog box,
                message box, menu, or scroll bar. The hook procedure monitors these messages for all applications in the same
                desktop as the calling thread.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowsHookType.WH_MOUSE">
            <summary>Installs a hook procedure that monitors mouse messages.</summary>
        </member>
        <member name="F:PInvoke.User32.WindowsHookType.WH_DEBUG">
            <summary>Installs a hook procedure useful for debugging other hook procedures.</summary>
        </member>
        <member name="F:PInvoke.User32.WindowsHookType.WH_SHELL">
            <summary>Installs a hook procedure that receives notifications useful to shell applications.</summary>
        </member>
        <member name="F:PInvoke.User32.WindowsHookType.WH_FOREGROUNDIDLE">
            <summary>
                Installs a hook procedure that will be called when the application's foreground thread is about to become
                idle. This hook is useful for performing low priority tasks during idle time.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowsHookType.WH_CALLWNDPROCRET">
            <summary>
                Installs a hook procedure that monitors messages after they have been processed by the destination window
                procedure.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowsHookType.WH_KEYBOARD_LL">
            <summary>Installs a hook procedure that monitors low-level keyboard input events.</summary>
        </member>
        <member name="F:PInvoke.User32.WindowsHookType.WH_MOUSE_LL">
            <summary>Installs a hook procedure that monitors low-level mouse input events.</summary>
        </member>
        <member name="T:PInvoke.User32.WindowShowStyle">
            <summary>Enumeration of the different ways of showing a window using
            ShowWindow</summary>
        </member>
        <member name="F:PInvoke.User32.WindowShowStyle.SW_HIDE">
            <summary>Hides the window and activates another window.</summary>
        </member>
        <member name="F:PInvoke.User32.WindowShowStyle.SW_SHOWNORMAL">
            <summary>Activates and displays a window. If the window is minimized
            or maximized, the system restores it to its original size and
            position. An application should specify this flag when displaying
            the window for the first time.</summary>
        </member>
        <member name="F:PInvoke.User32.WindowShowStyle.SW_SHOWMINIMIZED">
            <summary>Activates the window and displays it as a minimized window.</summary>
        </member>
        <member name="F:PInvoke.User32.WindowShowStyle.SW_SHOWMAXIMIZED">
            <summary>Activates the window and displays it as a maximized window.</summary>
        </member>
        <member name="F:PInvoke.User32.WindowShowStyle.SW_MAXIMIZE">
            <summary>Maximizes the specified window.</summary>
        </member>
        <member name="F:PInvoke.User32.WindowShowStyle.SW_SHOWNOACTIVATE">
            <summary>Displays a window in its most recent size and position.
            This value is similar to "ShowNormal", except the window is not
            actived.</summary>
        </member>
        <member name="F:PInvoke.User32.WindowShowStyle.SW_SHOW">
            <summary>Activates the window and displays it in its current size
            and position.</summary>
        </member>
        <member name="F:PInvoke.User32.WindowShowStyle.SW_MINIMIZE">
            <summary>Minimizes the specified window and activates the next
            top-level window in the Z order.</summary>
        </member>
        <member name="F:PInvoke.User32.WindowShowStyle.SW_SHOWMINNOACTIVE">
            <summary>Displays the window as a minimized window. This value is
            similar to "ShowMinimized", except the window is not activated.</summary>
        </member>
        <member name="F:PInvoke.User32.WindowShowStyle.SW_SHOWNA">
            <summary>Displays the window in its current size and position. This
            value is similar to "Show", except the window is not activated.</summary>
        </member>
        <member name="F:PInvoke.User32.WindowShowStyle.SW_RESTORE">
            <summary>Activates and displays the window. If the window is
            minimized or maximized, the system restores it to its original size
            and position. An application should specify this flag when restoring
            a minimized window.</summary>
        </member>
        <member name="F:PInvoke.User32.WindowShowStyle.SW_SHOWDEFAULT">
            <summary>Sets the show state based on the SW_ value specified in the
            STARTUPINFO structure passed to the CreateProcess function by the
            program that started the application.</summary>
        </member>
        <member name="F:PInvoke.User32.WindowShowStyle.SW_FORCEMINIMIZE">
            <summary>Windows 2000/XP: Minimizes a window, even if the thread
            that owns the window is hung. This flag should only be used when
            minimizing windows from a different thread.</summary>
        </member>
        <member name="T:PInvoke.User32.WindowStationCreationFlags">
            <summary>
            Controls the behaviour of <see cref="M:PInvoke.User32.CreateWindowStation(System.String,PInvoke.User32.WindowStationCreationFlags,PInvoke.Kernel32.ACCESS_MASK,System.Nullable{PInvoke.Kernel32.SECURITY_ATTRIBUTES})" /> when a window station with the desired name already exists/>
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStationCreationFlags.CWF_CREATE_ONLY">
            <summary>
            Enables processes running in other accounts on the desktop to set hooks in this process
            </summary>
        </member>
        <member name="T:PInvoke.User32.WindowStyles">
            <summary>
            Window Styles. The following styles can be specified wherever a window style is required.
            After the control has been created, these styles cannot be modified, except as noted.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStyles.WS_BORDER">
            <summary>
            The window has a thin-line border.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStyles.WS_CAPTION">
            <summary>
            The window has a title bar (includes the WS_BORDER style).
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStyles.WS_CHILD">
            <summary>
            The window is a child window. A window with this style cannot have a menu bar. This style
            cannot be used with the WS_POPUP style.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStyles.WS_CLIPCHILDREN">
            <summary>
            Excludes the area occupied by child windows when drawing occurs within the parent window.
            This style is used when creating the parent window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStyles.WS_CLIPSIBLINGS">
            <summary>
            Clips child windows relative to each other; that is, when a particular child window
            receives a WM_PAINT message, the WS_CLIPSIBLINGS style clips all other overlapping child
            windows out of the region of the child window to be updated. If WS_CLIPSIBLINGS is not
            specified and child windows overlap, it is possible, when drawing within the client area
            of a child window, to draw within the client area of a neighboring child window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStyles.WS_DISABLED">
            <summary>
            The window is initially disabled. A disabled window cannot receive input from the user.
            To change this after a window has been created, use the EnableWindow function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStyles.WS_DLGFRAME">
            <summary>
            The window has a border of a style typically used with dialog boxes. A window with this
            style cannot have a title bar.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStyles.WS_GROUP">
            <summary>
            The window is the first control of a group of controls. The group consists of this first
            control and all controls defined after it, up to the next control with the WS_GROUP
            style. The first control in each group usually has the WS_TABSTOP style so that the user
            can move from group to group. The user can subsequently change the keyboard focus from
            one control in the group to the next control in the group by using the direction keys.
            You can turn this style on and off to change dialog box navigation. To change this style
            after a window has been created, use the SetWindowLong function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStyles.WS_HSCROLL">
            <summary>
            The window has a horizontal scroll bar.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStyles.WS_MAXIMIZE">
            <summary>
            The window is initially maximized.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStyles.WS_MAXIMIZEBOX">
            <summary>
            The window has a maximize button. Cannot be combined with the WS_EX_CONTEXTHELP style.
            The WS_SYSMENU style must also be specified.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStyles.WS_MINIMIZE">
            <summary>
            The window is initially minimized.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStyles.WS_MINIMIZEBOX">
            <summary>
            The window has a minimize button. Cannot be combined with the WS_EX_CONTEXTHELP style.
            The WS_SYSMENU style must also be specified.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStyles.WS_OVERLAPPED">
            <summary>
            The window is an overlapped window. An overlapped window has a title bar and a border.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStyles.WS_OVERLAPPEDWINDOW">
            <summary>
            The window is an overlapped window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStyles.WS_POPUP">
            <summary>
            The window is a pop-up window. This style cannot be used with the WS_CHILD style.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStyles.WS_POPUPWINDOW">
            <summary>
            The window is a pop-up window. The WS_CAPTION and WS_POPUPWINDOW styles must be combined
            to make the window menu visible.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStyles.WS_SIZEFRAME">
            <summary>
            The window has a sizing border.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStyles.WS_SYSMENU">
            <summary>
            The window has a window menu on its title bar. The WS_CAPTION style must also be specified.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStyles.WS_TABSTOP">
            <summary>
            The window is a control that can receive the keyboard focus when the user presses the TAB
            key. Pressing the TAB key changes the keyboard focus to the next control with the
            WS_TABSTOP style. You can turn this style on and off to change dialog box navigation. To
            change this style after a window has been created, use the SetWindowLong function. For
            user-created windows and modeless dialogs to work with tab stops, alter the message loop
            to call the IsDialogMessage function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStyles.WS_VISIBLE">
            <summary>
            The window is initially visible. This style can be turned on and off by using the
            ShowWindow or SetWindowPos function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStyles.WS_VSCROLL">
            <summary>
            The window has a vertical scroll bar.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStylesEx.WS_EX_ACCEPTFILES">
            <summary>
            Specifies a window that accepts drag-drop files.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStylesEx.WS_EX_APPWINDOW">
            <summary>
            Forces a top-level window onto the taskbar when the window is visible.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStylesEx.WS_EX_CLIENTEDGE">
            <summary>
            Specifies a window that has a border with a sunken edge.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStylesEx.WS_EX_COMPOSITED">
            <summary>
            Specifies a window that paints all descendants in bottom-to-top painting order using
            double-buffering. This cannot be used if the window has a class style of either CS_OWNDC
            or CS_CLASSDC. This style is not supported in Windows 2000.
            </summary>
            <remarks>
            With WS_EX_COMPOSITED set, all descendants of a window get bottom-to-top painting order
            using double-buffering. Bottom-to-top painting order allows a descendant window to have
            translucency (alpha) and transparency (color-key) effects, but only if the descendant
            window also has the WS_EX_TRANSPARENT bit set. Double-buffering allows the window and its
            descendents to be painted without flicker.
            </remarks>
        </member>
        <member name="F:PInvoke.User32.WindowStylesEx.WS_EX_CONTEXTHELP">
            <summary>
            Specifies a window that includes a question mark in the title bar. When the user clicks
            the question mark, the cursor changes to a question mark with a pointer. If the user then
            clicks a child window, the child receives a WM_HELP message. The child window should pass
            the message to the parent window procedure, which should call the WinHelp function using
            the HELP_WM_HELP command. The Help application displays a pop-up window that typically
            contains help for the child window. WS_EX_CONTEXTHELP cannot be used with the
            WS_MAXIMIZEBOX or WS_MINIMIZEBOX styles.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStylesEx.WS_EX_CONTROLPARENT">
            <summary>
            Specifies a window which contains child windows that should take part in dialog box
            navigation. If this style is specified, the dialog manager recurses into children of this
            window when performing navigation operations such as handling the TAB key, an arrow key,
            or a keyboard mnemonic.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStylesEx.WS_EX_DLGMODALFRAME">
            <summary>
            Specifies a window that has a double border.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStylesEx.WS_EX_LAYERED">
            <summary>
            Specifies a window that is a layered window. This cannot be used for child windows or if
            the window has a class style of either CS_OWNDC or CS_CLASSDC.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStylesEx.WS_EX_LAYOUTRTL">
            <summary>
            Specifies a window with the horizontal origin on the right edge. Increasing horizontal
            values advance to the left. The shell language must support reading-order alignment for
            this to take effect.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStylesEx.WS_EX_LEFT">
            <summary>
            Specifies a window that has generic left-aligned properties. This is the default.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStylesEx.WS_EX_LEFTSCROLLBAR">
            <summary>
            Specifies a window with the vertical scroll bar (if present) to the left of the client
            area. The shell language must support reading-order alignment for this to take effect.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStylesEx.WS_EX_LTRREADING">
            <summary>
            Specifies a window that displays text using left-to-right reading-order properties. This
            is the default.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStylesEx.WS_EX_MDICHILD">
            <summary>
            Specifies a multiple-document interface (MDI) child window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStylesEx.WS_EX_NOACTIVATE">
            <summary>
            Specifies a top-level window created with this style does not become the foreground
            window when the user clicks it. The system does not bring this window to the foreground
            when the user minimizes or closes the foreground window. The window does not appear on
            the taskbar by default. To force the window to appear on the taskbar, use the
            WS_EX_APPWINDOW style. To activate the window, use the SetActiveWindow or
            SetForegroundWindow function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStylesEx.WS_EX_NOINHERITLAYOUT">
            <summary>
            Specifies a window which does not pass its window layout to its child windows.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStylesEx.WS_EX_NOPARENTNOTIFY">
            <summary>
            Specifies that a child window created with this style does not send the WM_PARENTNOTIFY
            message to its parent window when it is created or destroyed.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStylesEx.WS_EX_OVERLAPPEDWINDOW">
            <summary>
            Specifies an overlapped window.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStylesEx.WS_EX_PALETTEWINDOW">
            <summary>
            Specifies a palette window, which is a modeless dialog box that presents an array of commands.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStylesEx.WS_EX_RIGHT">
            <summary>
            Specifies a window that has generic "right-aligned" properties. This depends on the
            window class. The shell language must support reading-order alignment for this to take
            effect. Using the WS_EX_RIGHT style has the same effect as using the SS_RIGHT (static),
            ES_RIGHT (edit), and BS_RIGHT/BS_RIGHTBUTTON (button) control styles.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStylesEx.WS_EX_RIGHTSCROLLBAR">
            <summary>
            Specifies a window with the vertical scroll bar (if present) to the right of the client
            area. This is the default.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStylesEx.WS_EX_RTLREADING">
            <summary>
            Specifies a window that displays text using right-to-left reading-order properties. The
            shell language must support reading-order alignment for this to take effect.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStylesEx.WS_EX_STATICEDGE">
            <summary>
            Specifies a window with a three-dimensional border style intended to be used for items
            that do not accept user input.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStylesEx.WS_EX_TOOLWINDOW">
            <summary>
            Specifies a window that is intended to be used as a floating toolbar. A tool window has a
            title bar that is shorter than a normal title bar, and the window title is drawn using a
            smaller font. A tool window does not appear in the taskbar or in the dialog that appears
            when the user presses ALT+TAB. If a tool window has a system menu, its icon is not
            displayed on the title bar. However, you can display the system menu by right-clicking or
            by typing ALT+SPACE.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStylesEx.WS_EX_TOPMOST">
            <summary>
            Specifies a window that should be placed above all non-topmost windows and should stay
            above them, even when the window is deactivated. To add or remove this style, use the
            SetWindowPos function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStylesEx.WS_EX_TRANSPARENT">
            <summary>
            Specifies a window that should not be painted until siblings beneath the window (that
            were created by the same thread) have been painted. The window appears transparent
            because the bits of underlying sibling windows have already been painted. To achieve
            transparency without these restrictions, use the SetWindowRgn function.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WindowStylesEx.WS_EX_WINDOWEDGE">
            <summary>
            Specifies a window that has a border with a raised edge.
            </summary>
        </member>
        <member name="T:PInvoke.User32.WNDCLASSEX">
            <summary>
            Contains window class information. It is used with the <see cref="M:PInvoke.User32.RegisterClassEx(PInvoke.User32.WNDCLASSEX@)"/> and <see cref="M:PInvoke.User32.GetClassInfoEx(System.IntPtr,System.String,PInvoke.User32.WNDCLASSEX@)"/> functions.
            The <see cref="T:PInvoke.User32.WNDCLASSEX"/> structure is similar to the <see cref="T:PInvoke.User32.WNDCLASS"/> structure. There are two differences. <see cref="T:PInvoke.User32.WNDCLASSEX"/> includes the <see cref="F:PInvoke.User32.WNDCLASSEX.cbSize"/> member, which specifies the size of the structure, and the <see cref="F:PInvoke.User32.WNDCLASSEX.hIconSm"/> member, which contains a handle to a small icon associated with the window class.
            </summary>
        </member>
        <member name="F:PInvoke.User32.WHEEL_DELTA">
            <summary>
            The multiplicative constant 120 for calculating mouse wheel movement.
            </summary>
            <remarks>
            See https://msdn.microsoft.com/en-us/library/windows/desktop/ms646254(v=vs.85).aspx
            </remarks>
        </member>
        <member name="F:PInvoke.User32.CCHDEVICENAME">
            <summary>
            Size of a device name string
            </summary>
        </member>
        <member name="F:PInvoke.User32.CW_USEDEFAULT">
            <summary>
            Default parameters for <see cref="M:PInvoke.User32.CreateWindowEx(PInvoke.User32.WindowStylesEx,System.String,System.String,PInvoke.User32.WindowStyles,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)"/>
            </summary>
        </member>
        <member name="F:PInvoke.User32.LF_FACESIZE">
            <summary>
            Size of a font name or a font family name
            </summary>
        </member>
        <member name="F:PInvoke.User32.HBMMENU_CALLBACK">
            <summary>
                A bitmap that is drawn by the window that owns the menu. The application must process the WM_MEASUREITEM and
                WM_DRAWITEM messages.
            </summary>
        </member>
        <member name="F:PInvoke.User32.HBMMENU_MBAR_CLOSE">
            <summary>Close button for the menu bar.</summary>
        </member>
        <member name="F:PInvoke.User32.HBMMENU_MBAR_CLOSE_D">
            <summary>Disabled close button for the menu bar.</summary>
        </member>
        <member name="F:PInvoke.User32.HBMMENU_MBAR_MINIMIZE">
            <summary>Minimize button for the menu bar.</summary>
        </member>
        <member name="F:PInvoke.User32.HBMMENU_MBAR_MINIMIZE_D">
            <summary>Disabled minimize button for the menu bar.</summary>
        </member>
        <member name="F:PInvoke.User32.HBMMENU_MBAR_RESTORE">
            <summary>Restore button for the menu bar.</summary>
        </member>
        <member name="F:PInvoke.User32.HBMMENU_POPUP_CLOSE">
            <summary>Close button for the submenu.</summary>
        </member>
        <member name="F:PInvoke.User32.HBMMENU_POPUP_MAXIMIZE">
            <summary>Maximize button for the submenu.</summary>
        </member>
        <member name="F:PInvoke.User32.HBMMENU_POPUP_MINIMIZE">
            <summary>Minimize button for the submenu.</summary>
        </member>
        <member name="F:PInvoke.User32.HBMMENU_POPUP_RESTORE">
            <summary>Restore button for the submenu.</summary>
        </member>
        <member name="F:PInvoke.User32.HBMMENU_SYSTEM">
            <summary>Windows icon or the icon of the window specified in <see cref="F:PInvoke.User32.MENUITEMINFO.dwItemData" />.</summary>
        </member>
        <member name="F:PInvoke.User32.DPI_AWARENESS_CONTEXT_UNAWARE">
            <summary>
            Gets the predefined DPI_AWARENESS_CONTEXT handle for DPI unaware mode. These windows do not scale
            for DPI changes and are always assumed to have a scale factor of 100% (96 DPI). They will be automatically scaled by
            the system on any other DPI setting.
            </summary>
            <remarks>DPI_AWARENESS_CONTEXT values should never be compared directly. Instead, use AreDpiAwarenessContextsEqual function</remarks>
        </member>
        <member name="F:PInvoke.User32.DPI_AWARENESS_CONTEXT_SYSTEM_AWARE">
            <summary>
            Gets the predefined DPI_AWARENESS_CONTEXT handle for System aware mode. These windows do not scale for DPI changes.
            They will query for the DPI once and use that value for the lifetime of the process. If the DPI changes,
            the process will not adjust to the new DPI value. It will be automatically scaled up or down by the system
            when the DPI changes from the system value.
            </summary>
            <remarks>DPI_AWARENESS_CONTEXT values should never be compared directly. Instead, use AreDpiAwarenessContextsEqual function</remarks>
        </member>
        <member name="F:PInvoke.User32.DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE">
            <summary>
            Gets the predefined DPI_AWARENESS_CONTEXT handle for the Per Monitor mode. These windows check for the DPI when
            they are created and adjust the scale factor whenever the DPI changes. These processes are not automatically
            scaled by the system.
            </summary>
            <remarks>DPI_AWARENESS_CONTEXT values should never be compared directly. Instead, use AreDpiAwarenessContextsEqual function</remarks>
        </member>
        <member name="F:PInvoke.User32.DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2">
            <summary>
            Gets the predefined DPI_AWARENESS_CONTEXT handle for Per Monitor v2 mode.
            Per Monitor v2 is an advancement over the original Per Monitor DPI awareness mode, which enables applications to access
            new DPI-related scaling behaviors on a per top-level window basis. Per Monitor v2 was made available in the
            Creators Update of Windows 10, and is not available on earlier versions of the operating system. The additional behaviors
            introduced are as follows:
            <list type="bullet">
            <item>Child window DPI change notifications - In Per Monitor v2 contexts, the entire window tree is notified of any DPI changes that occur.</item>
            <item>Scaling of non-client area - All windows will automatically have their non-client area drawn in a DPI sensitive fashion. Calls to EnableNonClientDpiScaling are unnecessary.</item>
            <item>Scaling of Win32 menus - All NTUSER menus created in Per Monitor v2 contexts will be scaling in a per-monitor fashion.</item>
            <item>Dialog Scaling - Win32 dialogs created in Per Monitor v2 contexts will automatically respond to DPI changes.</item>
            <item>Improved scaling of comctl32 controls - Various comctl32 controls have improved DPI scaling behavior in Per Monitor v2 contexts.</item>
            <item>Improved theming behavior - UxTheme handles opened in the context of a Per Monitor v2 window will operate in terms of the DPI associated with that window.</item>
            </list>
            </summary>
            <remarks>DPI_AWARENESS_CONTEXT values should never be compared directly. Instead, use AreDpiAwarenessContextsEqual function</remarks>
        </member>
        <member name="F:PInvoke.User32.HWND_BROADCAST">
            <summary>
            A special windows handle used to indicate to <see cref="M:PInvoke.User32.SendMessage(System.IntPtr,PInvoke.User32.WindowMessage,System.IntPtr,System.IntPtr)" />
            that the message is sent to all top-level windows in the system, including disabled or invisible unowned windows,
            overlapped windows, and pop-up windows.
            </summary>
        </member>
        <member name="T:PInvoke.User32.WindowsHookDelegate">
            <summary>
            An application-defined or library-defined callback function used with the <see cref="M:PInvoke.User32.SetWindowsHookEx(PInvoke.User32.WindowsHookType,System.IntPtr,System.IntPtr,System.Int32)"/> function.
            This is a generic function to Hook callbacks. For specific callback functions see this <see href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms632589(v=vs.85).aspx" >API documentation on MSDN</see>.
            </summary>
            <param name="nCode">An action code for the callback. Can be used to indicate if the hook procedure must process the message or not.</param>
            <param name="wParam">First message parameter</param>
            <param name="lParam">Second message parameter</param>
            <returns>
            An LRESULT. Usually if nCode is less than zero, the hook procedure must return the value returned by CallNextHookEx.
            If nCode is greater than or equal to zero, it is highly recommended that you call CallNextHookEx and return the value it returns;
            otherwise, other applications that have installed hooks will not receive hook notifications and may behave incorrectly as a result.
            If the hook procedure does not call CallNextHookEx, the return value should be zero.
            </returns>
        </member>
        <member name="T:PInvoke.User32.WinEventProc">
            <summary>
            An application-defined callback (or hook) function that the system calls in response to events generated by an accessible object.
            The hook function processes the event notifications as required. Clients install the hook function and request specific types
            of event notifications by calling <see cref="M:PInvoke.User32.SetWinEventHook(PInvoke.User32.WindowsEventHookType,PInvoke.User32.WindowsEventHookType,System.IntPtr,System.IntPtr,System.Int32,System.Int32,PInvoke.User32.WindowsEventHookFlags)"/>.
            </summary>
            <param name="hWinEventHook">Handle to an event hook function. This value is returned by SetWinEventHook when the hook function
            is installed and is specific to each instance of the hook function.</param>
            <param name="event">Specifies the event that occurred. This value is one of the <see cref="T:PInvoke.User32.WindowsEventHookType"/> constants.</param>
            <param name="hwnd">Handle to the window that generates the event, or NULL if no window is associated with the event.
            For example, the mouse pointer is not associated with a window.</param>
            <param name="idObject">Identifies the object associated with the event. This is one of the object identifiers or a custom object ID.
            <see href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd373606(v=vs.85).aspx"/></param>
            <param name="idChild">Identifies whether the event was triggered by an object or a child element of the object.
            If this value is CHILDID_SELF, the event was triggered by the object; otherwise, this value is the child ID of the element that triggered the event.</param>
            <param name="dwEventThread">Identifies the thread that generated the event, or the thread that owns the current window.</param>
            <param name="dwmsEventTime">Specifies the time, in milliseconds, that the event was generated.</param>
        </member>
        <member name="T:PInvoke.User32.WINSTAENUMPROC">
            <summary>
            An application-defined callback function used with the <see cref="M:PInvoke.User32.EnumWindowStations(PInvoke.User32.WINSTAENUMPROC,System.IntPtr)"/> function.
            </summary>
            <param name="lpszWindowStation">The name of the window station.</param>
            <param name="lParam">An application-defined value specified in the <see cref="M:PInvoke.User32.EnumWindowStations(PInvoke.User32.WINSTAENUMPROC,System.IntPtr)"/> function.</param>
            <returns>To continue enumeration, the callback function must return TRUE (non-zero value). To stop enumeration, it must return FALSE (0).</returns>
            <remarks>
            An application must register this callback function by passing its address to <see cref="M:PInvoke.User32.EnumWindowStations(PInvoke.User32.WINSTAENUMPROC,System.IntPtr)"/>.
            The callback function can call SetLastError to set an error code for the caller to retrieve by calling GetLastError.
            </remarks>
        </member>
        <member name="T:PInvoke.User32.DESKTOPENUMPROC">
            <summary>
            An application-defined callback function used with the <see cref="M:PInvoke.User32.EnumDesktops(PInvoke.User32.SafeWindowStationHandle,PInvoke.User32.DESKTOPENUMPROC,System.IntPtr)"/> function.
            </summary>
            <param name="lpwstrDesktopName">The name of the desktop.</param>
            <param name="lParam">An application-defined value specified in the <see cref="M:PInvoke.User32.EnumDesktops(PInvoke.User32.SafeWindowStationHandle,PInvoke.User32.DESKTOPENUMPROC,System.IntPtr)"/> function.</param>
            <returns>To continue enumeration, the callback function must return TRUE (non-zero value). To stop enumeration, it must return FALSE (0).</returns>
            <remarks>
            An application must register this callback function by passing its address to <see cref="M:PInvoke.User32.EnumDesktops(PInvoke.User32.SafeWindowStationHandle,PInvoke.User32.DESKTOPENUMPROC,System.IntPtr)"/>.
            The callback function can call SetLastError to set an error code for the caller to retrieve by calling GetLastError.
            </remarks>
        </member>
        <member name="T:PInvoke.User32.WNDENUMPROC">
            <summary> An application-defined callback function used with the <see cref="M:PInvoke.User32.EnumWindows(PInvoke.User32.WNDENUMPROC,System.IntPtr)"/> or <see cref="M:PInvoke.User32.EnumDesktopWindows(PInvoke.User32.SafeDesktopHandle,PInvoke.User32.WNDENUMPROC,System.IntPtr)"/> function.</summary>
            <param name="hwnd">A handle to a top-level window.</param>
            <param name="lParam">The application-defined value given in <see cref="M:PInvoke.User32.EnumWindows(PInvoke.User32.WNDENUMPROC,System.IntPtr)"/> or <see cref="M:PInvoke.User32.EnumDesktopWindows(PInvoke.User32.SafeDesktopHandle,PInvoke.User32.WNDENUMPROC,System.IntPtr)"/>.</param>
            <returns>To continue enumeration, the callback function must return TRUE; to stop enumeration, it must return FALSE.</returns>
            <remarks>
            An application must register this callback function by passing its address to <see cref="M:PInvoke.User32.EnumWindows(PInvoke.User32.WNDENUMPROC,System.IntPtr)"/> or <see cref="M:PInvoke.User32.EnumDesktopWindows(PInvoke.User32.SafeDesktopHandle,PInvoke.User32.WNDENUMPROC,System.IntPtr)"/>.
            The callback function can call SetLastError to set an error code for the caller to retrieve by calling GetLastError.
            </remarks>
        </member>
        <member name="T:PInvoke.User32.DialogProc">
            <summary>
                Application-defined callback function used with the CreateDialog and DialogBox families of functions. It processes
                messages sent to a modal or modeless dialog box.
            </summary>
            <param name="hwndDlg">A handle to the dialog box.</param>
            <param name="uMsg">The message.</param>
            <param name="wParam">Additional message-specific information.</param>
            <param name="lParam">Additional message-specific information.</param>
            <returns>
                Typically, the dialog box procedure should return TRUE if it processed the message, and FALSE if it did not. If the
                dialog box procedure returns FALSE, the dialog manager performs the default dialog operation in response to the
                message.
                <para>
                    If the dialog box procedure processes a message that requires a specific return value, the dialog box
                    procedure should set the desired return value by calling <see cref="M:PInvoke.User32.SetWindowLong(System.IntPtr,PInvoke.User32.WindowLongIndexFlags,PInvoke.User32.SetWindowLongFlags)" /> with
                    <see cref="F:PInvoke.User32.WindowLongIndexFlags.DWLP_MSGRESULT" /> immediately before returning TRUE. Note that you must call
                    SetWindowLong immediately before returning TRUE; doing so earlier may result in the
                    <see cref="F:PInvoke.User32.WindowLongIndexFlags.DWLP_MSGRESULT" /> value being overwritten by a nested dialog box message.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.User32.MessageBeep(PInvoke.User32.MessageBeepType)">
            <summary>
            Plays a waveform sound. The waveform sound for each sound type is identified by an entry in the registry.
            </summary>
            <param name="uType">The sound to be played. The sounds are set by the user through the Sound control panel application, and then stored in the registry.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:PInvoke.User32.GetClassName(System.IntPtr,System.Char*,System.Int32)">
            <summary>
            Retrieves the name of the class to which the specified window belongs.
            </summary>
            <param name="hWnd">A handle to the window and, indirectly, the class to which the window belongs.</param>
            <param name="lpClassName">The class name string.</param>
            <param name="nMaxCount">
            The length of the <paramref name="lpClassName"/> buffer, in characters. The buffer must be large enough to include the terminating null character; otherwise, the class name string is truncated to <paramref name="nMaxCount"/>-1 characters.
            </param>
            <returns>
            If the function succeeds, the return value is the number of characters copied to the buffer, not including the terminating null character.
            If the function fails, the return value is zero. To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:PInvoke.User32.GetWindowThreadProcessId(System.IntPtr,System.Int32@)">
            <summary>
            Retrieves the identifier of the thread that created the specified window and, optionally, the identifier of the process that created the window.
            </summary>
            <param name="hWnd">A handle to the window. </param>
            <param name="lpdwProcessId">A pointer to a variable that receives the process identifier. If this parameter is not NULL, GetWindowThreadProcessId copies the identifier of the process to the variable; otherwise, it does not.</param>
            <returns>The return value is the identifier of the thread that created the window. </returns>
        </member>
        <member name="M:PInvoke.User32.AttachThreadInput(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Attaches or detaches the input processing mechanism of one thread to that of another thread.
            </summary>
            <param name="idAttach">The identifier of the thread to be attached to another thread. The thread to be attached cannot be a system thread.</param>
            <param name="idAttachTo">The identifier of the thread to which idAttach will be attached. This thread cannot be a system thread. A thread cannot attach to itself. Therefore, idAttachTo cannot equal idAttach.</param>
            <param name="fAttach">If this parameter is TRUE, the two threads are attached. If the parameter is FALSE, the threads are detached.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError. Windows Server2003 and WindowsXP: There is no extended error information; do not call GetLastError. This behavior changed as of WindowsVista.</returns>
        </member>
        <member name="M:PInvoke.User32.GetClientRect(System.IntPtr,PInvoke.RECT@)">
            <summary>
            Retrieves the coordinates of a window's client area. The client coordinates specify the upper-left and lower-right corners of the client area. Because client coordinates are relative to the upper-left corner of a window's client area, the coordinates of the upper-left corner are (0,0).
            </summary>
            <param name="hWnd">A handle to the window whose client coordinates are to be retrieved.</param>
            <param name="lpRect">A pointer to a RECT structure that receives the client coordinates. The left and top members are zero. The right and bottom members contain the width and height of the window.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero.To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:PInvoke.User32.GetForegroundWindow">
            <summary>
            Retrieves a handle to the foreground window (the window with which the user is currently
            working). The system assigns a slightly higher priority to the thread that creates the
            foreground window than it does to other threads.
            <para>
            See https://msdn.microsoft.com/en-us/library/windows/desktop/ms633505%28v=vs.85%29.aspx
            for more information.
            </para>
            </summary>
            <returns>
            C++ ( Type: Type: HWND ) <br/> The return value is a handle to the foreground window. The
            foreground window can be NULL in certain circumstances, such as when a window is losing activation.
            </returns>
        </member>
        <member name="M:PInvoke.User32.SetWindowPos(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,PInvoke.User32.SetWindowPosFlags)">
            <summary>
            Changes the size, position, and Z order of a child, pop-up, or top-level window. These
            windows are ordered according to their appearance on the screen. The topmost window
            receives the highest rank and is the first window in the Z order.
            <para>
            See https://msdn.microsoft.com/en-us/library/windows/desktop/ms633545%28v=vs.85%29.aspx
            for more information.
            </para>
            </summary>
            <param name="hWnd">C++ ( hWnd Type: HWND ) <br/> A handle to the window.</param>
            <param name="hWndInsertAfter">
            C++ ( hWndInsertAfter Type: HWND ) <br/> A handle to the window to
            precede the positioned window in the Z order. This parameter must be a window handle or
            one of the following values.
            <list type="table">
            <itemheader>
            <term>HWND placement</term>
            <description>Window to precede placement</description>
            </itemheader>
            <item>
            <term>HWND_BOTTOM ((HWND)1)</term>
            <description>
            Places the window at the bottom of the Z order. If the hWnd parameter identifies a
            topmost window, the window loses its topmost status and is placed at the bottom of all
            other windows.
            </description>
            </item>
            <item>
            <term>HWND_NOTOPMOST ((HWND)-2)</term>
            <description>
            Places the window above all non-topmost windows (that is, behind all topmost windows).
            This flag has no effect if the window is already a non-topmost window.
            </description>
            </item>
            <item>
            <term>HWND_TOP ((HWND)0)</term>
            <description>Places the window at the top of the Z order.</description>
            </item>
            <item>
            <term>HWND_TOPMOST ((HWND)-1)</term>
            <description>
            Places the window above all non-topmost windows. The window maintains its topmost
            position even when it is deactivated.
            </description>
            </item>
            </list>
            <para>
            For more information about how this parameter is used, see the following Remarks section.
            </para>
            </param>
            <param name="X">
            C++ ( X Type: int ) <br/> The new position of the left side of the window, in
            client coordinates.
            </param>
            <param name="Y">
            C++ ( Y Type: int ) <br/> The new position of the top of the window, in client coordinates.
            </param>
            <param name="cx">C++ ( cx Type: int ) <br/> The new width of the window, in pixels.</param>
            <param name="cy">
            C++ ( cy Type: int ) <br/> The new height of the window, in pixels.
            </param>
            <param name="uFlags">
            C++ ( uFlags Type: UINT ) <br/> The window sizing and positioning flags. This
            parameter can be a combination of the following values.
            <list type="table">
            <itemheader>
            <term>HWND sizing and positioning flags</term>
            <description>Where to place and size window. Can be a combination of any</description>
            </itemheader>
            <item>
            <term>SWP_ASYNCWINDOWPOS (0x4000)</term>
            <description>
            If the calling thread and the thread that owns the window are attached to different input
            queues, the system posts the request to the thread that owns the window. This prevents
            the calling thread from blocking its execution while other threads process the request.
            </description>
            </item>
            <item>
            <term>SWP_DEFERERASE (0x2000)</term>
            <description>Prevents generation of the WM_SYNCPAINT message.</description>
            </item>
            <item>
            <term>SWP_DRAWFRAME (0x0020)</term>
            <description>
            Draws a frame (defined in the window's class description) around the window.
            </description>
            </item>
            <item>
            <term>SWP_FRAMECHANGED (0x0020)</term>
            <description>
            Applies new frame styles set using the SetWindowLong function. Sends a WM_NCCALCSIZE
            message to the window, even if the window's size is not being changed. If this flag is
            not specified, WM_NCCALCSIZE is sent only when the window's size is being changed
            </description>
            </item>
            <item>
            <term>SWP_HIDEWINDOW (0x0080)</term>
            <description>Hides the window.</description>
            </item>
            <item>
            <term>SWP_NOACTIVATE (0x0010)</term>
            <description>
            Does not activate the window. If this flag is not set, the window is activated and moved
            to the top of either the topmost or non-topmost group (depending on the setting of the
            hWndInsertAfter parameter).
            </description>
            </item>
            <item>
            <term>SWP_NOCOPYBITS (0x0100)</term>
            <description>
            Discards the entire contents of the client area. If this flag is not specified, the valid
            contents of the client area are saved and copied back into the client area after the
            window is sized or repositioned.
            </description>
            </item>
            <item>
            <term>SWP_NOMOVE (0x0002)</term>
            <description>Retains the current position (ignores X and Y parameters).</description>
            </item>
            <item>
            <term>SWP_NOOWNERZORDER (0x0200)</term>
            <description>Does not change the owner window's position in the Z order.</description>
            </item>
            <item>
            <term>SWP_NOREDRAW (0x0008)</term>
            <description>
            Does not redraw changes. If this flag is set, no repainting of any kind occurs. This
            applies to the client area, the nonclient area (including the title bar and scroll bars),
            and any part of the parent window uncovered as a result of the window being moved. When
            this flag is set, the application must explicitly invalidate or redraw any parts of the
            window and parent window that need redrawing.
            </description>
            </item>
            <item>
            <term>SWP_NOREPOSITION (0x0200)</term>
            <description>Same as the SWP_NOOWNERZORDER flag.</description>
            </item>
            <item>
            <term>SWP_NOSENDCHANGING (0x0400)</term>
            <description>Prevents the window from receiving the WM_WINDOWPOSCHANGING message.</description>
            </item>
            <item>
            <term>SWP_NOSIZE (0x0001)</term>
            <description>Retains the current size (ignores the cx and cy parameters).</description>
            </item>
            <item>
            <term>SWP_NOZORDER (0x0004)</term>
            <description>Retains the current Z order (ignores the hWndInsertAfter parameter).</description>
            </item>
            <item>
            <term>SWP_SHOWWINDOW (0x0040)</term>
            <description>Displays the window.</description>
            </item>
            </list>
            </param>
            <returns>
            <c>true</c> or nonzero if the function succeeds, <c>false</c> or zero otherwise or if
            function fails.
            </returns>
            <remarks>
            <para>
            As part of the Vista re-architecture, all services were moved off the interactive desktop
            into Session 0. hwnd and window manager operations are only effective inside a session
            and cross-session attempts to manipulate the hwnd will fail. For more information, see
            The Windows Vista Developer Story: Application Compatibility Cookbook.
            </para>
            <para>
            If you have changed certain window data using SetWindowLong, you must call SetWindowPos
            for the changes to take effect. Use the following combination for uFlags: SWP_NOMOVE |
            SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED.
            </para>
            <para>
            A window can be made a topmost window either by setting the hWndInsertAfter parameter to
            HWND_TOPMOST and ensuring that the SWP_NOZORDER flag is not set, or by setting a window's
            position in the Z order so that it is above any existing topmost windows. When a
            non-topmost window is made topmost, its owned windows are also made topmost. Its owners,
            however, are not changed.
            </para>
            <para>
            If neither the SWP_NOACTIVATE nor SWP_NOZORDER flag is specified (that is, when the
            application requests that a window be simultaneously activated and its position in the Z
            order changed), the value specified in hWndInsertAfter is used only in the following circumstances.
            </para>
            <list type="bullet">
            <item>Neither the HWND_TOPMOST nor HWND_NOTOPMOST flag is specified in hWndInsertAfter.</item>
            <item>The window identified by hWnd is not the active window.</item>
            </list>
            <para>
            An application cannot activate an inactive window without also bringing it to the top of
            the Z order. Applications can change an activated window's position in the Z order
            without restrictions, or it can activate a window and then move it to the top of the
            topmost or non-topmost windows.
            </para>
            <para>
            If a topmost window is repositioned to the bottom (HWND_BOTTOM) of the Z order or after
            any non-topmost window, it is no longer topmost. When a topmost window is made
            non-topmost, its owners and its owned windows are also made non-topmost windows.
            </para>
            <para>
            A non-topmost window can own a topmost window, but the reverse cannot occur. Any window
            (for example, a dialog box) owned by a topmost window is itself made a topmost window, to
            ensure that all owned windows stay above their owner.
            </para>
            <para>
            If an application is not in the foreground, and should be in the foreground, it must call
            the SetForegroundWindow function.
            </para>
            <para>
            To use SetWindowPos to bring a window to the top, the process that owns the window must
            have SetForegroundWindow permission.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.ReleaseDC(System.IntPtr,System.IntPtr)">
            <summary>
            The ReleaseDC function releases a device context (DC), freeing it for use by other applications. The effect of the ReleaseDC function depends on the type of DC. It frees only common and window DCs. It has no effect on class or private DCs.
            </summary>
            <param name="hWnd">A handle to the window whose DC is to be released.</param>
            <param name="hDC">A handle to the DC to be released.</param>
            <returns>
            The return value indicates whether the DC was released. If the DC was released, the return value is 1.
            If the DC was not released, the return value is zero.
            </returns>
        </member>
        <member name="M:PInvoke.User32.FindWindow(System.String,System.String)">
            <summary>
            Retrieves a handle to the top-level window whose class name and window name match the specified strings. This function does not search child windows. This function does not perform a case-sensitive search. To search child windows, beginning with a specified child window, use the FindWindowEx function.
            </summary>
            <param name="lpClassName">The window class name. If lpClassName is NULL, it finds any window whose title matches the lpWindowName parameter. </param>
            <param name="lpWindowName">The window name (the window's title). If this parameter is NULL, all window names match.</param>
            <returns>If the function succeeds, the return value is a handle to the window that has the specified
             class name and window name. If the function fails, the return value is NULL.</returns>
        </member>
        <member name="M:PInvoke.User32.ShowWindow(System.IntPtr,PInvoke.User32.WindowShowStyle)">
            <summary>
            Shows a Window
            </summary>
            <remarks>
            <para>To perform certain special effects when showing or hiding a window, use AnimateWindow.</para>
            <para>
            The first time an application calls ShowWindow, it should use the WinMain function's
            nCmdShow parameter as its nCmdShow parameter. Subsequent calls to ShowWindow must use one
            of the values in the given list, instead of the one specified by the WinMain function's
            nCmdShow parameter.
            </para>
            <para>
            As noted in the discussion of the nCmdShow parameter, the nCmdShow value is ignored in
            the first call to ShowWindow if the program that launched the application specifies
            startup information in the structure. In this case, ShowWindow uses the information
            specified in the STARTUPINFO structure to show the window. On subsequent calls, the
            application must call ShowWindow with nCmdShow set to SW_SHOWDEFAULT to use the startup
            information provided by the program that launched the application. This behavior is
            designed for the following situations:
            </para>
            <list type="">
            <item>
            Applications create their main window by calling CreateWindow with the WS_VISIBLE flag set.
            </item>
            <item>
            Applications create their main window by calling CreateWindow with the WS_VISIBLE flag
            cleared, and later call ShowWindow with the SW_SHOW flag set to make it visible.
            </item>
            </list>
            </remarks>
            <param name="hWnd">Handle to the window.</param>
            <param name="nCmdShow">
            Specifies how the window is to be shown. This parameter is ignored the first time an
            application calls ShowWindow, if the program that launched the application provides a
            STARTUPINFO structure. Otherwise, the first time ShowWindow is called, the value should
            be the value obtained by the WinMain function in its nCmdShow parameter. In subsequent
            calls, this parameter can be one of the WindowShowStyle members.
            </param>
            <returns>
            If the window was previously visible, the return value is nonzero. If the window was
            previously hidden, the return value is zero.
            </returns>
        </member>
        <member name="M:PInvoke.User32.GetDesktopWindow">
            <summary>
            Retrieves a handle to the desktop window. The desktop window covers the entire screen. The desktop window is the area on top of which other windows are painted.
            </summary>
            <returns>The return value is a handle to the desktop window.</returns>
        </member>
        <member name="M:PInvoke.User32.GetShellWindow">
            <summary>
            Retrieves a handle to the Shell's desktop window.
            </summary>
            <returns>The return value is the handle of the Shell's desktop window. If no Shell process is present, the return value is NULL.</returns>
        </member>
        <member name="M:PInvoke.User32.SendMessage(System.IntPtr,PInvoke.User32.WindowMessage,System.Void*,System.Void*)">
            <summary>
            Sends the specified message to a window or windows. The SendMessage function calls the window procedure for the specified window and does not return until the window procedure has processed the message.
            To send a message and return immediately, use the SendMessageCallback or SendNotifyMessage function. To post a message to a thread's message queue and return immediately, use the PostMessage or PostThreadMessage function.
            </summary>
            <param name="hWnd">
            A handle to the window whose window procedure will receive the message. If this parameter is HWND_BROADCAST ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows.
            Message sending is subject to UIPI. The thread of a process can send messages only to message queues of threads in processes of lesser or equal integrity level.
            </param>
            <param name="wMsg">
            The message to be sent.
            For lists of the system-provided messages, see <see cref="T:PInvoke.User32.WindowMessage"/>.
            </param>
            <param name="wParam">Additional message-specific information.</param>
            <param name="lParam">Additional message-specific information.</param>
            <returns>The return value specifies the result of the message processing; it depends on the message sent.</returns>
        </member>
        <member name="M:PInvoke.User32.PostMessage(System.IntPtr,PInvoke.User32.WindowMessage,System.Void*,System.Void*)">
            <summary>
            Places (posts) a message in the message queue associated with the thread that created the specified window and returns without waiting for the thread to process the message.
            To post a message in the message queue associated with a thread, use the PostThreadMessage function.
            </summary>
            <param name="hWnd">
            A handle to the window whose window procedure is to receive the message.
            </param>
            <param name="wMsg">
            The message to be posted.
            For lists of the system-provided messages, see <see cref="T:PInvoke.User32.WindowMessage"/>.
            </param>
            <param name="wParam">Additional message-specific information.</param>
            <param name="lParam">Additional message-specific information.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call GetLastError. GetLastError returns ERROR_NOT_ENOUGH_QUOTA when the limit is hit.
            </returns>
        </member>
        <member name="M:PInvoke.User32.SendMessageTimeout(System.IntPtr,PInvoke.User32.WindowMessage,System.IntPtr,System.IntPtr,PInvoke.User32.SendMessageTimeoutFlags,System.Int32,System.IntPtr@)">
            <summary>
            Sends the specified message to one or more windows.
            </summary>
            <param name="hWnd">
            A handle to the window whose window procedure will receive the message.
            If this parameter is HWND_BROADCAST ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows.
            The function does not return until each window has timed out.
            Therefore, the total wait time can be up to the value of uTimeout multiplied by the number of top-level windows.
            </param>
            <param name="msg">
            The message to be sent.
            For lists of the system-provided messages, see <see cref="T:PInvoke.User32.WindowMessage"/>.
            </param>
            <param name="wParam">Any additional message-specific information.</param>
            <param name="lParam">Any additional message-specific information.</param>
            <param name="flags">The behavior of this function. This parameter can be one or more of the following values: <see cref="T:PInvoke.User32.SendMessageTimeoutFlags"/>. </param>
            <param name="timeout">The duration of the time-out period, in milliseconds.
            If the message is a broadcast message, each window can use the full time-out period.
            For example, if you specify a five second time-out period and there are three top-level windows that fail to process the message, you could have up to a 15 second delay.
            </param>
            <param name="pdwResult">The result of the message processing. The value of this parameter depends on the message that is specified.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            SendMessageTimeout does not provide information about individual windows timing out if HWND_BROADCAST is used.
            If the function fails or times out, the return value is 0.
            To get extended error information, call GetLastError.
            If GetLastError returns ERROR_TIMEOUT, then the function timed out.
            </returns>
        </member>
        <member name="M:PInvoke.User32.SetForegroundWindow(System.IntPtr)">
            <summary>
                Brings the thread that created the specified window into the foreground and activates the window. Keyboard
                input is directed to the window, and various visual cues are changed for the user. The system assigns a slightly
                higher priority to the thread that created the foreground window than it does to other threads.
            </summary>
            <param name="hWnd">A handle to the window that should be activated and brought to the foreground.</param>
            <returns>
                If the window was brought to the foreground, the return value is true.
                <para>If the window was not brought to the foreground, the return value is false.</para>
            </returns>
        </member>
        <member name="M:PInvoke.User32.GetAncestor(System.IntPtr,PInvoke.User32.GetAncestorFlags)">
            <summary>Retrieves the handle to the ancestor of the specified window.</summary>
            <param name="hWnd">
                A handle to the window whose ancestor is to be retrieved. If this parameter is the desktop window,
                the function returns <see cref="F:System.IntPtr.Zero" />.
            </param>
            <param name="gaFlags">The ancestor to be retrieved.</param>
            <returns>The handle to the ancestor window.</returns>
        </member>
        <member name="M:PInvoke.User32.SetWindowsHookEx(PInvoke.User32.WindowsHookType,PInvoke.User32.WindowsHookDelegate,System.IntPtr,System.Int32)">
            <summary>
                Installs an application-defined hook procedure into a hook chain. You would install a hook procedure to
                monitor the system for certain types of events. These events are associated either with a specific thread or with
                all threads in the same desktop as the calling thread.
            </summary>
            <param name="idHook">The type of hook procedure to be installed.</param>
            <param name="lpfn">
                A pointer to the hook procedure. If the <paramref name="dwThreadId" /> parameter is zero or
                specifies the identifier of a thread created by a different process, the <paramref name="lpfn" /> parameter must
                point to a hook procedure in a DLL. Otherwise, <paramref name="lpfn" /> can point to a hook procedure in the code
                associated with the current process.
            </param>
            <param name="hMod">
                A handle to the DLL containing the hook procedure pointed to by the <paramref name="lpfn" />
                parameter. The <paramref name="hMod" /> parameter must be set to <see cref="F:System.IntPtr.Zero" /> if the
                <paramref name="dwThreadId" /> parameter specifies a thread created by the current process and if the hook
                procedure is within the code associated with the current process.
            </param>
            <param name="dwThreadId">
                The identifier of the thread with which the hook procedure is to be associated. For desktop
                apps, if this parameter is zero, the hook procedure is associated with all existing threads running in the same
                desktop as the calling thread. For Windows Store apps, see the Remarks section.
            </param>
            <returns>
                If the function succeeds, the return value is the handle to the hook procedure.
                <para>
                    If the function fails, the return value is an invalid handle. To get extended error information,
                    call GetLastError.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.User32.SetWindowsHookEx(PInvoke.User32.WindowsHookType,System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
                Installs an application-defined hook procedure into a hook chain. You would install a hook procedure to
                monitor the system for certain types of events. These events are associated either with a specific thread or with
                all threads in the same desktop as the calling thread.
            </summary>
            <param name="idHook">The type of hook procedure to be installed.</param>
            <param name="lpfn">
                A pointer to the hook procedure. If the <paramref name="dwThreadId" /> parameter is zero or
                specifies the identifier of a thread created by a different process, the <paramref name="lpfn" /> parameter must
                point to a hook procedure in a DLL. Otherwise, <paramref name="lpfn" /> can point to a hook procedure in the code
                associated with the current process.
            </param>
            <param name="hMod">
                A handle to the DLL containing the hook procedure pointed to by the <paramref name="lpfn" />
                parameter. The <paramref name="hMod" /> parameter must be set to <see cref="F:System.IntPtr.Zero" /> if the
                <paramref name="dwThreadId" /> parameter specifies a thread created by the current process and if the hook
                procedure is within the code associated with the current process.
            </param>
            <param name="dwThreadId">
                The identifier of the thread with which the hook procedure is to be associated. For desktop
                apps, if this parameter is zero, the hook procedure is associated with all existing threads running in the same
                desktop as the calling thread. For Windows Store apps, see the Remarks section.
            </param>
            <returns>
                If the function succeeds, the return value is the handle to the hook procedure.
                <para>
                    If the function fails, the return value is an invalid handle. To get extended error information,
                    call GetLastError.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.User32.SetWinEventHook(PInvoke.User32.WindowsEventHookType,PInvoke.User32.WindowsEventHookType,System.IntPtr,System.IntPtr,System.Int32,System.Int32,PInvoke.User32.WindowsEventHookFlags)">
            <summary>
            Sets an event hook function for a range of events.
            </summary>
            <param name="eventMin">Specifies the event constant for the lowest event value in the range of events that are handled by
            the hook function. This parameter can be set to EVENT_MIN to indicate the lowest possible event value.</param>
            <param name="eventMax">Specifies the event constant for the highest event value in the range of events that are handled by
            the hook function. This parameter can be set to EVENT_MAX to indicate the highest possible event value.</param>
            <param name="hmodWinEventProc">Handle to the DLL that contains the hook function at lpfnWinEventProc, if the WINEVENT_INCONTEXT
            flag is specified in the dwFlags parameter. If the hook function is not located in a DLL, or if the WINEVENT_OUTOFCONTEXT flag
            is specified, this parameter is NULL.</param>
            <param name="lpfnWinEventProc">Pointer to the event hook function. For more information about this function, see WinEventProc.</param>
            <param name="idProcess">Specifies the ID of the process from which the hook function receives events. Specify zero (0) to
            receive events from all processes on the current desktop.</param>
            <param name="idThread">Specifies the ID of the thread from which the hook function receives events. If this parameter is zero,
            the hook function is associated with all existing threads on the current desktop.</param>
            <param name="dwflags">Flag values that specify the location of the hook function and of the events to be skipped. </param>
            <returns>If successful, returns an <see cref="T:PInvoke.User32.SafeEventHookHandle"/> value that identifies this event hook instance.</returns>
        </member>
        <member name="M:PInvoke.User32.SetWinEventHook(PInvoke.User32.WindowsEventHookType,PInvoke.User32.WindowsEventHookType,System.IntPtr,PInvoke.User32.WinEventProc,System.Int32,System.Int32,PInvoke.User32.WindowsEventHookFlags)">
            <summary>
            Sets an event hook function for a range of events.
            </summary>
            <param name="eventMin">Specifies the event constant for the lowest event value in the range of events that are handled by
            the hook function. This parameter can be set to EVENT_MIN to indicate the lowest possible event value.</param>
            <param name="eventMax">Specifies the event constant for the highest event value in the range of events that are handled by
            the hook function. This parameter can be set to EVENT_MAX to indicate the highest possible event value.</param>
            <param name="hmodWinEventProc">Handle to the DLL that contains the hook function at lpfnWinEventProc, if the WINEVENT_INCONTEXT
            flag is specified in the dwFlags parameter. If the hook function is not located in a DLL, or if the WINEVENT_OUTOFCONTEXT flag
            is specified, this parameter is NULL.</param>
            <param name="lpfnWinEventProc">Pointer to the event hook function. For more information about this function, see WinEventProc.</param>
            <param name="idProcess">Specifies the ID of the process from which the hook function receives events. Specify zero (0) to
            receive events from all processes on the current desktop.</param>
            <param name="idThread">Specifies the ID of the thread from which the hook function receives events. If this parameter is zero,
            the hook function is associated with all existing threads on the current desktop.</param>
            <param name="dwflags">Flag values that specify the location of the hook function and of the events to be skipped. </param>
            <returns>If successful, returns an <see cref="T:PInvoke.User32.SafeEventHookHandle"/> value that identifies this event hook instance.</returns>
        </member>
        <member name="M:PInvoke.User32.CallNextHookEx(System.IntPtr,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
                Passes the hook information to the next hook procedure in the current hook chain. A hook procedure can call
                this function either before or after processing the hook information.
            </summary>
            <param name="hhk">This parameter is ignored.</param>
            <param name="nCode">
                The hook code passed to the current hook procedure. The next hook procedure uses this code to
                determine how to process the hook information.
            </param>
            <param name="wParam">
                The wParam value passed to the current hook procedure. The meaning of this parameter depends on
                the type of hook associated with the current hook chain.
            </param>
            <param name="lParam">
                The lParam value passed to the current hook procedure. The meaning of this parameter depends on
                the type of hook associated with the current hook chain.
            </param>
            <returns>
                This value is returned by the next hook procedure in the chain. The current hook procedure must also return
                this value. The meaning of the return value depends on the hook type. For more information, see the descriptions of
                the individual hook procedures.
            </returns>
        </member>
        <member name="M:PInvoke.User32.SetCapture(System.IntPtr)">
            <summary>
                Sets the mouse capture to the specified window belonging to the current thread.SetCapture captures mouse input
                either when the mouse is over the capturing window, or when the mouse button was pressed while the mouse was over
                the capturing window and the button is still down. Only one window at a time can capture the mouse.
                <para>
                    If the mouse cursor is over a window created by another thread, the system will direct mouse input to the
                    specified window only if a mouse button is down.
                </para>
            </summary>
            <param name="hWnd">A handle to the window in the current thread that is to capture the mouse.</param>
            <returns>
                The return value is a handle to the window that had previously captured the mouse. If there is no such window,
                the return value is <see cref="F:System.IntPtr.Zero" />.
            </returns>
        </member>
        <member name="M:PInvoke.User32.ReleaseCapture">
            <summary>
                Releases the mouse capture from a window in the current thread and restores normal mouse input processing. A
                window that has captured the mouse receives all mouse input, regardless of the position of the cursor, except when
                a mouse button is clicked while the cursor hot spot is in the window of another thread.
            </summary>
            <returns>
                If the function succeeds, the return value is true.
                <para>If the function fails, the return value is false. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:PInvoke.User32.FlashWindowEx(PInvoke.User32.FLASHWINFO@)">
            <summary>Flashes the specified window. It does not change the active state of the window.</summary>
            <param name="pwfi">A pointer to a <see cref="T:PInvoke.User32.FLASHWINFO" /> structure.</param>
            <returns>
                The return value specifies the window's state before the call to the FlashWindowEx function. If the window
                caption was drawn as active before the call, the return value is nonzero. Otherwise, the return value is zero.
            </returns>
        </member>
        <member name="M:PInvoke.User32.GetSystemMenu(System.IntPtr,System.Boolean)">
            <summary>
                Enables the application to access the window menu (also known as the system menu or the control menu) for
                copying and modifying.
            </summary>
            <param name="hWnd">A handle to the window that will own a copy of the window menu.</param>
            <param name="bRevert">
                The action to be taken. If this parameter is FALSE, GetSystemMenu returns a handle to the copy of
                the window menu currently in use. The copy is initially identical to the window menu, but it can be modified. If
                this parameter is TRUE, GetSystemMenu resets the window menu back to the default state. The previous window menu,
                if any, is destroyed.
            </param>
            <returns>
                If the bRevert parameter is FALSE, the return value is a handle to a copy of the window menu. If the bRevert
                parameter is TRUE, the return value is NULL.
            </returns>
        </member>
        <member name="M:PInvoke.User32.LoadCursor(System.IntPtr,System.Char*)">
            <summary>
            Loads the specified cursor resource from the executable (.EXE) file associated with an application instance.
            </summary>
            <param name="hInstance">A handle to an instance of the module whose executable file contains the cursor to be loaded.</param>
            <param name="lpCursorName">
            The name of the cursor resource to be loaded. Alternatively, this parameter can consist of the resource identifier in the low-order word and zero in the high-order word.
            The <see cref="M:PInvoke.Kernel32.MAKEINTRESOURCE(System.Int32)"/> macro can also be used to create this value. To use one of the predefined cursors, the application must set the hInstance parameter to NULL and the lpCursorName parameter to one the values defined by <see cref="T:PInvoke.User32.Cursors" />.
            </param>
            <returns>
            If the function succeeds, the return value is the handle to the newly loaded cursor.
            If the function fails, the return value is NULL. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError" />.
            </returns>
            <remarks>
            Note: This function has been superseded by the LoadImage function.
            </remarks>
        </member>
        <member name="M:PInvoke.User32.GetCursor">
            <summary>
            Retrieves a handle to the current cursor.
            To get information on the global cursor, even if it is not owned by the current thread, use <see cref="M:PInvoke.User32.GetCursorInfo(PInvoke.User32.CURSORINFO*)" />.
            </summary>
            <returns>The return value is the handle to the current cursor. If there is no cursor, the return value is null.</returns>
        </member>
        <member name="M:PInvoke.User32.CreateCursor(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte*,System.Byte*)">
            <summary>
            Creates a cursor having the specified size, bit patterns, and hot spot.
            </summary>
            <param name="hInst">A handle to the current instance of the application creating the cursor.</param>
            <param name="xHotspot">The horizontal position of the cursor's hot spot.</param>
            <param name="yHotSpot">The vertical position of the cursor's hot spot.</param>
            <param name="nWidth">The width of the cursor, in pixels.</param>
            <param name="nHeight">The height of the cursor, in pixels.</param>
            <param name="pvANDPlane">An array of bytes that contains the bit values for the AND mask of the cursor, as in a device-dependent monochrome bitmap.</param>
            <param name="pvXORPlane">An array of bytes that contains the bit values for the XOR mask of the cursor, as in a device-dependent monochrome bitmap.</param>
            <returns>
            If the function succeeds, the return value is a handle to the cursor.
            If the function fails, the return value is NULL. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
            <remarks>
            <para>The <paramref name="nWidth"/> and <paramref name="nHeight"/> parameters must specify a width and height that are supported by the current display driver, because the system cannot create cursors of other sizes. To determine the width and height supported by the display driver, use the GetSystemMetrics function, specifying the SM_CXCURSOR or SM_CYCURSOR value.</para>
            <para>Before closing, an application must call the <see cref="M:PInvoke.User32.DestroyCursor(System.IntPtr)"/> function to free any system resources associated with the cursor.</para>
            <para>This API does not participate in DPI virtualization. The output returned is in terms of physical coordinates, and is not affected by the DPI of the calling thread. Note that the cursor created may still be scaled to match the DPI of any given window it is drawn into.</para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.SetCursor(PInvoke.User32.SafeCursorHandle)">
            <summary>
            Sets the cursor shape.
            </summary>
            <param name="hCursor">
            A handle to the cursor. The cursor must have been created by the <see cref="M:PInvoke.User32.CreateCursor(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte*,System.Byte*)" /> function or loaded by the <see cref="M:PInvoke.User32.LoadCursor(System.IntPtr,System.Char*)" /> or <see cref="M:PInvoke.User32.LoadImage(System.IntPtr,System.Char*,PInvoke.User32.ImageType,System.Int32,System.Int32,PInvoke.User32.LoadImageFlags)" /> function. If this parameter is NULL, the cursor is removed from the screen.
            </param>
            <returns>
            The return value is the handle to the previous cursor, if there was one.
            If there was no previous cursor, the return value is NULL.
            </returns>
            <remarks>
            <para>The cursor is set only if the new cursor is different from the previous cursor; otherwise, the function returns immediately.</para>
            <para>The cursor is a shared resource. A window should set the cursor shape only when the cursor is in its client area or when the window is capturing mouse input. In systems without a mouse, the window should restore the previous cursor before the cursor leaves the client area or before it relinquishes control to another window.</para>
            <para>If your application must set the cursor while it is in a window, make sure the class cursor for the specified window's class is set to NULL. If the class cursor is not NULL, the system restores the class cursor each time the mouse is moved.</para>
            <para>The cursor is not shown on the screen if the internal cursor display count is less than zero. This occurs if the application uses the <see cref="M:PInvoke.User32.ShowCursor(System.Boolean)" /> function to hide the cursor more times than to show the cursor.</para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.GetCursorInfo(PInvoke.User32.CURSORINFO*)">
            <summary>
            Retrieves information about the global cursor.
            </summary>
            <param name="pci">A pointer to a <see cref="T:PInvoke.User32.CURSORINFO" /> structure that receives the information. Note that you must set the <see cref="F:PInvoke.User32.CURSORINFO.cbSize" /> member to sizeof(CURSORINFO) before calling this function.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError" />.
            </returns>
        </member>
        <member name="M:PInvoke.User32.ShowCursor(System.Boolean)">
            <summary>
            Displays or hides the cursor.
            </summary>
            <param name="bShow">
            If bShow is TRUE, the display count is incremented by one. If bShow is FALSE, the display count is decremented by one.
            </param>
            <returns>The return value specifies the new display counter.</returns>
            <remarks>
            Windows 8: Call <see cref="M:PInvoke.User32.GetCursorInfo(PInvoke.User32.CURSORINFO*)"/> to determine the cursor visibility.
            This function sets an internal display counter that determines whether the cursor should be displayed. The cursor is displayed only if the display count is greater than or equal to 0. If a mouse is installed, the initial display count is 0. If no mouse is installed, the display count is -1.
            </remarks>
        </member>
        <member name="M:PInvoke.User32.LoadImage(System.IntPtr,System.Char*,PInvoke.User32.ImageType,System.Int32,System.Int32,PInvoke.User32.LoadImageFlags)">
            <summary>
            Loads an icon, cursor, animated cursor, or bitmap.
            </summary>
            <param name="hInst">
            A handle to the module of either a DLL or executable (.exe) that contains the image to be loaded. For more information, see <see cref="M:PInvoke.Kernel32.GetModuleHandle(System.String)"/>. Note that as of 32-bit Windows, an instance handle (HINSTANCE), such as the application instance handle exposed by system function call of WinMain, and a module handle (HMODULE) are the same thing.
            To load an OEM image, set this parameter to NULL.
            To load a stand-alone resource (icon, cursor, or bitmap file)—for example, c:\myimage.bmp—set this parameter to NULL.
            </param>
            <param name="name">
            The image to be loaded. If the hinst parameter is non-NULL and the fuLoad parameter omits LR_LOADFROMFILE, lpszName specifies the image resource in the hinst module. If the image resource is to be loaded by name from the module, the lpszName parameter is a pointer to a null-terminated string that contains the name of the image resource. If the image resource is to be loaded by ordinal from the module, use the MAKEINTRESOURCE macro to convert the image ordinal into a form that can be passed to the LoadImage function.
            For more information, see the <see href="https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-loadimagew">Microsoft documentation</see>.
            </param>
            <param name="type">The type of image to be loaded.</param>
            <param name="cx">The width, in pixels, of the icon or cursor. If this parameter is zero and the fuLoad parameter is LR_DEFAULTSIZE, the function uses the SM_CXICON or SM_CXCURSOR system metric value to set the width. If this parameter is zero and LR_DEFAULTSIZE is not used, the function uses the actual resource width.</param>
            <param name="cy">The height, in pixels, of the icon or cursor. If this parameter is zero and the fuLoad parameter is LR_DEFAULTSIZE, the function uses the SM_CYICON or SM_CYCURSOR system metric value to set the height. If this parameter is zero and LR_DEFAULTSIZE is not used, the function uses the actual resource height.</param>
            <param name="fuLoad">This parameter can be one or more of the values defined by the enum.</param>
            <returns>
            If the function succeeds, the return value is the handle of the newly loaded image.
            If the function fails, the return value is NULL. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.User32.AppendMenu(System.IntPtr,PInvoke.User32.MenuItemFlags,System.IntPtr,System.String)">
            <summary>
                Appends a new item to the end of the specified menu bar, drop-down menu, submenu, or shortcut menu. You can
                use this function to specify the content, appearance, and behavior of the menu item.
            </summary>
            <param name="hMenu">A handle to the menu bar, drop-down menu, submenu, or shortcut menu to be changed.</param>
            <param name="uFlags">Controls the appearance and behavior of the new menu item</param>
            <param name="uIdNewItem">
                The identifier of the new menu item or, if the uFlags parameter is set to
                <see cref="F:PInvoke.User32.MenuItemFlags.MF_POPUP" />, a handle to the drop-down menu or submenu.
            </param>
            <param name="lpNewItem">
                The content of the new menu item. The interpretation of lpNewItem depends on whether the uFlags parameter includes
                the following values.
                <para><see cref="F:PInvoke.User32.MenuItemFlags.MF_BITMAP" />: Contains a bitmap handle.</para>
                <para>
                    <see cref="F:PInvoke.User32.MenuItemFlags.MF_OWNERDRAW" />: Contains an application-supplied value that can be used to
                    maintain additional data related to the menu item. The value is in the itemData member of the structure pointed
                    to by the lParam parameter of the WM_MEASUREITEM or WM_DRAWITEM message sent when the menu is created or its
                    appearance is updated.
                </para>
                <para><see cref="F:PInvoke.User32.MenuItemFlags.MF_STRING" />: Contains a pointer to a null-terminated string.</para>
            </param>
            <returns>
                If the function succeeds, the return value is true.
                <para>If the function fails, the return value is false. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:PInvoke.User32.SetMenuItemInfo(System.IntPtr,System.UInt32,System.Boolean,PInvoke.User32.MENUITEMINFO@)">
            <summary>Changes information about a menu item.</summary>
            <param name="hMenu">A handle to the menu that contains the menu item.</param>
            <param name="uItem">
                The identifier or position of the menu item to change. The meaning of this parameter depends on the
                value of <paramref name="fByPosition" />.
            </param>
            <param name="fByPosition">
                The meaning of uItem. If this parameter is FALSE, uItem is a menu item identifier. Otherwise,
                it is a menu item position.
            </param>
            <param name="lpmii">
                A <see cref="T:PInvoke.User32.MENUITEMINFO" /> structure that contains information about the menu item and specifies
                which menu item attributes to change.
            </param>
            <returns>
                If the function succeeds, the return value is true.
                <para>If the function fails, the return value is false. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:PInvoke.User32.GetMenuItemInfo(System.IntPtr,System.UInt32,System.Boolean,PInvoke.User32.MENUITEMINFO@)">
            <summary>Retrieves information about a menu item.</summary>
            <param name="hMenu">A handle to the menu that contains the menu item.</param>
            <param name="uItem">
                The identifier or position of the menu item to get information about. The meaning of this parameter
                depends on the value of <paramref name="fByPosition" />.
            </param>
            <param name="fByPosition">
                The meaning of <paramref name="uItem" />. If this parameter is FALSE,
                <paramref name="uItem" /> is a menu item identifier. Otherwise, it is a menu item position.
            </param>
            <param name="lpmii">
                A <see cref="T:PInvoke.User32.MENUITEMINFO" /> structure that specifies the information to retrieve and receives
                information about the menu item. Note that you must set the cbSize member to <code>sizeof(MENUITEMINFO)</code>
                before calling this function (Either manually or by using <see cref="M:PInvoke.User32.MENUITEMINFO.Create" />).
            </param>
            <returns>
                If the function succeeds, the return value is true.
                <para>If the function fails, the return value is false. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:PInvoke.User32.MapVirtualKey(System.Int32,PInvoke.User32.MapVirtualKeyTranslation)">
            <summary>
                Translates (maps) a virtual-key code into a scan code or character value, or translates a scan code into a
                virtual-key code.
                <para>
                    To specify a handle to the keyboard layout to use for translating the specified code, use the MapVirtualKeyEx
                    function.
                </para>
            </summary>
            <param name="uCode">
                The virtual key code or scan code for a key. How this value is interpreted depends on the value of
                the uMapType parameter.
            </param>
            <param name="uMapType">
                The translation to be performed. The value of this parameter depends on the value of the uCode
                parameter.
            </param>
            <returns>
                The return value is either a scan code, a virtual-key code, or a character value, depending on the value of
                <paramref name="uCode" /> and <paramref name="uMapType" />. If there is no translation, the return value is zero.
            </returns>
        </member>
        <member name="M:PInvoke.User32.GetActiveWindow">
            <summary>Retrieves the window handle to the active window attached to the calling thread's message queue.</summary>
            <returns>
                The return value is the handle to the active window attached to the calling thread's message queue. Otherwise,
                the return value is <see cref="F:System.IntPtr.Zero" />.
            </returns>
        </member>
        <member name="M:PInvoke.User32.IsWindow(System.IntPtr)">
            <summary>
            Determines whether the specified window handle identifies an existing window.
            </summary>
            <param name="hWnd">A handle to the window to be tested.</param>
            <returns>If the window handle identifies an existing window, the return value is true, otherwise it is false.</returns>
            <remarks>
            A thread should not use IsWindow for a window that it did not create because the window could be destroyed after this function was called.
            Further, because window handles are recycled the handle could even point to a different window.
            </remarks>
        </member>
        <member name="M:PInvoke.User32.IsGUIThread(System.Boolean)">
            <summary>
            Determines whether the calling thread is already a GUI thread. It can also optionally convert the thread to a GUI thread.
            </summary>
            <param name="bConvert">If TRUE and the thread is not a GUI thread, convert the thread to a GUI thread.</param>
            <returns>The function returns a nonzero value (different from <see cref="F:PInvoke.HResult.Code.S_OK"/> but not specified on MSDN documentation) in the following situations:
            <list>
            <item>If the calling thread is already a GUI thread.</item>
            <item>If <paramref name="bConvert"/> is TRUE and the function successfully converts the thread to a GUI thread.</item>
            </list>
            Otherwise, the function returns <see cref="F:PInvoke.HResult.Code.S_OK"/>.
            If <paramref name="bConvert"/> is TRUE and the function cannot successfully convert the thread to a GUI thread,
            IsGUIThread returns <see cref="F:PInvoke.Win32ErrorCode.ERROR_NOT_ENOUGH_MEMORY"/>.
            </returns>
        </member>
        <member name="M:PInvoke.User32.IsChild(System.IntPtr,System.IntPtr)">
            <summary>
            Determines whether a window is a child window or descendant window of a specified parent window.
            A child window is the direct descendant of a specified parent window if that parent window is in the chain of parent windows;
            the chain of parent windows leads from the original overlapped or pop-up window to the child window.
            </summary>
            <param name="hWndParent">A handle to the parent window.</param>
            <param name="hWnd">A handle to the window to be tested.</param>
            <returns>If the window is a child or descendant window of the specified parent window, the return value is true, otherwise it is false.</returns>
        </member>
        <member name="M:PInvoke.User32.IsHungAppWindow(System.IntPtr)">
            <summary>
            Determines whether the system considers that a specified application is not responding.
            An application is considered to be not responding if it is not waiting for input, is not in startup processing,
            and has not called <see cref="M:PInvoke.User32.PeekMessage(PInvoke.User32.MSG*,System.IntPtr,PInvoke.User32.WindowMessage,PInvoke.User32.WindowMessage,PInvoke.User32.PeekMessageRemoveFlags)"/> within the internal timeout period of 5 seconds.
            </summary>
            <param name="hWnd">A handle to the window to be tested.</param>
            <returns>
            If the window handle identifies an existing window, the return value is true, otherwise it is false.
            Ghost windows always return true.
            </returns>
            <remarks>
            The Windows timeout criteria of 5 seconds is subject to change.
            This function was not included in the SDK headers and libraries until Windows XP Service Pack 1 (SP1) and Windows Server 2003.
            If you do not have a header file and import library for this function, you can call the function using <see cref="M:PInvoke.Kernel32.LoadLibrary(System.String)"/> and <see cref="M:PInvoke.Kernel32.GetProcAddress(PInvoke.Kernel32.SafeLibraryHandle,System.String)"/>.
            </remarks>
        </member>
        <member name="M:PInvoke.User32.IsIconic(System.IntPtr)">
            <summary>
            Determines whether the specified window is minimized (iconic).
            </summary>
            <param name="hWnd">A handle to the window to be tested.</param>
            <returns>If the window is iconic, the return value is true, otherwise it is false.</returns>
        </member>
        <member name="M:PInvoke.User32.IsWindowUnicode(System.IntPtr)">
            <summary>
            Determines whether the specified window is a native Unicode window.
            </summary>
            <param name="hWnd">A handle to the window to be tested.</param>
            <returns>If the window is a native Unicode window, the return value is true, otherwise it is false (the window is a native ANSI window).</returns>
            <remarks>
            <para>
            The character set of a window is determined by the use of the <see cref="M:PInvoke.User32.RegisterClass(PInvoke.User32.WNDCLASS@)"/> function.
            If the window class was registered with the ANSI version of <see cref="M:PInvoke.User32.RegisterClass(PInvoke.User32.WNDCLASS@)"/> (RegisterClassA), the character set of the window is ANSI.
            If the window class was registered with the Unicode version of <see cref="M:PInvoke.User32.RegisterClass(PInvoke.User32.WNDCLASS@)"/> (RegisterClassW), the character set of the window is Unicode.
            </para>
            <para>
            The system does automatic two-way translation (Unicode to ANSI) for window messages. For example,
            if an ANSI window message is sent to a window that uses the Unicode character set,
            the system translates that message into a Unicode message before calling the window procedure.
            The system calls IsWindowUnicode to determine whether to translate the message or not.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.IsWindowVisible(System.IntPtr)">
            <summary>
            Determines the visibility state of the specified window.
            </summary>
            <param name="hWnd">A handle to the window to be tested.</param>
            <returns>
            If the specified window, its parent window, its parent's parent window, and so forth, have the WS_VISIBLE style, the return value is true, otherwise it is false.
            Because the return value specifies whether the window has the WS_VISIBLE style, it may be nonzero even if the window is totally obscured by other windows.
            </returns>
            <remarks>
            The visibility state of a window is indicated by the WS_VISIBLE style bit.
            When WS_VISIBLE is set, the window is displayed and subsequent drawing into it is displayed as long as the window has the WS_VISIBLE style.
            Any drawing to a window with the WS_VISIBLE style will not be displayed if the window is obscured by other windows or is clipped by its parent window.
            </remarks>
        </member>
        <member name="M:PInvoke.User32.IsZoomed(System.IntPtr)">
            <summary>
            Determines whether a window is maximized.
            </summary>
            <param name="hWnd">A handle to the window to be tested.</param>
            <returns>If the window is zoomed, the return value is true, otherwise it is false.</returns>
        </member>
        <member name="M:PInvoke.User32.LookupIconIdFromDirectory(System.Byte*,System.Boolean)">
            <summary>
            Searches through icon or cursor data for the icon or cursor that best fits the current display device.
            To specify a desired height or width, use the LookupIconIdFromDirectoryEx function.
            </summary>
            <param name="presbits">
            The icon or cursor directory data. Because this function does not validate the resource data, it causes a general protection (GP) fault or returns an undefined value if <paramref name="presbits"/> is not pointing to valid resource data.
            </param>
            <param name="fIcon">
            Indicates whether an icon or a cursor is sought. If this parameter is TRUE, the function is searching for an icon; if the parameter is FALSE, the function is searching for a cursor.
            </param>
            <returns>
            If the function succeeds, the return value is an integer resource identifier for the icon or cursor that best fits the current display device.
            If the function fails, the return value is zero. To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:PInvoke.User32.LookupIconIdFromDirectoryEx(System.Byte*,System.Boolean,System.Int32,System.Int32,PInvoke.User32.LookupIconIdFromDirectoryExFlags)">
            <summary>
            Searches through icon or cursor data for the icon or cursor that best fits the current display device.
            To specify a desired height or width, use the LookupIconIdFromDirectoryEx function.
            </summary>
            <param name="presbits">
            The icon or cursor directory data. Because this function does not validate the resource data, it causes a general protection (GP) fault or returns an undefined value if <paramref name="presbits"/> is not pointing to valid resource data.
            </param>
            <param name="fIcon">
            Indicates whether an icon or a cursor is sought. If this parameter is TRUE, the function is searching for an icon; if the parameter is FALSE, the function is searching for a cursor.
            </param>
            <param name="cxDesired">The desired width, in pixels, of the icon. If this parameter is zero, the function uses the SM_CXICON or SM_CXCURSOR system metric value.</param>
            <param name="cyDesired">The desired height, in pixels, of the icon. If this parameter is zero, the function uses the SM_CYICON or SM_CYCURSOR system metric value.</param>
            <param name="Flags">A combination of the following values.</param>
            <returns>
            If the function succeeds, the return value is an integer resource identifier for the icon or cursor that best fits the current display device.
            If the function fails, the return value is zero. To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:PInvoke.User32.GetClipboardFormatName(System.Int32,System.Char*,System.Int32)">
            <summary>
            Retrieves the name of the format from the clipboard.
            </summary>
            <param name="format">The type of format to be retrieved. This parameter must not specify any of the predefined clipboard formats.</param>
            <param name="lpszFormatName">The format name string.</param>
            <param name="cchMaxCount">
            The length of the <paramref name="lpszFormatName"/> buffer, in characters. The buffer must be large enough to include the terminating null character; otherwise, the format name string is truncated to <paramref name="cchMaxCount"/>-1 characters.
            </param>
            <returns>
            If the function succeeds, the return value is the number of characters copied to the buffer.
            If the function fails, the return value is zero. To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:PInvoke.User32.SendInput(System.Int32,PInvoke.User32.INPUT*,System.Int32)">
            <summary>
            Synthesizes keystrokes, mouse motions, and button clicks.
            </summary>
            <param name="nInputs">The number of structures in the <paramref name="pInputs" /> array.</param>
            <param name="pInputs">An array of  structures. Each structure represents an event to be inserted into the keyboard or mouse input stream.</param>
            <param name="cbSize">The size, in bytes, of an <see cref="T:PInvoke.User32.INPUT" /> structure. If cbSize is not the size of an <see cref="T:PInvoke.User32.INPUT" /> structure, the function fails.</param>
            <returns>
            The function returns the number of events that it successfully inserted into the keyboard or mouse input stream.
            If the function returns zero, the input was already blocked by another thread. To get extended error information, call GetLastError.
            </returns>
            <remarks>
            This function is subject to UIPI. Applications are permitted to inject input only into applications that are at an equal or lesser integrity level.
            This function fails when it is blocked by UIPI. Note that neither GetLastError nor the return value will indicate the failure was caused by UIPI blocking.
            </remarks>
        </member>
        <member name="M:PInvoke.User32.WaitForInputIdle(System.IntPtr,System.Int32)">
            <summary>
            Waits until the specified process has finished processing its initial input and is waiting for user input with no input pending, or until the time-out interval has elapsed.
            </summary>
            <param name="hProcess">A handle to the process. If this process is a console application or does not have a message queue, WaitForInputIdle returns immediately.</param>
            <param name="dwMilliseconds">The time-out interval, in milliseconds. If dwMilliseconds is INFINITE, the function does not return until the process is idle.</param>
            <returns>0 if the wait was satisfied successfully., WAIT_TIMEOUT if the wait was terminated because the time-out interval elapsed, and WAIT_FAILED if an error occurred.</returns>
            <remarks>Raymond Chen has a series of articles that give a bit more depth to how this function was intended to be used.
            <a href="http://blogs.msdn.com/b/oldnewthing/archive/2010/03/25/9984720.aspx">Here</a> and <a href="http://blogs.msdn.com/b/oldnewthing/archive/2010/03/26/9985422.aspx">here</a>.
            The jist of it is that this function should have been really called WaitForProcessStartupComplete, as this is all it does.</remarks>
        </member>
        <member name="M:PInvoke.User32.GetAsyncKeyState(System.Int32)">
            <summary>
            Determines whether a key is up or down at the time the function is called, and whether the key was pressed after a previous call to GetAsyncKeyState.
            </summary>
            <param name="vKey">
            The virtual-key code from the <see cref="T:PInvoke.User32.VirtualKey" /> enum.
            You can use left- and right-distinguishing constants to specify certain keys.
            </param>
            <returns>
            If the function succeeds, the return value specifies whether the key was pressed since the last call to GetAsyncKeyState, and whether the key is currently up or down. If the most significant bit is set, the key is down, and if the least significant bit is set, the key was pressed after /// the previous call to GetAsyncKeyState. However, you should not rely on this last behavior; for more information, see the Remarks on MSDN.
            </returns>
        </member>
        <member name="M:PInvoke.User32.GetKeyState(System.Int32)">
            <summary>
            Retrieves the status of the specified virtual key. The status specifies whether the key is up, down, or toggled (on, off—alternating each time the key is pressed).
            </summary>
            <param name="nVirtKey">
            A virtual key code from the <see cref="T:PInvoke.User32.VirtualKey" /> enum. If the desired virtual key is a letter or digit (A through Z, a through z, or 0 through 9), nVirtKey must be set to the ASCII value of that character. For other keys, it must be a virtual-key code.
            If a non-English keyboard layout is used, virtual keys with values in the range ASCII A through Z and 0 through 9 are used to specify most of the character keys. For example, for the German keyboard layout,
            the virtual key of value ASCII O (0x4F) refers to the "o" key, whereas VK_OEM_1 refers to the "o with umlaut" key.
            </param>
            <returns>
            The return value specifies the status of the specified virtual key, as follows:
            If the high-order bit is 1, the key is down; otherwise, it is up.
            If the low-order bit is 1, the key is toggled. A key, such as the CAPS LOCK key, is toggled if it is turned on. The key is off and untoggled if the low-order bit is 0. A toggle key's indicator light (if any) on the keyboard will be on when the key is toggled,
            and off when the key is untoggled.
            </returns>
        </member>
        <member name="M:PInvoke.User32.PhysicalToLogicalPointForPerMonitorDPI(System.IntPtr,PInvoke.POINT@)">
            <summary>
            <para>
            Converts a point in a window from logical coordinates into physical coordinates, regardless of the dots per inch (dpi) awareness of the caller.
            For more information about DPI awareness levels, see <see cref="T:PInvoke.PROCESS_DPI_AWARENESS"/>
            </para>
            <para>
            Tip: Since an application with a value of <see cref="F:PInvoke.PROCESS_DPI_AWARENESS.PROCESS_PER_MONITOR_DPI_AWARE"/> uses the actual DPI of the monitor,
            physical and logical coordinates are the same for this app.
            </para>
            </summary>
            <param name="hwnd">A handle to the window whose transform is used for the conversion</param>
            <param name="lpPoint">
            A pointer to a <see cref="T:PInvoke.POINT"/> structure that specifies the physical/screen coordinates to be converted.
            The new logical coordinates are copied into this structure if the function succeeds
            </param>
            <returns>Returns TRUE if successful, or FALSE otherwise</returns>
            <remarks>
            <para>
            In Windows 8, system–DPI aware applications translated between physical and logical space using
            <see cref="M:PInvoke.User32.PhysicalToLogicalPoint(System.IntPtr,PInvoke.POINT@)"/> and <see cref="M:PInvoke.User32.LogicalToPhysicalPoint(System.IntPtr,PInvoke.POINT@)"/>.
            In Windows 8.1, the additional virtualization of the system and inter-process communications means that for the majority of applications, you do not need these APIs.
            As a result, in Windows 8.1, these APIs no longer transform points.
            The system returns all points to an application in its own coordinate space.
            This behavior preserves functionality for the majority of applications,
            but there are some exceptions in which you must make changes to ensure that the application works as expected.
            </para>
            <para>
            For example, an application might need to walk the entire window tree of another process and ask the system for DPI-dependent information about the window.
            By default, the system will return the information based on the DPI awareness of the caller. This is ideal for most applications.
            However, the caller might need the information based on the DPI awareness of the application associated with the window.
            This might be necessary because the two applications send DPI-dependent information between each other directly.
            In this case, the application can use <see cref="M:PInvoke.User32.LogicalToPhysicalPointForPerMonitorDPI(System.IntPtr,PInvoke.POINT@)"/> to get physical coordinates and
            then use PhysicalToLogicalPointForPerMonitorDPI to convert the physical coordinates
            into logical coordinates based on the DPI-awareness of the provided <paramref name="hwnd"/>.
            </para>
            <para>
            Consider two applications, one has value of  and the other has a value of <see cref="F:PInvoke.PROCESS_DPI_AWARENESS.PROCESS_PER_MONITOR_DPI_AWARE"/>.
            The <see cref="F:PInvoke.PROCESS_DPI_AWARENESS.PROCESS_DPI_UNAWARE"/> app creates a window on a single monitor where the scale factor is 200% (192 DPI).
            If both apps call <see cref="M:PInvoke.User32.GetWindowRect(System.IntPtr,PInvoke.RECT@)"/> on this window, they will receive different values.
            The <see cref="F:PInvoke.PROCESS_DPI_AWARENESS.PROCESS_PER_MONITOR_DPI_AWARE"/> app will receive a rect based on 96 DPI coordinates,
            while the <see cref="F:PInvoke.PROCESS_DPI_AWARENESS.PROCESS_DPI_UNAWARE"/> app will receive coordinates matching the actual DPI of the monitor.
            If the <see cref="F:PInvoke.PROCESS_DPI_AWARENESS.PROCESS_PER_MONITOR_DPI_AWARE"/> needs the <see cref="T:PInvoke.RECT"/> that the system returned
            to the <see cref="F:PInvoke.PROCESS_DPI_AWARENESS.PROCESS_DPI_UNAWARE"/> app, it could call <see cref="M:PInvoke.User32.LogicalToPhysicalPointForPerMonitorDPI(System.IntPtr,PInvoke.POINT@)"/>
            for the corners of its <see cref="T:PInvoke.RECT"/> and pass in the handle to the <see cref="F:PInvoke.PROCESS_DPI_AWARENESS.PROCESS_DPI_UNAWARE"/> app's window.
            This will return points based on the other app's awareness that can be used to create a <see cref="T:PInvoke.RECT"/>.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.PhysicalToLogicalPoint(System.IntPtr,PInvoke.POINT@)">
            <summary>
            Converts the physical coordinates of a point in a window to logical coordinates
            </summary>
            <param name="hwnd">
            A handle to the window whose transform is used for the conversion. Top level windows are fully supported.
            In the case of child windows, only the area of overlap between the parent and the child window is converted
            </param>
            <param name="lpPoint">
            A pointer to a <see cref="T:PInvoke.POINT"/> structure that specifies the physical/screen coordinates to be converted.
            The new logical coordinates are copied into this structure if the function succeeds
            </param>
            <returns>Returns TRUE if successful, or FALSE otherwise</returns>
            <remarks>
            <para>
            The function uses the window identified by the <paramref name="hwnd"/> parameter and the physical coordinates
            given in the <see cref="T:PInvoke.POINT"/> structure to compute the logical coordinates.
            The logical coordinates are the unscaled coordinates that appear to the application in a programmatic way.
            In other words, the logical coordinates are the coordinates the application recognizes, which can be different from the physical coordinates.
            The API then replaces the physical coordinates with the logical coordinates.
            The new coordinates are in the world coordinates whose origin is (0, 0) on the desktop.
            The coordinates passed to the API have to be on the <paramref name="hwnd"/>.
            </para>
            <para>
            On all platforms, PhysicalToLogicalPoint will fail on a window that has either 0 width or height;
            an application must first establish a non-0 width and height by calling, for example, <see cref="M:PInvoke.User32.MoveWindow(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)"/>.
            On some versions of Windows (including Windows 7), PhysicalToLogicalPointwill still fail if <see cref="M:PInvoke.User32.MoveWindow(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)"/> has been called
            after a call to <see cref="M:PInvoke.User32.ShowWindow(System.IntPtr,PInvoke.User32.WindowShowStyle)"/> with <see cref="F:PInvoke.User32.WindowShowStyle.SW_HIDE"/> has hidden the window.
            </para>
            <para>
            In Windows 8, system–DPI aware applications translate between physical and logical space using PhysicalToLogicalPoint and <see cref="M:PInvoke.User32.LogicalToPhysicalPoint(System.IntPtr,PInvoke.POINT@)"/>.
            In Windows 8.1, the additional virtualization of the system and inter-process communications means that for the majority of applications,
            you do not need these APIs. As a result, in Windows 8.1, PhysicalToLogicalPoint and <see cref="M:PInvoke.User32.LogicalToPhysicalPoint(System.IntPtr,PInvoke.POINT@)"/> no longer transform points.
            The system returns all points to an application in its own coordinate space.
            This behavior preserves functionality for the majority of applications,
            but there are some exceptions in which you must make changes to ensure that the application works as expected.
            In those cases, use <see cref="M:PInvoke.User32.PhysicalToLogicalPointForPerMonitorDPI(System.IntPtr,PInvoke.POINT@)"/> and <see cref="M:PInvoke.User32.LogicalToPhysicalPointForPerMonitorDPI(System.IntPtr,PInvoke.POINT@)"/>.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.LogicalToPhysicalPointForPerMonitorDPI(System.IntPtr,PInvoke.POINT@)">
            <summary>
            Converts a point in a window from logical coordinates into physical coordinates, regardless of the dots per inch (dpi) awareness of the caller.
            For more information about DPI awareness levels, see <see cref="T:PInvoke.PROCESS_DPI_AWARENESS"/>.
            <para>
            Tip: Since an application with a value of <see cref="F:PInvoke.PROCESS_DPI_AWARENESS.PROCESS_PER_MONITOR_DPI_AWARE"/> uses the actual DPI of the monitor,
            physical and logical coordinates are the same for this app.
            </para>
            </summary>
            <param name="hwnd">A handle to the window whose transform is used for the conversion</param>
            <param name="lpPoint">
            A pointer to a <see cref="T:PInvoke.POINT"/> structure that specifies the logical coordinates to be converted.
            The new physical coordinates are copied into this structure if the function succeeds
            </param>
            <returns>Returns true if successful, or false otherwise</returns>
            <remarks>
            <para>
            In Windows 8, system–DPI aware applications translated between physical and logical space using
            <see cref="M:PInvoke.User32.PhysicalToLogicalPoint(System.IntPtr,PInvoke.POINT@)"/> and <see cref="M:PInvoke.User32.LogicalToPhysicalPoint(System.IntPtr,PInvoke.POINT@)"/>.
            In Windows 8.1, the additional virtualization of the system and inter-process communications means that for the majority of applications, you do not need these APIs.
            As a result, in Windows 8.1, these APIs no longer transform points.
            The system returns all points to an application in its own coordinate space.
            This behavior preserves functionality for the majority of applications,
            but there are some exceptions in which you must make changes to ensure that the application works as expected.
            </para>
            <para>
            For example, an application might need to walk the entire window tree of another process and ask the system for DPI-dependent information about the window.
            By default, the system will return the information based on the DPI awareness of the caller. This is ideal for most applications.
            However, the caller might need the information based on the DPI awareness of the application associated with the window.
            This might be necessary because the two applications send DPI-dependent information between each other directly.
            In this case, the application can use LogicalToPhysicalPointForPerMonitorDPI to get physical coordinates and
            then use <see cref="M:PInvoke.User32.PhysicalToLogicalPointForPerMonitorDPI(System.IntPtr,PInvoke.POINT@)"/> to convert the physical coordinates
            into logical coordinates based on the DPI-awareness of the provided <paramref name="hwnd"/>.
            </para>
            <para>
            Consider two applications, one has value of  and the other has a value of <see cref="F:PInvoke.PROCESS_DPI_AWARENESS.PROCESS_PER_MONITOR_DPI_AWARE"/>.
            The <see cref="F:PInvoke.PROCESS_DPI_AWARENESS.PROCESS_DPI_UNAWARE"/> app creates a window on a single monitor where the scale factor is 200% (192 DPI).
            If both apps call <see cref="M:PInvoke.User32.GetWindowRect(System.IntPtr,PInvoke.RECT@)"/> on this window, they will receive different values.
            The <see cref="F:PInvoke.PROCESS_DPI_AWARENESS.PROCESS_PER_MONITOR_DPI_AWARE"/> app will receive a rect based on 96 DPI coordinates,
            while the <see cref="F:PInvoke.PROCESS_DPI_AWARENESS.PROCESS_DPI_UNAWARE"/> app will receive coordinates matching the actual DPI of the monitor.
            If the <see cref="F:PInvoke.PROCESS_DPI_AWARENESS.PROCESS_PER_MONITOR_DPI_AWARE"/> needs the <see cref="T:PInvoke.RECT"/> that the system returned
            to the <see cref="F:PInvoke.PROCESS_DPI_AWARENESS.PROCESS_DPI_UNAWARE"/> app, it could call LogicalToPhysicalPointForPerMonitorDPI
            for the corners of its <see cref="T:PInvoke.RECT"/> and pass in the handle to the <see cref="F:PInvoke.PROCESS_DPI_AWARENESS.PROCESS_DPI_UNAWARE"/> app's window.
            This will return points based on the other app's awareness that can be used to create a <see cref="T:PInvoke.RECT"/>.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.LogicalToPhysicalPoint(System.IntPtr,PInvoke.POINT@)">
            <summary>
            Converts the logical coordinates of a point in a window to physical coordinates
            </summary>
            <param name="hwnd">
            A handle to the window whose transform is used for the conversion. Top level windows are fully supported.
            In the case of child windows, only the area of overlap between the parent and the child window is converted
            </param>
            <param name="lpPoint">
            A pointer to a <see cref="T:PInvoke.POINT"/> structure that specifies the logical coordinates to be converted.
            The new physical coordinates are copied into this structure if the function succeeds
            </param>
            <returns>Returns TRUE if successful, or FALSE otherwise</returns>
            <remarks>
            <para>
            LogicalToPhysicalPoint is a transformation API that can be called by a process that declares itself as dpi aware.
            The function uses the window identified by the hWnd parameter and the logical coordinates given in the <see cref="T:PInvoke.POINT"/> structure to compute the physical coordinates.
            The LogicalToPhysicalPoint function replaces the logical coordinates in the <see cref="T:PInvoke.POINT"/> structure with the physical coordinates.
            The physical coordinates are relative to the upper-left corner of the screen.
            The coordinates have to be inside the client area of <paramref name="hwnd"/>.
            </para>
            <para>
            On all platforms, LogicalToPhysicalPoint will fail on a window that has either 0 width or height;
            an application must first establish a non-0 width and height by calling, for example, <see cref="M:PInvoke.User32.MoveWindow(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)"/>.
            On some versions of Windows (including Windows 7), LogicalToPhysicalPoint will still fail if <see cref="M:PInvoke.User32.MoveWindow(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)"/> has been called
            after a call to <see cref="M:PInvoke.User32.ShowWindow(System.IntPtr,PInvoke.User32.WindowShowStyle)"/> with <see cref="F:PInvoke.User32.WindowShowStyle.SW_HIDE"/> has hidden the window.
            </para>
            <para>
            In Windows 8, system–DPI aware applications translate between physical and logical space using <see cref="M:PInvoke.User32.PhysicalToLogicalPoint(System.IntPtr,PInvoke.POINT@)"/> and LogicalToPhysicalPoint.
            In Windows 8.1, the additional virtualization of the system and inter-process communications means that for the majority of applications,
            you do not need these APIs. As a result, in Windows 8.1, <see cref="M:PInvoke.User32.PhysicalToLogicalPoint(System.IntPtr,PInvoke.POINT@)"/> and LogicalToPhysicalPoint no longer transform points.
            The system returns all points to an application in its own coordinate space.
            This behavior preserves functionality for the majority of applications,
            but there are some exceptions in which you must make changes to ensure that the application works as expected.
            In those cases, use <see cref="M:PInvoke.User32.PhysicalToLogicalPointForPerMonitorDPI(System.IntPtr,PInvoke.POINT@)"/> and <see cref="M:PInvoke.User32.LogicalToPhysicalPointForPerMonitorDPI(System.IntPtr,PInvoke.POINT@)"/>.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.IsProcessDPIAware">
            <summary>
            Determines whether the current process is dots per inch (dpi) aware such that it adjusts the sizes of UI elements to compensate for the dpi setting.
            </summary>
            <returns>TRUE if the process is dpi aware; otherwise, FALSE</returns>
            <remarks>
            IsProcessDPIAware is available for use in Windows Vista or superior the operating systems.
            It may be altered or unavailable in subsequent versions.
            For Windows 8.1 or superior operating systems, use GetProcessDPIAwareness/>.
            </remarks>
        </member>
        <member name="M:PInvoke.User32.SetProcessDPIAware">
            <summary>
            Sets the current process as dots per inch (dpi) awareness.
            </summary>
            <returns>If the function succeeds, the return value is true. Otherwise, the return value is false.</returns>
            <remarks>
            <para>
            SetProcessDPIAware is available for use in Windows Vista or superior the operating systems.
            It may be altered or unavailable in subsequent versions.
            For Windows 8.1 or superior operating systems, use SetProcessDpiAwareness/>.
            </para>
            <para>
            SetProcessDPIAware is subject to a possible race condition if a DLL caches dpi settings during initialization.
            For this reason, it is recommended that dpi-aware be set through the application (.exe) manifest rather than by calling SetProcessDPIAware.
            DLLs should accept the dpi setting of the host process rather than call SetProcessDPIAware themselves.
            To be set properly, dpiAware should be specified as part of the application (.exe) manifest.
            IMPORTANT: dpiAware defined in an embedded DLL manifest has no affect.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.SwitchDesktop(PInvoke.User32.SafeDesktopHandle)">
            <summary>
            The GetDC function retrieves a handle to a device context (DC) for the client area of a specified window or for the entire screen. You can use the returned handle in subsequent GDI functions to draw in the DC. The device context is an opaque data structure, whose values are used internally by GDI.
            The GetDCEx function is an extension to GetDC, which gives an application more control over how and whether clipping occurs in the client area.
            Makes the specified desktop visible and activates it. This enables the desktop to receive input from the user.
            The calling process must have DESKTOP_SWITCHDESKTOP access to the desktop for the SwitchDesktop function to succeed.
            </summary>
            <param name="hDesktop">
            A handle to the desktop. This handle is returned by the <see cref="M:PInvoke.User32.CreateDesktop(System.String,System.String,System.IntPtr,PInvoke.User32.DesktopCreationFlags,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)"/> and <see cref="M:PInvoke.User32.OpenDesktop(System.String,PInvoke.User32.DesktopCreationFlags,System.Boolean,PInvoke.Kernel32.ACCESS_MASK)"/> functions.
            This desktop must be associated with the current window station for the process.</param>
            <returns>If the function succeeds, the return value is true, if it fails, the return value is false.</returns>
            <remarks>
            <para>
            SwitchDesktop only sets the last error for the following cases:
            <list>
            <item>When the desktop belongs to an invisible window station</item>
            <item>When hDesktop is an invalid handle, refers to a destroyed desktop, or belongs to a different session than that of the calling process</item>
            </list>
            </para>
            <para>
            The SwitchDesktop function fails if the desktop belongs to an invisible window station.
            SwitchDesktop also fails when called from a process that is associated with a secured desktop such as the WinLogon and ScreenSaver desktops.
            Processes that are associated with a secured desktop include custom UserInit processes. Such calls typically fail with an "access denied" error.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.SetThreadDesktop(PInvoke.User32.SafeDesktopHandle)">
            <summary>
            Assigns the specified desktop to the calling thread. All subsequent operations on the desktop use the access rights granted to the desktop.
            </summary>
            <param name="hDesktop">
            A handle to the desktop to be assigned to the calling thread.
            This handle is returned by the <see cref="M:PInvoke.User32.CreateDesktop(System.String,System.String,System.IntPtr,PInvoke.User32.DesktopCreationFlags,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)"/>, <see cref="M:PInvoke.User32.GetThreadDesktop(System.UInt32)"/>, <see cref="M:PInvoke.User32.OpenDesktop(System.String,PInvoke.User32.DesktopCreationFlags,System.Boolean,PInvoke.Kernel32.ACCESS_MASK)"/>, or <see cref="M:PInvoke.User32.OpenInputDesktop(PInvoke.User32.DesktopCreationFlags,System.Boolean,PInvoke.Kernel32.ACCESS_MASK)"/> function.
            This desktop must be associated with the current window station for the process.
            </param>
            <returns>If the function succeeds, the return value is true, if it fails, the return value is false.</returns>
            <remarks>
            The function will fail if the calling thread has any windows or hooks on its current desktop (unless the <paramref name="hDesktop"/> parameter is a handle to the current desktop).
            </remarks>
        </member>
        <member name="M:PInvoke.User32.OpenDesktop(System.String,PInvoke.User32.DesktopCreationFlags,System.Boolean,PInvoke.Kernel32.ACCESS_MASK)">
            <summary>
            Opens the specified desktop object.
            </summary>
            <param name="lpszDesktop">The name of the desktop to be opened. Desktop names are case-insensitive. This desktop must belong to the current window station.</param>
            <param name="dwFlags">Access control flags</param>
            <param name="fInherit">If this value is true, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
            <param name="dwDesiredAccess">The access to the desktop. For a list of access rights, see <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.</param>
            <returns>If the function succeeds, the return value is a handle to the opened desktop, if the function fails, the return value is an invalid handle.</returns>
            <remarks>
            <para>
            When you are finished using the handle, call the <see cref="M:PInvoke.User32.CloseDesktop(System.IntPtr)"/> function to close it.
            </para>
            <para>
            The calling process must have an associated window station, either assigned by the system at process creation time or set by the <see cref="M:PInvoke.User32.SetProcessWindowStation(PInvoke.User32.SafeWindowStationHandle)"/> function.
            </para>
            <para>
            If the <paramref name="dwDesiredAccess"/> parameter specifies the READ_CONTROL, WRITE_DAC, or WRITE_OWNER standard access rights, you must also request the DESKTOP_READOBJECTS and DESKTOP_WRITEOBJECTS access rights.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.EnumDesktopWindows(PInvoke.User32.SafeDesktopHandle,PInvoke.User32.WNDENUMPROC,System.IntPtr)">
            <summary>
            Enumerates all top-level windows associated with the specified desktop. It passes the handle to each window, in turn, to an application-defined callback function.
            </summary>
            <param name="hDesktop">
            A handle to the desktop whose top-level windows are to be enumerated. This handle is returned by the <see cref="M:PInvoke.User32.CreateDesktop(System.String,System.String,System.IntPtr,PInvoke.User32.DesktopCreationFlags,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)"/>, <see cref="M:PInvoke.User32.GetThreadDesktop(System.UInt32)"/>, <see cref="M:PInvoke.User32.OpenDesktop(System.String,PInvoke.User32.DesktopCreationFlags,System.Boolean,PInvoke.Kernel32.ACCESS_MASK)"/>, or <see cref="M:PInvoke.User32.OpenInputDesktop(PInvoke.User32.DesktopCreationFlags,System.Boolean,PInvoke.Kernel32.ACCESS_MASK)"/> function,
            and must have the <see cref="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_READOBJECTS"/> access right.
            If this parameter is NULL, the current desktop is used.
            </param>
            <param name="lpfn">An application-defined <see cref="T:PInvoke.User32.WNDENUMPROC"/> callback function.</param>
            <param name="lParam">An application-defined value to be passed to the callback function.</param>
            <returns>
            If the function is unable to perform the enumeration, the return value is zero. Call GetLastError to get extended error information.
            If the function succeeds, it returns the nonzero value returned by the callback function that was pointed to by <paramref name="lpfn"/>.
            If the callback function fails, the return value is zero. The callback function can call SetLastError to set an error code for the caller to retrieve by calling GetLastError.
            Windows Server 2003 and Windows XP/2000:  If there are no windows on the desktop, GetLastError returns ERROR_INVALID_HANDLE.
            </returns>
            <remarks>The EnumDesktopWindows function repeatedly invokes the <paramref name="lpfn"/> callback function until the last top-level window is enumerated or the callback function returns FALSE.</remarks>
        </member>
        <member name="M:PInvoke.User32.EnumWindows(PInvoke.User32.WNDENUMPROC,System.IntPtr)">
            <summary>
            Enumerates all top-level windows on the screen by passing the handle to each window, in turn, to an application-defined callback function. EnumWindows continues until the last top-level window is enumerated or the callback function returns FALSE.
            </summary>
            <param name="lpEnumFunc">An application-defined <see cref="T:PInvoke.User32.WNDENUMPROC"/> callback function.</param>
            <param name="lParam">An application-defined value to be passed to the callback function.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero.To get extended error information, call GetLastError.
            If <see cref="T:PInvoke.User32.WNDENUMPROC"/> returns zero, the return value is also zero. In this case, the callback function should call SetLastError to obtain a meaningful error code to be returned to the caller of EnumWindows.
            </returns>
            <remarks>
            The EnumWindows function does not enumerate child windows, with the exception of a few top-level windows owned by the system that have the WS_CHILD style.
            This function is more reliable than calling the GetWindow function in a loop. An application that calls GetWindow to perform this task risks being caught in an infinite loop or referencing a handle to a window that has been destroyed.
            Note that for Windows 8 and later, EnumWindows enumerates only top-level windows of desktop apps.
            </remarks>
        </member>
        <member name="M:PInvoke.User32.EnumDesktops(PInvoke.User32.SafeWindowStationHandle,PInvoke.User32.DESKTOPENUMPROC,System.IntPtr)">
            <summary>
            Enumerates all desktops associated with the specified window station of the calling process. The function passes the name of each desktop, in turn, to an application-defined callback function.
            </summary>
            <param name="hWinsta">A handle to the window station whose desktops are to be enumerated. This handle is returned by the <see cref="M:PInvoke.User32.CreateWindowStation(System.String,PInvoke.User32.WindowStationCreationFlags,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)"/>, <see cref="M:PInvoke.User32.GetProcessWindowStation"/>, or <see cref="M:PInvoke.User32.OpenWindowStation(System.String,System.Boolean,PInvoke.Kernel32.ACCESS_MASK)"/> function, and must have the WINSTA_ENUMDESKTOPS access right.</param>
            <param name="lpEnumFunc">An application-defined <see cref="T:PInvoke.User32.DESKTOPENUMPROC"/> callback function.</param>
            <param name="lParam">An application-defined value to be passed to the callback function.</param>
            <returns>
            If the function succeeds, it returns the nonzero value returned by the callback function that was pointed to by <paramref name="lpEnumFunc"/>.
            If the function is unable to perform the enumeration, the return value is zero. Call GetLastError to get extended error information.
            If the callback function fails, the return value is zero. The callback function can call SetLastError to set an error code for the caller to retrieve by calling GetLastError.
            </returns>
            <remarks>
            The EnumDesktops function enumerates only those desktops for which the calling process has the <see cref="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_ENUMERATE"/> access right.
            The EnumDesktops function repeatedly invokes the lpEnumFunc callback function until the last desktop is enumerated or the callback function returns zero.
            </remarks>
        </member>
        <member name="M:PInvoke.User32.OpenInputDesktop(PInvoke.User32.DesktopCreationFlags,System.Boolean,PInvoke.Kernel32.ACCESS_MASK)">
            <summary>
            Opens the desktop that receives user input.
            </summary>
            <param name="dwFlags">Access control flags</param>
            <param name="fInherit">If this value is true, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
            <param name="dwDesiredAccess">The requested access to the desktop. For a list of values, see <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.</param>
            <returns>If the function succeeds, the return value is a handle to the opened desktop, if the function fails, the return value is an invalid handle.</returns>
            <remarks>
            <para>
            When you are finished using the handle, call the <see cref="M:PInvoke.User32.CloseDesktop(System.IntPtr)"/> function to close it.
            </para>
            <para>
            The calling process must have an associated window station, either assigned by the system at process creation time or set by the <see cref="M:PInvoke.User32.SetProcessWindowStation(PInvoke.User32.SafeWindowStationHandle)"/> function. The window station associated with the calling process must be capable of receiving input.
            If the calling process is running in a disconnected session, the function returns a handle to the desktop that becomes active when the user restores the connection.
            </para>
            <para>
            An application can use the <see cref="M:PInvoke.User32.SwitchDesktop(PInvoke.User32.SafeDesktopHandle)"/> function to change the input desktop.
            </para>
            <para>
            If the <paramref name="dwDesiredAccess"/> parameter specifies the READ_CONTROL, WRITE_DAC, or WRITE_OWNER standard access rights, you must also request the DESKTOP_READOBJECTS and DESKTOP_WRITEOBJECTS access rights.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.CreateDesktopEx(System.String,System.IntPtr,System.IntPtr,PInvoke.User32.DesktopCreationFlags,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.UInt32,System.IntPtr)">
            <summary>
            Creates a new desktop with the specified heap, associates it with the current window station of the calling process, and assigns it to the calling thread.
            The calling process must have an associated window station, either assigned by the system at process creation time or set by the <see cref="M:PInvoke.User32.SetProcessWindowStation(PInvoke.User32.SafeWindowStationHandle)"/> function.
            </summary>
            <param name="lpszDesktop">The name of the desktop to be created. Desktop names are case-insensitive and may not contain backslash characters (\).</param>
            <param name="lpszDevice">This parameter is reserved and must be <see cref="F:System.IntPtr.Zero"/></param>
            <param name="pDevmode">This parameter is reserved and must be <see cref="F:System.IntPtr.Zero"/>.</param>
            <param name="dwFlags">Access control flags</param>
            <param name="dwDesiredAccess">
            The requested access to the desktop. For a list of values, see <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.
            This parameter must include the <see cref="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_CREATEWINDOW"/> access right, because internally <see cref="M:PInvoke.User32.CreateDesktop(System.String,System.String,System.IntPtr,PInvoke.User32.DesktopCreationFlags,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)"/> uses the handle to create a window.
            </param>
            <param name="lpsa">
            A pointer to a <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that determines whether the returned handle can be inherited by child processes. If lpsa is NULL, the handle cannot be inherited.
            The <see cref="F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member of the structure specifies a security descriptor for the new desktop. If this parameter is NULL, the desktop inherits its security descriptor from the parent window station.
            </param>
            <param name="ulHeapSize">The size of the desktop heap, in kilobytes.</param>
            <param name="pvoid">This parameter is also reserved and must be <see cref="F:System.IntPtr.Zero"/>.</param>
            <returns>
            If the function succeeds, the return value is a handle to the newly created desktop.
            If the specified desktop already exists, the function succeeds and returns a handle to the existing desktop.
            If the function fails, the return value is an invalid handle.
            </returns>
            <remarks>
            <para>
            If the dwDesiredAccess parameter specifies the READ_CONTROL, WRITE_DAC, or WRITE_OWNER standard access rights, you must also request the DESKTOP_READOBJECTS and DESKTOP_WRITEOBJECTS access rights.
            </para>
            <para>
            The number of desktops that can be created is limited by the size of the system desktop heap, which is 48 MB. Desktop objects use the heap to store resources. You can increase the number of desktops that can be created by reducing the default heap reserved for each desktop in the interactive window station. This value is specified in the SharedSection substring of the following registry value: HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\SubSystems\Windows.
            </para>
            <para>
            The default size of the desktop heap depends on factors such as hardware architecture. To retrieve the size of the desktop heap, call the <see cref="M:PInvoke.User32.GetUserObjectInformation(System.IntPtr,PInvoke.User32.ObjectInformationType,System.Void*,System.UInt32,System.UInt32*)"/> function with UOI_HEAPSIZE.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.CreateDesktop(System.String,System.String,System.IntPtr,PInvoke.User32.DesktopCreationFlags,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)">
            <summary>
            Creates a new desktop, associates it with the current window station of the calling process, and assigns it to the calling thread. The calling process must have an associated window station, either assigned by the system at process creation time or set by the <see cref="M:PInvoke.User32.SetProcessWindowStation(PInvoke.User32.SafeWindowStationHandle)"/> function.
            </summary>
            <param name="lpszDesktop">The name of the desktop to be created. Desktop names are case-insensitive and may not contain backslash characters (\).</param>
            <param name="lpszDevice">This parameter is reserved and must be <see cref="F:System.IntPtr.Zero"/></param>
            <param name="pDevmode">This parameter is reserved and must be <see cref="F:System.IntPtr.Zero"/>.</param>
            <param name="dwFlags">Access control flags</param>
            <param name="dwDesiredAccess">
            The requested access to the desktop. For a list of values, see <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.
            This parameter must include the <see cref="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_CREATEWINDOW"/> access right, because internally <see cref="M:PInvoke.User32.CreateDesktop(System.String,System.String,System.IntPtr,PInvoke.User32.DesktopCreationFlags,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)"/> uses the handle to create a window.
            </param>
            <param name="lpsa">
            A pointer to a <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that determines whether the returned handle can be inherited by child processes. If lpsa is NULL, the handle cannot be inherited.
            The <see cref="F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member of the structure specifies a security descriptor for the new desktop. If this parameter is NULL, the desktop inherits its security descriptor from the parent window station.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the newly created desktop.
            If the specified desktop already exists, the function succeeds and returns a handle to the existing desktop.
            If the function fails, the return value is an invalid handle.
            </returns>
            <remarks>
            <para>
            If the dwDesiredAccess parameter specifies the READ_CONTROL, WRITE_DAC, or WRITE_OWNER standard access rights, you must also request the DESKTOP_READOBJECTS and DESKTOP_WRITEOBJECTS access rights.
            </para>
            <para>
            The number of desktops that can be created is limited by the size of the system desktop heap, which is 48 MB. Desktop objects use the heap to store resources. You can increase the number of desktops that can be created by reducing the default heap reserved for each desktop in the interactive window station. This value is specified in the SharedSection substring of the following registry value: HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\SubSystems\Windows.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.GetThreadDesktop(System.UInt32)">
            <summary>
            Retrieves a handle to the desktop assigned to the specified thread.
            </summary>
            <param name="dwThreadId">The thread identifier. The <see cref="M:PInvoke.Kernel32.GetCurrentThreadId"/> and CreateProcess functions return thread identifiers.</param>
            <returns>
            If the function succeeds, the return value is a handle to the desktop associated with the specified thread.
            You do not need to call the <see cref="M:PInvoke.User32.CloseDesktop(System.IntPtr)"/> function to close the returned handle.
            </returns>
            <remarks>
            <para>
            The system associates a desktop with a thread when that thread is created. A thread can use the SetThreadDesktop function to change its desktop. The desktop associated with a thread must be on the window station associated with the thread's process.
            </para>
            <para>
            The calling process can use the returned handle in calls to the <see cref="M:PInvoke.User32.GetUserObjectInformation(System.IntPtr,PInvoke.User32.ObjectInformationType,System.Void*,System.UInt32,System.UInt32*)"/>, GetUserObjectSecurity, SetUserObjectInformation, and SetUserObjectSecurity functions.
            </para>
            <para>
            A service application is created with an associated window station and desktop, so there is no need to call a USER or GDI function to connect the service to a window station and desktop.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.CloseDesktop(System.IntPtr)">
            <summary>
            Closes an open handle to a desktop object.
            </summary>
            <param name="hDesktop">
            A handle to the desktop to be closed. This can be a handle returned by the <see cref="M:PInvoke.User32.CreateDesktop(System.String,System.String,System.IntPtr,PInvoke.User32.DesktopCreationFlags,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)"/>, <see cref="M:PInvoke.User32.OpenDesktop(System.String,PInvoke.User32.DesktopCreationFlags,System.Boolean,PInvoke.Kernel32.ACCESS_MASK)"/>, or <see cref="M:PInvoke.User32.OpenInputDesktop(PInvoke.User32.DesktopCreationFlags,System.Boolean,PInvoke.Kernel32.ACCESS_MASK)"/> functions.
            Do not specify the handle returned by the <see cref="M:PInvoke.User32.GetThreadDesktop(System.UInt32)"/> function.
            </param>
            <returns>If the function succeeds, the return value is true, if it fails, the return value is false.</returns>
            <remarks>The CloseDesktop function will fail if any thread in the calling process is using the specified desktop handle or if the handle refers to the initial desktop of the calling process.</remarks>
        </member>
        <member name="M:PInvoke.User32.GetUserObjectInformation(System.IntPtr,PInvoke.User32.ObjectInformationType,System.Void*,System.UInt32,System.UInt32*)">
            <summary>
            Retrieves information about the specified window station or desktop object.
            </summary>
            <param name="hObj">A handle to the window station or desktop object. This handle is returned by the <see cref="M:PInvoke.User32.CreateWindowStation(System.String,PInvoke.User32.WindowStationCreationFlags,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)"/>, <see cref="M:PInvoke.User32.OpenWindowStation(System.String,System.Boolean,PInvoke.Kernel32.ACCESS_MASK)"/>, <see cref="M:PInvoke.User32.CreateDesktop(System.String,System.String,System.IntPtr,PInvoke.User32.DesktopCreationFlags,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)"/>, or <see cref="M:PInvoke.User32.OpenDesktop(System.String,PInvoke.User32.DesktopCreationFlags,System.Boolean,PInvoke.Kernel32.ACCESS_MASK)"/> function.</param>
            <param name="nIndex">The information to be retrieved.</param>
            <param name="pvInfo">A pointer to a buffer to receive the object information.</param>
            <param name="nLength">The size of the buffer pointed to by the <paramref name="pvInfo"/> parameter, in bytes.</param>
            <param name="lpnLengthNeeded">
            A pointer to a variable receiving the number of bytes required to store the requested information.
            If this variable's value is greater than the value of the <paramref name="nLength"/> parameter when the function returns, the function returns false, and none of the information is copied to the <paramref name="pvInfo"/> buffer.
            If the value of the variable pointed to by lpnLengthNeeded is less than or equal to the value of <paramref name="nLength"/>, the entire information block is copied.</param>
            <returns>If the function succeeds, the return value is true, if it fails, the return value is false.</returns>
        </member>
        <member name="M:PInvoke.User32.SetProcessWindowStation(PInvoke.User32.SafeWindowStationHandle)">
            <summary>
            Assigns the specified window station to the calling process.
            This enables the process to access objects in the window station such as desktops, the clipboard, and global atoms. All subsequent operations on the window station use the access rights granted to <paramref name="hWinSta"/>.
            </summary>
            <param name="hWinSta">
            A handle to the window station. This can be a handle returned by the <see cref="M:PInvoke.User32.CreateWindowStation(System.String,PInvoke.User32.WindowStationCreationFlags,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)"/>, <see cref="M:PInvoke.User32.OpenWindowStation(System.String,System.Boolean,PInvoke.Kernel32.ACCESS_MASK)"/>, or <see cref="M:PInvoke.User32.GetProcessWindowStation"/> function.
            This window station must be associated with the current session.
            </param>
            <returns>If the function succeeds, the return value is true, if it fails, the return value is false.</returns>
        </member>
        <member name="M:PInvoke.User32.CloseWindowStation(System.IntPtr)">
            <summary>
            Closes an open window station handle.
            </summary>
            <param name="hWinsta">
            A handle to the window station to be closed.
            This handle is returned by the <see cref="M:PInvoke.User32.CreateWindowStation(System.String,PInvoke.User32.WindowStationCreationFlags,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)"/> or <see cref="M:PInvoke.User32.OpenWindowStation(System.String,System.Boolean,PInvoke.Kernel32.ACCESS_MASK)"/> function.
            Do not specify the handle returned by the <see cref="M:PInvoke.User32.GetProcessWindowStation"/> function.
            </param>
            <returns>If the function succeeds, the return value is true, if it fails, the return value is false.</returns>
            <remarks>
            <para>
            Windows Server 2003 and Windows XP/2000:  This function does not set the last error code on failure.
            </para>
            <para>
            The CloseWindowStation function will fail if the handle being closed is for the window station assigned to the calling process.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.CreateWindowStation(System.String,PInvoke.User32.WindowStationCreationFlags,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)">
            <summary>
            Creates a window station object, associates it with the calling process, and assigns it to the current session.
            </summary>
            <param name="lpwinsta">
            The name of the window station to be created. Window station names are case-insensitive and cannot contain backslash characters (\).
            Only members of the Administrators group are allowed to specify a name.
            If lpwinsta is NULL or an empty string, the system forms a window station name using the logon session identifier for the calling process.
            To get this name, call the <see cref="M:PInvoke.User32.GetUserObjectInformation(System.IntPtr,PInvoke.User32.ObjectInformationType,System.Void*,System.UInt32,System.UInt32*)"/> function.</param>
            <param name="dwFlags">
            If this parameter is <see cref="F:PInvoke.User32.WindowStationCreationFlags.CWF_CREATE_ONLY"/> and the window station already exists, the call fails.
            If this flag is not specified and the window station already exists, the function succeeds and returns a new handle to the existing window station.
            Windows XP/2000:  This parameter is reserved and must be zero.
            </param>
            <param name="dwDesiredAccess">
            The requested access to the window station. For a list of values, see <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.
            In addition, you can specify any of the standard access rights, such as <see cref="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.READ_CONTROL"/> or <see cref="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.WRITE_DAC"/>, and a combination of the window station-specific access rights.
            </param>
            <param name="lpsa">
            A pointer to a <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that determines whether the returned handle can be inherited by child processes. If lpsa is NULL, the handle cannot be inherited.
            The <see cref="F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member of the structure specifies a security descriptor for the new window station.
            If lpsa is NULL, the window station (and any desktops created within the window) gets a security descriptor that grants <see cref="F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_ALL"/> access to all users.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the newly created window station.
            If the specified window station already exists, the function succeeds and returns a handle to the existing window station.
            If the function fails, the return value is an invalid handle.
            </returns>
            <remarks>After you are done with the handle, you must call <see cref="M:PInvoke.User32.CloseWindowStation(System.IntPtr)"/> to free the handle.</remarks>
        </member>
        <member name="M:PInvoke.User32.GetProcessWindowStation">
            <summary>
            Retrieves a handle to the current window station for the calling process.
            </summary>
            <returns>
            If the function succeeds, the return value is a handle to the window station. If the function fails, the return value is an invalid handle.
            Do not close the handle returned by this function.
            </returns>
            <remarks>
            <para>
            The system associates a window station with a process when the process is created. A process can use the <see cref="M:PInvoke.User32.SetProcessWindowStation(PInvoke.User32.SafeWindowStationHandle)"/> function to change its window station.
            </para>
            <para>
            The calling process can use the returned handle in calls to the <see cref="M:PInvoke.User32.GetUserObjectInformation(System.IntPtr,PInvoke.User32.ObjectInformationType,System.Void*,System.UInt32,System.UInt32*)"/>, GetUserObjectSecurity, SetUserObjectInformation, and SetUserObjectSecurity functions.
            </para>
            <para>
            A service application is created with an associated window station and desktop, so there is no need to call a USER or GDI function to connect the service to a window station and desktop.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.EnumWindowStations(PInvoke.User32.WINSTAENUMPROC,System.IntPtr)">
            <summary>
            Enumerates all window stations in the current session. The function passes the name of each window station, in turn, to an application-defined callback function.
            </summary>
            <param name="lpEnumFunc">An application-defined <see cref="T:PInvoke.User32.WINSTAENUMPROC"/> callback function.</param>
            <param name="lParam">An application-defined value to be passed to the callback function.</param>
            <returns>
            If the function is unable to perform the enumeration, the return value is zero. Call GetLastError to get extended error information.
            If the function succeeds, it returns the nonzero value returned by the callback function that was pointed to by <paramref name="lpEnumFunc"/>.
            If the callback function fails, the return value is zero. The callback function can call SetLastError to set an error code for the caller to retrieve by calling GetLastError.
            </returns>
            <remarks>
            The EnumWindowStations function enumerates only those window stations for which the calling process has the <see cref="F:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight.WINSTA_ENUMERATE"/> access right.
             EnumWindowStations repeatedly invokes the <paramref name="lpEnumFunc"/> callback function until the last window station is enumerated or the callback function returns FALSE.
            </remarks>
        </member>
        <member name="M:PInvoke.User32.OpenWindowStation(System.String,System.Boolean,PInvoke.Kernel32.ACCESS_MASK)">
            <summary>
            Opens the specified window station.
            </summary>
            <param name="lpszWinSta">The name of the window station to be opened. Window station names are case-insensitive. This window station must belong to the current session.</param>
            <param name="fInherit">If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
            <param name="dwDesiredAccess">The access to the window station. For a list of access rights</param>
            <returns>If the function succeeds, the return value is the handle to the specified window station. If the function fails, the return value is NULL. </returns>
            <remarks>After you are done with the handle, you must call <see cref="M:PInvoke.User32.CloseWindowStation(System.IntPtr)"/> to free the handle.</remarks>
        </member>
        <member name="M:PInvoke.User32.CreateDialogIndirectParam(PInvoke.Kernel32.SafeLibraryHandle,PInvoke.User32.DLGTEMPLATE*,System.IntPtr,PInvoke.User32.DialogProc,System.IntPtr)">
            <summary>
                Creates a modeless dialog box from a dialog box template in memory. Before displaying the dialog box, the function
                passes an application-defined value to the dialog box procedure as the lParam parameter of the
                <see cref="F:PInvoke.User32.WindowMessage.WM_INITDIALOG" /> message. An application can use this value to initialize dialog box
                controls.
            </summary>
            <param name="hInstance">
                A handle to the module which contains the dialog box template. If this parameter is
                <see cref="F:PInvoke.Kernel32.SafeLibraryHandle.Null" />, then the current executable is used.
            </param>
            <param name="lpTemplate">
                The template CreateDialogIndirectParam uses to create the dialog box. A dialog box template consists of a header
                that describes the dialog box, followed by one or more additional blocks of data that describe each of the controls
                in the dialog box. The template can use either the standard format or the extended format.
                <para>
                    In a standard template, the header is a <see cref="T:PInvoke.User32.DLGTEMPLATE" /> structure followed by additional
                    variable-length arrays. The data for each control consists of a <see cref="T:PInvoke.User32.DLGITEMTEMPLATE" /> structure
                    followed by additional variable-length arrays.
                </para>
                <para>
                    In an extended dialog box template, the header uses the DLGTEMPLATEEX format and the control definitions use
                    the DLGITEMTEMPLATEEX format.
                </para>
                <para>
                    After CreateDialogIndirectParam returns, you can free the template, which is only used to get the dialog box
                    started.
                </para>
            </param>
            <param name="hWndParent">A handle to the window that owns the dialog box.</param>
            <param name="lpDialogFunc">A pointer to the dialog box procedure.</param>
            <param name="lParamInit">
                The value to pass to the dialog box in the lParam parameter of the
                <see cref="F:PInvoke.User32.WindowMessage.WM_INITDIALOG" /> message.
            </param>
            <returns>
                If the function succeeds, the return value is the window handle to the dialog box.
                <para>
                    If the function fails, the return value is <see cref="F:System.IntPtr.Zero" />. To get extended error information,
                    call <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.User32.GetMessage(PInvoke.User32.MSG*,System.IntPtr,PInvoke.User32.WindowMessage,PInvoke.User32.WindowMessage)">
            <summary>
                Retrieves a message from the calling thread's message queue. The function dispatches incoming sent messages until a
                posted message is available for retrieval.
                <para>
                    Unlike <see cref="M:PInvoke.User32.GetMessage(PInvoke.User32.MSG*,System.IntPtr,PInvoke.User32.WindowMessage,PInvoke.User32.WindowMessage)" />, the <see cref="M:PInvoke.User32.PeekMessage(PInvoke.User32.MSG*,System.IntPtr,PInvoke.User32.WindowMessage,PInvoke.User32.WindowMessage,PInvoke.User32.PeekMessageRemoveFlags)" /> function does not wait for a message to be
                    posted before returning.
                </para>
            </summary>
            <param name="lpMsg">A pointer to an <see cref="T:PInvoke.User32.MSG" /> structure that receives message information.</param>
            <param name="hWnd">
                A handle to the window whose messages are to be retrieved. The window must belong to the current thread.
                <para>
                    If hWnd is <see cref="F:System.IntPtr.Zero" />, PeekMessage retrieves messages for any window that belongs to the
                    current thread, and any messages on the current thread's message queue whose hwnd value is NULL (see the MSG
                    structure). Therefore if hWnd is <see cref="F:System.IntPtr.Zero" />, both window messages and thread messages are
                    processed.
                </para>
                <para>
                    If hWnd is -1, PeekMessage retrieves only messages on the current thread's message queue whose hwnd value is
                    NULL, that is, thread messages as posted by <see cref="M:PInvoke.User32.PostMessage(System.IntPtr,PInvoke.User32.WindowMessage,System.Void*,System.Void*)" />
                    (when the hWnd parameter is <see cref="F:System.IntPtr.Zero" />) or <see cref="M:PInvoke.User32.PostThreadMessage(System.Int32,PInvoke.User32.WindowMessage,System.IntPtr,System.IntPtr)"/>.
                </para>
            </param>
            <param name="wMsgFilterMin">
                <para>
                    The value of the first message in the range of messages to be examined. Use
                    <see cref="F:PInvoke.User32.WindowMessage.WM_KEYFIRST" /> to specify the first keyboard message or
                    <see cref="F:PInvoke.User32.WindowMessage.WM_MOUSEFIRST" /> to specify the first mouse message.
                </para>
                <para>
                    If wMsgFilterMin and wMsgFilterMax are both <see cref="F:PInvoke.User32.WindowMessage.WM_NULL" />, PeekMessage returns all
                    available messages (that is, no range filtering is performed).
                </para>
            </param>
            <param name="wMsgFilterMax">
                <para>
                    The value of the last message in the range of messages to be examined. Use
                    <see cref="F:PInvoke.User32.WindowMessage.WM_KEYLAST" /> to specify the last keyboard message or
                    <see cref="F:PInvoke.User32.WindowMessage.WM_MOUSELAST" /> to specify the last mouse message.
                </para>
                <para>
                    If wMsgFilterMin and wMsgFilterMax are both <see cref="F:PInvoke.User32.WindowMessage.WM_NULL" />, PeekMessage returns all
                    available messages (that is, no range filtering is performed).
                </para>
            </param>
            <returns>
                If the function retrieves a message other than <see cref="F:PInvoke.User32.WindowMessage.WM_QUIT" />, the return value is nonzero.
                <para>If the function retrieves the <see cref="F:PInvoke.User32.WindowMessage.WM_QUIT" /> message, the return value is zero.</para>
                <para>
                    If there is an error, the return value is -1. For example, the function fails if <paramref name="hWnd" /> is
                    an invalid window handle or <paramref name="lpMsg" /> is an invalid pointer. To get extended error information,
                    call <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.User32.PeekMessage(PInvoke.User32.MSG*,System.IntPtr,PInvoke.User32.WindowMessage,PInvoke.User32.WindowMessage,PInvoke.User32.PeekMessageRemoveFlags)">
            <summary>
                Dispatches incoming sent messages, checks the thread message queue for a posted message, and retrieves the message
                (if any exist).
            </summary>
            <param name="lpMsg">A pointer to an <see cref="T:PInvoke.User32.MSG" /> structure that receives message information.</param>
            <param name="hWnd">
                A handle to the window whose messages are to be retrieved. The window must belong to the current thread.
                <para>
                    If hWnd is <see cref="F:System.IntPtr.Zero" />, PeekMessage retrieves messages for any window that belongs to the
                    current thread, and any messages on the current thread's message queue whose hwnd value is NULL (see the MSG
                    structure). Therefore if hWnd is <see cref="F:System.IntPtr.Zero" />, both window messages and thread messages are
                    processed.
                </para>
                <para>
                    If hWnd is -1, PeekMessage retrieves only messages on the current thread's message queue whose hwnd value is
                    NULL, that is, thread messages as posted by <see cref="M:PInvoke.User32.PostMessage(System.IntPtr,PInvoke.User32.WindowMessage,System.Void*,System.Void*)" /> (when the hWnd parameter is
                    <see cref="F:System.IntPtr.Zero" />) or <see cref="M:PInvoke.User32.PostThreadMessage(System.Int32,PInvoke.User32.WindowMessage,System.IntPtr,System.IntPtr)"/>.
                </para>
            </param>
            <param name="wMsgFilterMin">
                <para>
                    The value of the first message in the range of messages to be examined. Use
                    <see cref="F:PInvoke.User32.WindowMessage.WM_KEYFIRST" /> to specify the first keyboard message or
                    <see cref="F:PInvoke.User32.WindowMessage.WM_MOUSEFIRST" /> to specify the first mouse message.
                </para>
                <para>
                    If wMsgFilterMin and wMsgFilterMax are both <see cref="F:PInvoke.User32.WindowMessage.WM_NULL" />, PeekMessage returns all
                    available messages (that is, no range filtering is performed).
                </para>
            </param>
            <param name="wMsgFilterMax">
                <para>
                    The value of the last message in the range of messages to be examined. Use
                    <see cref="F:PInvoke.User32.WindowMessage.WM_KEYLAST" /> to specify the last keyboard message or
                    <see cref="F:PInvoke.User32.WindowMessage.WM_MOUSELAST" /> to specify the last mouse message.
                </para>
                <para>
                    If wMsgFilterMin and wMsgFilterMax are both <see cref="F:PInvoke.User32.WindowMessage.WM_NULL" />, PeekMessage returns all
                    available messages (that is, no range filtering is performed).
                </para>
            </param>
            <param name="wRemoveMsg">Specifies how messages are to be handled</param>
            <returns>
                If a message is available, the return value is true.
                <para>If no messages are available, the return value is false.</para>
            </returns>
        </member>
        <member name="M:PInvoke.User32.PostThreadMessage(System.Int32,PInvoke.User32.WindowMessage,System.IntPtr,System.IntPtr)">
            <summary>
                Posts a message to the message queue of the specified thread. It returns without waiting for the thread to process
                the message.
            </summary>
            <param name="idThread">
                The identifier of the thread to which the message is to be posted.
                <para>
                    The function fails if the specified thread does not have a message queue. The system creates a thread's
                    message queue when the thread makes its first call to one of the User or GDI functions.
                </para>
                <para>
                    Message posting is subject to UIPI. The thread of a process can post messages only to posted-message queues
                    of threads in processes of lesser or equal integrity level.
                </para>
                <para>
                    This thread must have the SE_TCB_NAME privilege to post a message to a thread that belongs to a process with
                    the same locally unique identifier (LUID) but is in a different desktop. Otherwise, the function fails and
                    returns <see cref="F:PInvoke.Win32ErrorCode.ERROR_INVALID_THREAD_ID" />.
                </para>
                <para>
                    This thread must either belong to the same desktop as the calling thread or to a process with the same LUID.
                    Otherwise, the function fails and returns <see cref="F:PInvoke.Win32ErrorCode.ERROR_INVALID_THREAD_ID" />.
                </para>
            </param>
            <param name="Msg">The type of message to be posted.</param>
            <param name="wParam">First additional message-specific information.</param>
            <param name="lParam">Second additional message-specific information.</param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />. GetLastError returns
                    <see cref="F:PInvoke.Win32ErrorCode.ERROR_INVALID_THREAD_ID" /> if idThread is not a valid thread identifier, or if the
                    thread specified by idThread does not have a message queue. GetLastError returns
                    <see cref="F:PInvoke.Win32ErrorCode.ERROR_NOT_ENOUGH_QUOTA" /> when the message limit is hit.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.User32.DefWindowProc(System.IntPtr,PInvoke.User32.WindowMessage,System.IntPtr,System.IntPtr)">
            <summary>
                Calls the default window procedure to provide default processing for any window messages that an application does
                not process. This function ensures that every message is processed. DefWindowProc is called with the same
                parameters received by the window procedure.
            </summary>
            <param name="hWnd">A handle to the window procedure that received the message.</param>
            <param name="Msg">The message.</param>
            <param name="wParam">First additional message information. The content of this parameter depends on the value of the <paramref name="Msg" /> parameter.</param>
            <param name="lParam">Second additional message information. The content of this parameter depends on the value of the <paramref name="Msg" /> parameter.</param>
            <returns>The return value is the result of the message processing and depends on the message.</returns>
        </member>
        <member name="M:PInvoke.User32.GetQueueStatus(PInvoke.User32.QueueStatusFlags)">
            <summary>
                Retrieves the type of messages found in the calling thread's message queue.
            </summary>
            <param name="flags">The types of messages for which to check</param>
            <returns>
                The high-order word of the return value indicates the types of messages currently in the queue. The low-order word
                indicates the types of messages that have been added to the queue and that are still in the queue since the last
                call to the <see cref="M:PInvoke.User32.GetQueueStatus(PInvoke.User32.QueueStatusFlags)" />, <see cref="M:PInvoke.User32.GetMessage(PInvoke.User32.MSG*,System.IntPtr,PInvoke.User32.WindowMessage,PInvoke.User32.WindowMessage)" />, or <see cref="M:PInvoke.User32.PeekMessage(PInvoke.User32.MSG*,System.IntPtr,PInvoke.User32.WindowMessage,PInvoke.User32.WindowMessage,PInvoke.User32.PeekMessageRemoveFlags)" /> function.
            </returns>
        </member>
        <member name="M:PInvoke.User32.TranslateMessage(PInvoke.User32.MSG*)">
            <summary>
                Translates virtual-key messages into character messages. The character messages are posted to the calling thread's
                message queue, to be read the next time the thread calls the <see cref="M:PInvoke.User32.GetMessage(PInvoke.User32.MSG*,System.IntPtr,PInvoke.User32.WindowMessage,PInvoke.User32.WindowMessage)" /> or
                <see cref="M:PInvoke.User32.PeekMessage(PInvoke.User32.MSG*,System.IntPtr,PInvoke.User32.WindowMessage,PInvoke.User32.WindowMessage,PInvoke.User32.PeekMessageRemoveFlags)" /> function.
            </summary>
            <param name="lpMsg">
                A pointer to an <see cref="T:PInvoke.User32.MSG" /> structure that contains message information retrieved from the
                calling thread's message queue by using the <see cref="M:PInvoke.User32.GetMessage(PInvoke.User32.MSG*,System.IntPtr,PInvoke.User32.WindowMessage,PInvoke.User32.WindowMessage)" /> or <see cref="M:PInvoke.User32.PeekMessage(PInvoke.User32.MSG*,System.IntPtr,PInvoke.User32.WindowMessage,PInvoke.User32.WindowMessage,PInvoke.User32.PeekMessageRemoveFlags)" /> function.
            </param>
            <returns>
                If the message is translated (that is, a character message is posted to the thread's message queue), the return
                value is nonzero.
                <para>
                    If the message is <see cref="F:PInvoke.User32.WindowMessage.WM_KEYDOWN" />, <see cref="F:PInvoke.User32.WindowMessage.WM_KEYUP" />,
                    <see cref="F:PInvoke.User32.WindowMessage.WM_SYSKEYDOWN" />, or
                    <see cref="F:PInvoke.User32.WindowMessage.WM_SYSKEYUP" />, the return value is nonzero, regardless of the translation.
                </para>
                <para>
                    If the message is not translated (that is, a character message is not posted to the thread's message queue),
                    the return value is zero.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.User32.DispatchMessage(PInvoke.User32.MSG*)">
            <summary>
                Dispatches a message to a window procedure. It is typically used to dispatch a message retrieved by the
                <see cref="M:PInvoke.User32.GetMessage(PInvoke.User32.MSG*,System.IntPtr,PInvoke.User32.WindowMessage,PInvoke.User32.WindowMessage)" /> function.
            </summary>
            <param name="lpMsg">A pointer to a structure that contains the message.</param>
            <returns>
                The return value specifies the value returned by the window procedure. Although its meaning depends on the
                message being dispatched, the return value generally is ignored.
            </returns>
        </member>
        <member name="M:PInvoke.User32.PostQuitMessage(System.Int32)">
            <summary>
                Indicates to the system that a thread has made a request to terminate (quit). It is typically used in response to a
                <see cref="F:PInvoke.User32.WindowMessage.WM_DESTROY" /> message.
            </summary>
            <param name="nExitCode">
                The application exit code. This value is used as the wParam parameter of the
                <see cref="F:PInvoke.User32.WindowMessage.WM_QUIT" /> message.
            </param>
        </member>
        <member name="M:PInvoke.User32.IsDialogMessage(System.IntPtr,PInvoke.User32.MSG*)">
            <summary>
                Determines whether a message is intended for the specified dialog box and, if it is, processes the message.
            </summary>
            <param name="hDlg">A handle to the dialog box.</param>
            <param name="lpMsg">A pointer to an <see cref="T:PInvoke.User32.MSG" /> structure that contains the message to be checked.</param>
            <returns>
                If the message has been processed, the return value is nonzero.
                <para>If the message has not been processed, the return value is zero.</para>
            </returns>
        </member>
        <member name="M:PInvoke.User32.LoadString(System.IntPtr,System.UInt32,System.Char*@,System.Int32)">
            <summary>
                Loads a string resource from the executable file associated with a specified module, copies the string into
                a buffer, and appends a terminating null character.
            </summary>
            <param name="hInstance">
                A handle to an instance of the module whose executable file contains the string resource. To get the handle
                to the application itself, call the <see cref="M:PInvoke.Kernel32.GetModuleHandle(System.String)"/> function with NULL.
            </param>
            <param name="uID">
                The identifier of the string to be loaded.
            </param>
            <param name="lpBuffer">
                The buffer is to receive the string. Must be of sufficient length to hold a pointer (8 bytes).
            </param>
            <param name="cchBufferMax">
                The size of the buffer, in characters. The string is truncated and null-terminated if it is longer than the
                number of characters specified. If this parameter is 0, then lpBuffer receives a read-only pointer to the
                resource itself.
            </param>
            <returns>
                If the function succeeds, the return value is the number of characters copied into the buffer, not
                including the terminating null character, or zero if the string resource does not exist. To get extended
                error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.User32.GetWindowTextLength(System.IntPtr)">
            <summary>
            Retrieves the length, in characters, of the specified window's title bar text (if the window has a title bar).
            If the specified window is a control, the function retrieves the length of the text within the control. However,
            GetWindowTextLength cannot retrieve the length of the text of an edit control in another application.
            </summary>
            <param name="hWnd">A handle to the window or control.</param>
            <returns>
            If the function succeeds, the return value is the length, in characters, of the text. Under certain
            conditions, this value may actually be greater than the length of the text. For more information, see the following
            Remarks section.
            <para>If the window has no text, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:PInvoke.User32.GetWindowText(System.IntPtr,System.Char*,System.Int32)">
            <summary>
            Copies the text of the specified window's title bar (if it has one) into a buffer. If the specified window is
            a control, the text of the control is copied. However, GetWindowText cannot retrieve the text of a control in another
            application.
            </summary>
            <param name="hWnd">A handle to the window or control containing the text.</param>
            <param name="lpString">
            The buffer that will receive the text. If the string is as long or longer than the buffer, the
            string is truncated and terminated with a null character.
            </param>
            <param name="nMaxCount">
            The maximum number of characters to copy to the buffer, including the null character. If the
            text exceeds this limit, it is truncated.
            </param>
            <returns>
            If the function succeeds, the return value is the length, in characters, of the copied string, not including
            the terminating null character. If the window has no title bar or text, if the title bar is empty, or if the window or
            control handle is invalid, the return value is zero. To get extended error information, call GetLastError.
            <para>This function cannot retrieve the text of an edit control in another application.</para>
            </returns>
        </member>
        <member name="M:PInvoke.User32.SetWindowText(System.IntPtr,System.String)">
            <summary>
            Changes the text of the specified window's title bar (if it has one). If the specified window is a control, the text of the control is changed. However, SetWindowText cannot change the text of a control in another application.
            </summary>
            <param name="hWnd">A handle to the window or control whose text is to be changed. </param>
            <param name="lpString">The new title or control text. </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:PInvoke.User32.GetTopWindow(System.IntPtr)">
            <summary>
            Examines the Z order of the child windows associated with the specified parent window and retrieves a handle to the child window at the top of the Z order.
            </summary>
            <param name="hWnd">A handle to the parent window whose child windows are to be examined. If this parameter is NULL, the function returns a handle to the window at the top of the Z order.</param>
            <returns>
            If the function succeeds, the return value is a handle to the child window at the top of the Z order. If the specified window has no child windows, the return value is NULL. To get extended error information, use the GetLastError function.
            </returns>
        </member>
        <member name="M:PInvoke.User32.GetWindow(System.IntPtr,PInvoke.User32.GetWindowCommands)">
            <summary>
            Retrieves a handle to a window that has the specified relationship (Z-Order or owner) to the specified window.
            </summary>
            <param name="hWnd">A handle to a window. The window handle retrieved is relative to this window, based on the value of the wCmd parameter. </param>
            <param name="wCmd">The relationship between the specified window and the window whose handle is to be retrieved.</param>
            <returns>If the function succeeds, the return value is a handle to the next (or previous) window. If there is no next (or previous) window, the return value is NULL. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:PInvoke.User32.GetNextWindow(System.IntPtr,PInvoke.User32.GetNextWindowCommands)">
            <summary>
            Retrieves a handle to the next or previous window in the Z-Order. The next window is below the specified window; the previous window is above.
            If the specified window is a topmost window, the function searches for a topmost window. If the specified window is a top-level window, the function searches for a top-level window. If the specified window is a child window, the function searches for a child window.
            </summary>
            <param name="hWnd">A handle to a window. The window handle retrieved is relative to this window, based on the value of the wCmd parameter. </param>
            <param name="wCmd">Indicates whether the function returns a handle to the next window or the previous window.</param>
            <returns>If the function succeeds, the return value is a handle to the next (or previous) window. If there is no next (or previous) window, the return value is NULL. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:PInvoke.User32.SetCursorPos(System.Int32,System.Int32)">
            <summary>
            Moves the cursor to the specified screen coordinates. If the new coordinates are not within the screen
            rectangle set by the most recent ClipCursor function call, the system automatically adjusts the coordinates so that the
            cursor stays within the rectangle.
            </summary>
            <param name="X">The new x-coordinate of the cursor, in screen coordinates.</param>
            <param name="Y">The new y-coordinate of the cursor, in screen coordinates.</param>
            <returns>Returns nonzero if successful or zero otherwise. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:PInvoke.User32.GetCursorPos(PInvoke.POINT*)">
            <summary>
            Retrieves the position of the mouse cursor, in screen coordinates.
            </summary>
            <param name="lpPoint">A pointer to a POINT structure that receives the screen coordinates of the cursor.</param>
            <returns>Returns nonzero if successful or zero otherwise. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:PInvoke.User32.WindowFromPoint(PInvoke.POINT)">
            <summary>
            Retrieves a handle to the window that contains the specified point.
            </summary>
            <param name="Point">The point to be checked.</param>
            <returns>The return value is a handle to the window that contains the point. If no window exists at the given point, the return value is <see cref="F:System.IntPtr.Zero"/>. If the point is over a static text control, the return value is a handle to the window under the static text control.</returns>
        </member>
        <member name="M:PInvoke.User32.GetWindowPlacement(System.IntPtr,PInvoke.User32.WINDOWPLACEMENT*)">
            <summary>Retrieves the show state and the restored, minimized, and maximized positions of the specified window.</summary>
            <param name="hWnd">A handle to the window.</param>
            <param name="lpwndpl">
            A pointer to the WINDOWPLACEMENT structure that receives the show state and position information.
            Before calling GetWindowPlacement, set the length member to sizeof(WINDOWPLACEMENT). GetWindowPlacement fails if
            lpwndpl-> length is not set correctly.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:PInvoke.User32.CreateWindowEx(PInvoke.User32.WindowStylesEx,System.String,System.String,PInvoke.User32.WindowStyles,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr,System.IntPtr,System.Void*)">
            <summary>
            Creates an overlapped, pop-up, or child window with an
            extended window style; otherwise, this function is identical to the CreateWindow function.
            </summary>
            <param name="dwExStyle">Specifies the extended window style of the window being created.</param>
            <param name="lpClassName">
            Pointer to a null-terminated string that specifies
            the window class name. The class name can be any name registered with RegisterClass or
            RegisterClassEx, provided that the module that registers the class is also the module
            that creates the window. The class name can also be any of the predefined system class names.
            </param>
            <param name="lpWindowName">
            Pointer to a null-terminated string that specifies the window name. If the window style
            specifies a title bar, the window title pointed to by lpWindowName is displayed in the
            title bar. When using CreateWindow to create controls, such as buttons, check boxes, and
            static controls, use lpWindowName to specify the text of the control. When creating a
            static control with the SS_ICON style, use lpWindowName to specify the icon name or
            identifier. To specify an identifier, use the syntax "#num".
            </param>
            <param name="dwStyle">
            Specifies the style of the window being created. This parameter can be a combination of
            window styles, plus the control styles indicated in the Remarks section.
            </param>
            <param name="x">
            Specifies the initial horizontal position of the window. For an overlapped or pop-up
            window, the x parameter is the initial x-coordinate of the window's upper-left corner, in
            screen coordinates. For a child window, x is the x-coordinate of the upper-left corner of
            the window relative to the upper-left corner of the parent window's client area. If x is
            set to CW_USEDEFAULT, the system selects the default position for the window's upper-left
            corner and ignores the y parameter. CW_USEDEFAULT is valid only for overlapped windows;
            if it is specified for a pop-up or child window, the x and y parameters are set to zero.
            </param>
            <param name="y">
            Specifies the initial vertical position of the window. For an overlapped or pop-up
            window, the y parameter is the initial y-coordinate of the window's upper-left corner, in
            screen coordinates. For a child window, y is the initial y-coordinate of the upper-left
            corner of the child window relative to the upper-left corner of the parent window's
            client area. For a list box y is the initial y-coordinate of the upper-left corner of the
            list box's client area relative to the upper-left corner of the parent window's client area.
            <para>
            If an overlapped window is created with the WS_VISIBLE style bit set and the x parameter
            is set to CW_USEDEFAULT, then the y parameter determines how the window is shown. If the
            y parameter is CW_USEDEFAULT, then the window manager calls ShowWindow with the SW_SHOW
            flag after the window has been created. If the y parameter is some other value, then the
            window manager calls ShowWindow with that value as the nCmdShow parameter.
            </para>
            </param>
            <param name="nWidth">
            Specifies the width, in device units, of the window. For overlapped windows, nWidth is
            the window's width, in screen coordinates, or CW_USEDEFAULT. If nWidth is CW_USEDEFAULT,
            the system selects a default width and height for the window; the default width extends
            from the initial x-coordinates to the right edge of the screen; the default height
            extends from the initial y-coordinate to the top of the icon area. CW_USEDEFAULT is valid
            only for overlapped windows; if CW_USEDEFAULT is specified for a pop-up or child window,
            the nWidth and nHeight parameter are set to zero.
            </param>
            <param name="nHeight">
            Specifies the height, in device units, of the window. For overlapped windows, nHeight is
            the window's height, in screen coordinates. If the nWidth parameter is set to
            CW_USEDEFAULT, the system ignores nHeight.
            </param>
            <param name="hWndParent">
            Handle to the parent or owner window of the window being created. To create a child
            window or an owned window, supply a valid window handle. This parameter is optional for
            pop-up windows.
            <para>
            Windows 2000/XP: To create a message-only window, supply HWND_MESSAGE or a handle to an
            existing message-only window.
            </para>
            </param>
            <param name="hMenu">
            Handle to a menu, or specifies a child-window identifier, depending on the window style.
            For an overlapped or pop-up window, hMenu identifies the menu to be used with the window;
            it can be NULL if the class menu is to be used. For a child window, hMenu specifies the
            child-window identifier, an integer value used by a dialog box control to notify its
            parent about events. The application determines the child-window identifier; it must be
            unique for all child windows with the same parent window.
            </param>
            <param name="hInstance">
            Handle to the instance of the module to be associated with the window.
            </param>
            <param name="lpParam">
            Pointer to a value to be passed to the window through the CREATESTRUCT structure
            (lpCreateParams member) pointed to by the lParam param of the WM_CREATE message. This
            message is sent to the created window by this function before it returns.
            <para>
            If an application calls CreateWindow to create a MDI client window, lpParam should point
            to a CLIENTCREATESTRUCT structure. If an MDI client window calls CreateWindow to create
            an MDI child window, lpParam should point to a MDICREATESTRUCT structure. lpParam may be
            NULL if no additional data is needed.
            </para>
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the new window.
            <para>
            If the function fails, the return value is NULL. To get extended error information, call GetLastError.
            </para>
            <para>This function typically fails for one of the following reasons:</para>
            <list type="">
            <item>an invalid parameter value</item>
            <item>the system class was registered by a different module</item>
            <item>The WH_CBT hook is installed and returns a failure code</item>
            <item>
            if one of the controls in the dialog template is not registered, or its window window
            procedure fails WM_CREATE or WM_NCCREATE
            </item>
            </list>
            </returns>
        </member>
        <member name="M:PInvoke.User32.CreateWindowEx(PInvoke.User32.WindowStylesEx,System.Int16,System.String,PInvoke.User32.WindowStyles,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr,System.IntPtr,System.Void*)">
            <summary>
            Creates an overlapped, pop-up, or child window with an
            extended window style; otherwise, this function is identical to the CreateWindow function.
            </summary>
            <param name="dwExStyle">Specifies the extended window style of the window being created.</param>
            <param name="lpClassName">
            Pointer to a class atom created by a previous call to the
            RegisterClass or RegisterClassEx function. The atom must be in the low-order word of
            lpClassName; the high-order word must be zero.
            </param>
            <param name="lpWindowName">
            Pointer to a null-terminated string that specifies the window name. If the window style
            specifies a title bar, the window title pointed to by lpWindowName is displayed in the
            title bar. When using CreateWindow to create controls, such as buttons, check boxes, and
            static controls, use lpWindowName to specify the text of the control. When creating a
            static control with the SS_ICON style, use lpWindowName to specify the icon name or
            identifier. To specify an identifier, use the syntax "#num".
            </param>
            <param name="dwStyle">
            Specifies the style of the window being created. This parameter can be a combination of
            window styles, plus the control styles indicated in the Remarks section.
            </param>
            <param name="x">
            Specifies the initial horizontal position of the window. For an overlapped or pop-up
            window, the x parameter is the initial x-coordinate of the window's upper-left corner, in
            screen coordinates. For a child window, x is the x-coordinate of the upper-left corner of
            the window relative to the upper-left corner of the parent window's client area. If x is
            set to CW_USEDEFAULT, the system selects the default position for the window's upper-left
            corner and ignores the y parameter. CW_USEDEFAULT is valid only for overlapped windows;
            if it is specified for a pop-up or child window, the x and y parameters are set to zero.
            </param>
            <param name="y">
            Specifies the initial vertical position of the window. For an overlapped or pop-up
            window, the y parameter is the initial y-coordinate of the window's upper-left corner, in
            screen coordinates. For a child window, y is the initial y-coordinate of the upper-left
            corner of the child window relative to the upper-left corner of the parent window's
            client area. For a list box y is the initial y-coordinate of the upper-left corner of the
            list box's client area relative to the upper-left corner of the parent window's client area.
            <para>
            If an overlapped window is created with the WS_VISIBLE style bit set and the x parameter
            is set to CW_USEDEFAULT, then the y parameter determines how the window is shown. If the
            y parameter is CW_USEDEFAULT, then the window manager calls ShowWindow with the SW_SHOW
            flag after the window has been created. If the y parameter is some other value, then the
            window manager calls ShowWindow with that value as the nCmdShow parameter.
            </para>
            </param>
            <param name="nWidth">
            Specifies the width, in device units, of the window. For overlapped windows, nWidth is
            the window's width, in screen coordinates, or CW_USEDEFAULT. If nWidth is CW_USEDEFAULT,
            the system selects a default width and height for the window; the default width extends
            from the initial x-coordinates to the right edge of the screen; the default height
            extends from the initial y-coordinate to the top of the icon area. CW_USEDEFAULT is valid
            only for overlapped windows; if CW_USEDEFAULT is specified for a pop-up or child window,
            the nWidth and nHeight parameter are set to zero.
            </param>
            <param name="nHeight">
            Specifies the height, in device units, of the window. For overlapped windows, nHeight is
            the window's height, in screen coordinates. If the nWidth parameter is set to
            CW_USEDEFAULT, the system ignores nHeight.
            </param>
            <param name="hWndParent">
            Handle to the parent or owner window of the window being created. To create a child
            window or an owned window, supply a valid window handle. This parameter is optional for
            pop-up windows.
            <para>
            Windows 2000/XP: To create a message-only window, supply HWND_MESSAGE or a handle to an
            existing message-only window.
            </para>
            </param>
            <param name="hMenu">
            Handle to a menu, or specifies a child-window identifier, depending on the window style.
            For an overlapped or pop-up window, hMenu identifies the menu to be used with the window;
            it can be NULL if the class menu is to be used. For a child window, hMenu specifies the
            child-window identifier, an integer value used by a dialog box control to notify its
            parent about events. The application determines the child-window identifier; it must be
            unique for all child windows with the same parent window.
            </param>
            <param name="hInstance">
            Handle to the instance of the module to be associated with the window.
            </param>
            <param name="lpParam">
            Pointer to a value to be passed to the window through the CREATESTRUCT structure
            (lpCreateParams member) pointed to by the lParam param of the WM_CREATE message. This
            message is sent to the created window by this function before it returns.
            <para>
            If an application calls CreateWindow to create a MDI client window, lpParam should point
            to a CLIENTCREATESTRUCT structure. If an MDI client window calls CreateWindow to create
            an MDI child window, lpParam should point to a MDICREATESTRUCT structure. lpParam may be
            NULL if no additional data is needed.
            </para>
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the new window.
            <para>
            If the function fails, the return value is NULL. To get extended error information, call GetLastError.
            </para>
            <para>This function typically fails for one of the following reasons:</para>
            <list type="">
            <item>an invalid parameter value</item>
            <item>the system class was registered by a different module</item>
            <item>The WH_CBT hook is installed and returns a failure code</item>
            <item>
            if one of the controls in the dialog template is not registered, or its window window
            procedure fails WM_CREATE or WM_NCCREATE
            </item>
            </list>
            </returns>
        </member>
        <member name="M:PInvoke.User32.DestroyWindow(System.IntPtr)">
            <summary>
            Destroys the specified window. The function sends WM_DESTROY and WM_NCDESTROY messages to the window to deactivate it and remove the keyboard focus from it. The function also destroys the window's menu, flushes the thread message queue, destroys timers, removes clipboard ownership, and breaks the clipboard viewer chain (if the window is at the top of the viewer chain).
            If the specified window is a parent or owner window, DestroyWindow automatically destroys the associated child or owned windows when it destroys the parent or owner window. The function first destroys child or owned windows, and then it destroys the parent or owner window.
            DestroyWindow also destroys modeless dialog boxes created by the CreateDialog function.
            </summary>
            <param name="hWnd">A handle to the window to be destroyed. </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:PInvoke.User32.DrawText(PInvoke.User32.SafeDCHandle,System.Char*,System.Int32,PInvoke.RECT*,PInvoke.User32.TextFormats)">
            <summary>
            The DrawText function draws formatted text in the specified rectangle.
            It formats the text according to the specified method (expanding tabs, justifying characters, breaking lines, and so forth).
            To specify additional formatting options, use the <see cref="M:PInvoke.User32.DrawTextEx(PInvoke.User32.SafeDCHandle,System.Char*,System.Int32,PInvoke.RECT*,System.UInt32,PInvoke.User32.DRAWTEXTPARAMS*)"/> function.
            </summary>
            <param name="hDC">A handle to the device context.</param>
            <param name="lpString">
            A pointer to the string that specifies the text to be drawn.
            If the <paramref name="nCount"/> parameter is -1, the string must be null-terminated.
            If <paramref name="uFormat"/> includes <see cref="F:PInvoke.User32.TextFormats.DT_MODIFYSTRING"/>, the function could add up to four additional characters to this string.
            The buffer containing the string should be large enough to accommodate these extra characters.
            </param>
            <param name="nCount">The length, in characters, of the string. If nCount is -1, then the lpchText parameter is assumed to be a pointer to a null-terminated string and DrawText computes the character count automatically.</param>
            <param name="lpRect">A pointer to a RECT structure that contains the rectangle (in logical coordinates) in which the text is to be formatted.</param>
            <param name="uFormat">The method of formatting the text.</param>
            <returns>
            If the function succeeds, the return value is the height of the text in logical units.
            If <see cref="F:PInvoke.User32.TextFormats.DT_VCENTER"/> or <see cref="F:PInvoke.User32.TextFormats.DT_BOTTOM"/> is specified, the return value is the offset from <see cref="F:PInvoke.RECT.top"/> (<paramref name="lpRect"/>) to the bottom of the drawn text.
            If the function fails, the return value is zero.</returns>
            <remarks>
            <para>
            The DrawText function uses the device context's selected font, text color, and background color to draw the text.
            Unless the <see cref="F:PInvoke.User32.TextFormats.DT_NOCLIP"/> format is used, DrawText clips the text so that it does not appear outside the specified rectangle.
            Note that text with significant overhang may be clipped, for example, an initial "W" in the text string or text that is in italics.
            All formatting is assumed to have multiple lines unless the <see cref="F:PInvoke.User32.TextFormats.DT_SINGLELINE"/> format is specified.
            </para>
            <para>
            If the selected font is too large for the specified rectangle, the DrawText function does not attempt to substitute a smaller font.
            The text alignment mode for the device context must include the TA_LEFT, TA_TOP, and TA_NOUPDATECP flags.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.DrawTextEx(PInvoke.User32.SafeDCHandle,System.Char*,System.Int32,PInvoke.RECT*,System.UInt32,PInvoke.User32.DRAWTEXTPARAMS*)">
            <summary>
            The DrawTextEx function draws formatted text in the specified rectangle.
            </summary>
            <param name="hdc">A handle to the device context in which to draw.</param>
            <param name="lpchText">
            A pointer to the string that contains the text to draw. If the <paramref name="cchText"/> parameter is -1, the string must be null-terminated.
            If <paramref name="dwDTFormat"/> includes <see cref="F:PInvoke.User32.TextFormats.DT_MODIFYSTRING"/>, the function could add up to four additional characters to this string.
            The buffer containing the string should be large enough to accommodate these extra characters.
            </param>
            <param name="cchText">
            The length of the string pointed to by <paramref name="lpchText"/>.
            If cchText is -1, then the lpchText parameter is assumed to be a pointer to a null-terminated string and DrawTextEx computes the character count automatically.
            </param>
            <param name="lprc">A pointer to a <see cref="T:PInvoke.RECT"/> structure that contains the rectangle, in logical coordinates, in which the text is to be formatted.</param>
            <param name="dwDTFormat">The formatting options.</param>
            <param name="lpDTParams">A pointer to a <see cref="T:PInvoke.User32.DRAWTEXTPARAMS"/> structure that specifies additional formatting options. This parameter can be NULL.</param>
            <returns>
            If the function succeeds, the return value is the text height in logical units.
            If <see cref="F:PInvoke.User32.TextFormats.DT_VCENTER"/> or <see cref="F:PInvoke.User32.TextFormats.DT_BOTTOM"/> is specified, the return value is the offset from  <see cref="F:PInvoke.RECT.top"/> (<paramref name="lprc"/>) to the bottom of the drawn text
            If the function fails, the return value is zero.
            </returns>
        </member>
        <member name="M:PInvoke.User32.EndPaint(System.IntPtr,PInvoke.User32.PAINTSTRUCT*)">
            <summary>
            The EndPaint function marks the end of painting in the specified window. This function is required for each call to the <see cref="M:PInvoke.User32.BeginPaint(System.IntPtr,PInvoke.User32.PAINTSTRUCT*)"/> function, but only after painting is complete.
            </summary>
            <param name="hWnd">Handle to the window that has been repainted.</param>
            <param name="lpPaint">Pointer to a <see cref="T:PInvoke.User32.PAINTSTRUCT"/> structure that contains the painting information retrieved by <see cref="M:PInvoke.User32.BeginPaint(System.IntPtr,PInvoke.User32.PAINTSTRUCT*)"/>.</param>
            <returns>The return value is always nonzero.</returns>
            <remarks>
            If the caret was hidden by <see cref="M:PInvoke.User32.BeginPaint(System.IntPtr,PInvoke.User32.PAINTSTRUCT*)"/>, EndPaint restores the caret to the screen.
            EndPaint releases the display device context that <see cref="M:PInvoke.User32.BeginPaint(System.IntPtr,PInvoke.User32.PAINTSTRUCT*)"/> retrieved.
            </remarks>
        </member>
        <member name="M:PInvoke.User32.SetWindowPlacement(System.IntPtr,PInvoke.User32.WINDOWPLACEMENT*)">
            <summary>
            Sets the show state and the restored, minimized, and maximized positions of the specified window.
            </summary>
            <param name="hWnd">A handle to the window.</param>
            <param name="lpwndpl">A pointer to a WINDOWPLACEMENT structure that specifies the new show state and window positions.
            Before calling SetWindowPlacement, set the <see cref="F:PInvoke.User32.WINDOWPLACEMENT.length"/> member of the <see cref="T:PInvoke.User32.WINDOWPLACEMENT"/> structure to sizeof(WINDOWPLACEMENT).
            SetWindowPlacement fails if the length member is not set correctly.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:PInvoke.User32.keybd_event(System.Byte,System.Byte,PInvoke.User32.KEYEVENTF,System.Void*)">
            <summary>
                Synthesizes a keystroke. The system can use such a synthesized keystroke to generate a WM_KEYUP or WM_KEYDOWN message. The keyboard driver's interrupt handler calls the keybd_event function.
            </summary>
            <param name="bVk">
                A virtual-key code from <see cref="T:PInvoke.User32.VirtualKey" />. The code must be a value in the range 1 to 254.
            </param>
            <param name="bScan">
                A hardware scan code for the key from <see cref="T:PInvoke.User32.ScanCode" />.
            </param>
            <param name="dwFlags">
                Controls various aspects of function operation. This parameter can be one or more of the following values.
            </param>
            <param name="dwExtraInfo">
                An additional value associated with the key stroke.
            </param>
        </member>
        <member name="M:PInvoke.User32.SetLastErrorEx(System.UInt32,System.UInt32)">
            <summary>
            Sets the last-error code for the calling thread.
            Currently, this function is identical to the SetLastError function. The second parameter is ignored.
            </summary>
            <param name="dwErrCode">The last-error code for the thread.</param>
            <param name="dwType">This parameter is ignored.</param>
        </member>
        <member name="M:PInvoke.User32.mouse_event(PInvoke.User32.mouse_eventFlags,System.Int32,System.Int32,System.Int32,System.Void*)">
            <summary>
            The <see cref="M:PInvoke.User32.mouse_event(PInvoke.User32.mouse_eventFlags,System.Int32,System.Int32,System.Int32,System.Void*)"/> function synthesizes mouse motion and button clicks.
            </summary>
            <param name="dwFlags">Controls various aspects of mouse motion and button clicking.</param>
            <param name="dx">The mouse's absolute position along the x-axis or its amount of motion since the last mouse event was generated, depending on the setting of <see cref="F:PInvoke.User32.mouse_eventFlags.MOUSEEVENTF_ABSOLUTE" />. Absolute data is specified as the mouse's actual x-coordinate; relative data is specified as the number of mickeys moved. A mickey is the amount that a mouse has to move for it to report that it has moved.</param>
            <param name="dy">The mouse's absolute position along the y-axis or its amount of motion since the last mouse event was generated, depending on the setting of <see cref="F:PInvoke.User32.mouse_eventFlags.MOUSEEVENTF_ABSOLUTE" />. Absolute data is specified as the mouse's actual y-coordinate; relative data is specified as the number of mickeys moved.</param>
            <param name="dwData">
            If <paramref name="dwFlags"/> contains <see cref="F:PInvoke.User32.mouse_eventFlags.MOUSEEVENTF_WHEEL"/>, then dwData specifies the amount of wheel movement. A positive value indicates that the wheel was rotated forward, away from the user; a negative value indicates that the wheel was rotated backward, toward the user. One wheel click is defined as WHEEL_DELTA, which is 120.
            If <paramref name="dwFlags"/> contains <see cref="F:PInvoke.User32.mouse_eventFlags.MOUSEEVENTF_HWHEEL" />, then dwData specifies the amount of wheel movement. A positive value indicates that the wheel was tilted to the right; a negative value indicates that the wheel was tilted to the left.
            If <paramref name="dwFlags"/> contains <see cref="F:PInvoke.User32.mouse_eventFlags.MOUSEEVENTF_XDOWN" /> or <see cref="F:PInvoke.User32.mouse_eventFlags.MOUSEEVENTF_XUP" />, then <paramref name="dwData"/> specifies which X buttons were pressed or released. This value may be any combination of the following flags.
            If <paramref name="dwFlags"/> is not <see cref="F:PInvoke.User32.mouse_eventFlags.MOUSEEVENTF_WHEEL" />, <see cref="F:PInvoke.User32.mouse_eventFlags.MOUSEEVENTF_XDOWN" />, or <see cref="F:PInvoke.User32.mouse_eventFlags.MOUSEEVENTF_XUP" />, then <paramref name="dwData"/> should be zero.
            </param>
            <param name="dwExtraInfo">An additional value associated with the mouse event. An application calls GetMessageExtraInfo to obtain this extra information.</param>
        </member>
        <member name="M:PInvoke.User32.AdjustWindowRectExForDpi(PInvoke.RECT*,PInvoke.User32.WindowStyles,System.Boolean,PInvoke.User32.WindowStylesEx,System.Int32)">
            <summary>
            Calculates the required size of the window rectangle, based on the desired size of the client rectangle and the provided DPI. This window rectangle can then be passed to the CreateWindowEx function to create a window with a client area of the desired size.
            </summary>
            <param name="lpRect">A pointer to a <see cref="T:PInvoke.RECT"/> structure that contains the coordinates of the top-left and bottom-right corners of the desired client area. When the function returns, the structure contains the coordinates of the top-left and bottom-right corners of the window to accommodate the desired client area.</param>
            <param name="dwStyle">The Window Style of the window whose required size is to be calculated. Note that you cannot specify the <see cref="F:PInvoke.User32.WindowStyles.WS_OVERLAPPED"/> style.</param>
            <param name="bMenu">Indicates whether the window has a menu.</param>
            <param name="dwExStyle">The Extended Window Style of the window whose required size is to be calculated.</param>
            <param name="dpi">The DPI to use for scaling.</param>
            <returns>
            If the function succeeds, the return value is true.
            If the function fails, the return value is false. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.User32.AreDpiAwarenessContextsEqual(System.IntPtr,System.IntPtr)">
            <summary>
            Determines whether two DPI_AWARENESS_CONTEXT values are identical.
            </summary>
            <param name="dpiContextA">The first value to compare.</param>
            <param name="dpiContextB">The second value to compare.</param>
            <returns>Returns true if the values are equal, otherwise false.</returns>
            <remarks>
            A DPI_AWARENESS_CONTEXT contains multiple pieces of information. For example, it includes both the current and the inherited <see cref="T:PInvoke.User32.DPI_AWARENESS"/> values.
            AreDpiAwarenessContextsEqual ignores informational flags and determines if the values are equal. You can't use a direct bitwise comparison because of these informational flags.
            </remarks>
        </member>
        <member name="M:PInvoke.User32.EnableNonClientDpiScaling(System.IntPtr)">
            <summary>
            In high-DPI displays, enables automatic display scaling of the non-client area portions of the specified top-level window. Must be called during the initialization of that window.
            </summary>
            <param name="hwnd">The window that should have automatic scaling enabled.</param>
            <returns>
            If the function succeeds, the return value is true.
            If the function fails, the return value is false. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.User32.GetAwarenessFromDpiAwarenessContext(System.IntPtr)">
            <summary>
            Retrieves the <see cref="T:PInvoke.User32.DPI_AWARENESS"/> value from a DPI_AWARENESS_CONTEXT.
            </summary>
            <param name="dpiAwarenessContext">The DPI_AWARENESS_CONTEXT you want to examine.</param>
            <returns>The <see cref="T:PInvoke.User32.DPI_AWARENESS"/>. If the provided <paramref name="dpiAwarenessContext"/> is null or invalid, this method will return <see cref="F:PInvoke.User32.DPI_AWARENESS.DPI_AWARENESS_INVALID"/>.</returns>
        </member>
        <member name="M:PInvoke.User32.GetDpiForSystem">
            <summary>
            Returns the system DPI.
            </summary>
            <returns>The system DPI value.</returns>
            <remarks>
            The return value will be dependent based upon the calling context. If the current thread has a <see cref="T:PInvoke.User32.DPI_AWARENESS"/> value of <see cref="F:PInvoke.User32.DPI_AWARENESS.DPI_AWARENESS_UNAWARE"/>, the return value will be 96. That is because the current context always assumes a DPI of 96. For any other <see cref="T:PInvoke.User32.DPI_AWARENESS"/> value, the return value will be the actual system DPI.
            You should not cache the system DPI, but should use GetDpiForSystem whenever you need the system DPI value.
            </remarks>
        </member>
        <member name="M:PInvoke.User32.GetDpiForWindow(System.IntPtr)">
            <summary>
            Returns the dots per inch (dpi) value for the associated window.
            </summary>
            <param name="hwnd">The window you want to get information about.</param>
            <returns>The DPI for the window which depends on the <see cref="T:PInvoke.User32.DPI_AWARENESS"/> of the window. An invalid <paramref name="hwnd"/> value will result in a return value of 0.</returns>
            <remarks>
            The following table indicates the return value of GetDpiForWindow based on the <see cref="T:PInvoke.User32.DPI_AWARENESS"/> of the provided <paramref name="hwnd"/>.
            +---------------------------------+-----------------------------------------------------+
            |          DPI_AWARENESS          |                    Return value                     |
            +---------------------------------+-----------------------------------------------------+
            | DPI_AWARENESS_UNAWARE           | 96                                                  |
            | DPI_AWARENESS_SYSTEM_AWARE      | The system DPI.                                     |
            | DPI_AWARENESS_PER_MONITOR_AWARE | The DPI of the monitor where the window is located. |
            +---------------------------------+-----------------------------------------------------+
            </remarks>
        </member>
        <member name="M:PInvoke.User32.GetSystemMetricsForDpi(System.Int32,System.Int32)">
            <summary>
            Retrieves the specified system metric or system configuration setting taking into account a provided DPI.
            </summary>
            <param name="nIndex">The system metric or configuration setting to be retrieved. See <see cref="M:PInvoke.User32.GetSystemMetrics(PInvoke.User32.SystemMetric)"/> for the possible values.</param>
            <param name="dpi">The DPI to use for scaling the metric.</param>
            <returns>
            If the function succeeds, the return value is true.
            If the function fails, the return value is false. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
            <remarks>This function returns the same result as <see cref="M:PInvoke.User32.GetSystemMetrics(PInvoke.User32.SystemMetric)"/> but scales it according to an arbitrary DPI you provide if appropriate.</remarks>
        </member>
        <member name="M:PInvoke.User32.GetThreadDpiAwarenessContext">
            <summary>
            Gets the DPI_AWARENESS_CONTEXT for the current thread.
            </summary>
            <returns>The current DPI_AWARENESS_CONTEXT for the thread.</returns>
            <remarks>
            This method will return the latest DPI_AWARENESS_CONTEXT sent to SetThreadDpiAwarenessContext. If SetThreadDpiAwarenessContext was never called for this thread, then the return value will equal the default DPI_AWARENESS_CONTEXT for the process.
            </remarks>
        </member>
        <member name="M:PInvoke.User32.GetWindowDpiAwarenessContext(System.IntPtr)">
            <summary>
            Returns the DPI_AWARENESS_CONTEXT associated with a window.
            </summary>
            <param name="hwnd">The window to query.</param>
            <returns>The DPI_AWARENESS_CONTEXT for the provided window. If the window is not valid, the return value is NULL.</returns>
            <remarks>
            The return value of GetWindowDpiAwarenessContext is not affected by the <see cref="T:PInvoke.User32.DPI_AWARENESS"/> of the current thread. It only indicates the context of the window specified by the <paramref name="hwnd"/> input parameter.
            </remarks>
        </member>
        <member name="M:PInvoke.User32.IsValidDpiAwarenessContext(System.IntPtr)">
            <summary>
            Determines if a specified DPI_AWARENESS_CONTEXT is valid and supported by the current system.
            </summary>
            <param name="dpiAwarenessContext">The context that you want to determine if it is supported.</param>
            <returns>true if the provided context is supported, otherwise false.</returns>
            <remarks>
            IsValidDpiAwarenessContext determines the validity of any provided DPI_AWARENESS_CONTEXT. You should make sure a context is valid before using SetThreadDpiAwarenessContext to that context.
            An input value of NULL is considered to be an invalid context and will result in a return value of false.
            </remarks>
        </member>
        <member name="M:PInvoke.User32.SetThreadDpiAwarenessContext(System.IntPtr)">
            <summary>
            Set the DPI awareness for the current thread to the provided value.
            </summary>
            <param name="dpiContext">The new DPI_AWARENESS_CONTEXT for the current thread. This context includes the <see cref="T:PInvoke.User32.DPI_AWARENESS"/> value.</param>
            <returns>The old DPI_AWARENESS_CONTEXT for the thread. If the <paramref name="dpiContext"/> is invalid, the thread will not be updated and the return value will be NULL. You can use this value to restore the old DPI_AWARENESS_CONTEXT after overriding it with a predefined value.</returns>
        </member>
        <member name="M:PInvoke.User32.SystemParametersInfoForDpi(PInvoke.User32.SystemParametersInfoAction,System.Int32,System.Void*,PInvoke.User32.SystemParametersInfoFlags,System.Int32)">
            <summary>
            Retrieves the value of one of the system-wide parameters, taking into account the provided DPI value.
            </summary>
            <param name="uiAction">The system-wide parameter to be retrieved. This function is only intended for use with <see cref="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETICONTITLELOGFONT"/>, <see cref="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETICONMETRICS"/>, or <see cref="F:PInvoke.User32.SystemParametersInfoAction.SPI_GETNONCLIENTMETRICS"/>. See <see cref="T:PInvoke.User32.SystemParametersInfoAction"/> for more information on these values.</param>
            <param name="uiParam">A parameter whose usage and format depends on the system parameter being queried. For more information about system-wide parameters, see the <paramref name="uiAction"/> parameter. If not otherwise indicated, you must specify zero for this parameter.</param>
            <param name="pvParam">A parameter whose usage and format depends on the system parameter being queried. For more information about system-wide parameters, see the <paramref name="uiAction"/> parameter. If not otherwise indicated, you must specify NULL for this parameter.</param>
            <param name="fWinIni">Has no effect for with this API. This parameter only has an effect if you're setting parameter.</param>
            <param name="dpi">The DPI to use for scaling the metric.</param>
            <returns>
            If the function succeeds, the return value is true.
            If the function fails, the return value is false. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
            <remarks>
            This function returns a similar result as SystemParametersInfo, but scales it according to an arbitrary DPI you provide (if appropriate). It only scales with the following possible values for uiAction:
                SPI_GETICONTITLELOGFONT, SPI_GETICONMETRICS, SPI_GETNONCLIENTMETRICS.
            Other possible uiAction values do not provide ForDPI behavior, and therefore this function returns 0 if called with them.
            For uiAction values that contain strings within their associated structures, only Unicode(LOGFONTW) strings are supported in this function.
            </remarks>
        </member>
        <member name="M:PInvoke.User32.SetProcessDpiAwarenessContext(System.IntPtr)">
             <summary>
             Sets the current process to a specified dots per inch (dpi) awareness context.
             </summary>
             <param name="dpiAWarenessContext">The DPI awareness value to set.</param>
             <returns>
             If the function succeeds, the return value is true.
             If the function fails, the return value is false. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            
             Possible errors are <see cref="F:PInvoke.Win32ErrorCode.ERROR_INVALID_PARAMETER"/> for an invalid input, and <see cref="F:PInvoke.Win32ErrorCode.ERROR_ACCESS_DENIED"/> if the default API awareness mode for the process has already been set (via a previous API call or within the application manifest).
             </returns>
        </member>
        <member name="M:PInvoke.User32.SetDialogDpiChangeBehavior(System.IntPtr,PInvoke.User32.DIALOG_DPI_CHANGE_BEHAVIORS,PInvoke.User32.DIALOG_DPI_CHANGE_BEHAVIORS)">
             <summary>
             Dialogs in Per-Monitor v2 contexts are automatically DPI scaled. This method lets you customize their DPI change behavior.
             This function works in conjunction with the <see cref="T:PInvoke.User32.DIALOG_DPI_CHANGE_BEHAVIORS"/> enum in order to override the default DPI scaling behavior for
             dialogs.This function is called on a specified dialog, for which the specified flags are individually saved.
             This function does not affect the DPI scaling behavior for the child windows of the dialog in question - that is done with SetDialogControlDpiChangeBehavior.
             </summary>
             <param name="hDlg">A handle for the dialog whose behavior will be modified.</param>
             <param name="mask">A mask specifying the subset of flags to be changed.</param>
             <param name="values">The desired value to be set for the specified subset of flags.</param>
             <returns>
             If the function succeeds, the return value is true.
             If the function fails, the return value is false. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            
             Possible errors are <see cref="F:PInvoke.Win32ErrorCode.ERROR_INVALID_HANDLE"/> for an invalid dialog HWND, and <see cref="F:PInvoke.Win32ErrorCode.ERROR_ACCESS_DENIED"/> if if the dialog belongs to another process.
             </returns>
             <remarks>
             For extensibility, <see cref="T:PInvoke.User32.DIALOG_DPI_CHANGE_BEHAVIORS"/> was modeled as a set of bit-flags representing separate behaviors. This function
             follows the typical two-parameter approach to setting flags, where a mask specifies the subset of the flags to be changed.
             It is not an error to call this API outside of Per Monitor v2 contexts, though the flags will have no effect on the behavior of the
             specified dialog until the context is changed to Per Monitor v2.
             </remarks>
        </member>
        <member name="M:PInvoke.User32.GetDialogDpiChangeBehavior(System.IntPtr)">
            <summary>
            Returns the flags that might have been set on a given dialog by an earlier call to SetDialogDpiChangeBehavior.
            If that function was never called on the dialog, the return value will be 0.
            </summary>
            <param name="hDlg">The handle for the dialog to examine.</param>
            <returns>The flags set on the given dialog. If passed an invalid handle, this function will return 0, and set its last error to <see cref="F:PInvoke.Win32ErrorCode.ERROR_INVALID_HANDLE"/>.</returns>
            <remarks>
            It can be difficult to distinguish between a return value of <see cref="F:PInvoke.User32.DIALOG_DPI_CHANGE_BEHAVIORS.DDC_DEFAULT"/> and the error case, which is zero. To determine between the two, it is recommended that you call <see cref="M:PInvoke.Kernel32.GetLastError"/> to check the error.
            </remarks>
        </member>
        <member name="M:PInvoke.User32.SetDialogControlDpiChangeBehavior(System.IntPtr,PInvoke.User32.DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS,PInvoke.User32.DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS)">
             <summary>
             Overrides the default per-monitor DPI scaling behavior of a child window in a dialog.
             </summary>
             <param name="hwnd">A handle for the window whose behavior will be modified.</param>
             <param name="mask">A mask specifying the subset of flags to be changed.</param>
             <param name="values">The desired value to be set for the specified subset of flags.</param>
             <returns>
             If the function succeeds, the return value is true.
             If the function fails, the return value is false. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            
             Possible errors are <see cref="F:PInvoke.Win32ErrorCode.ERROR_INVALID_HANDLE"/> if passed an invalid HWND, and <see cref="F:PInvoke.Win32ErrorCode.ERROR_ACCESS_DENIED"/> if the windows belongs to another process.
             </returns>
             <remarks>
             The behaviors are specified as values from the <see cref="T:PInvoke.User32.DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS"/> enum. This function follows the typical two-parameter approach
             to setting flags, where a mask specifies the subset of the flags to be changed.
             It is valid to set these behaviors on any window.It does not matter if the window is currently a child of a dialog at the point in time that SetDialogControlDpiChangeBehavior is
             called.The behaviors are retained and will take effect only when the window is an immediate child of a dialog that has per-monitor DPI scaling enabled.
             This API influences individual controls within dialogs.The dialog-wide per-monitor DPI scaling behavior is controlled by SetDialogDpiChangeBehavior.
             </remarks>
        </member>
        <member name="M:PInvoke.User32.GetDialogControlDpiChangeBehavior(System.IntPtr)">
            <summary>
            Retrieves and per-monitor DPI scaling behavior overrides of a child window in a dialog.
            </summary>
            <param name="hWnd">The handle for the window to examine.</param>
            <returns>The flags set on the given window. If passed an invalid handle, this function will return zero, and set its last error to <see cref="F:PInvoke.Win32ErrorCode.ERROR_INVALID_HANDLE"/>.</returns>
            <remarks>It can be difficult to distinguish between a return value of <see cref="F:PInvoke.User32.DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS.DCDC_DEFAULT"/> and the error case, which is zero. To determine between the two, it is recommended that you call <see cref="M:PInvoke.Kernel32.GetLastError"/> to check the error.</remarks>
        </member>
        <member name="M:PInvoke.User32.GetSystemDpiForProcess(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>
            Retrieves the system DPI associated with a given process. This is useful for avoiding compatibility issues that arise from sharing DPI-sensitive information between multiple system-aware processes with different system DPI values.
            </summary>
            <param name="hProcess">The handle for the process to examine. If this value is null, this API behaves identically to <see cref="M:PInvoke.User32.GetDpiForSystem"/>.</param>
            <returns>The process's system DPI value.</returns>
            <remarks>
            The return value will be dependent based upon the process passed as a parameter. If the specified process has a
            <see cref="T:PInvoke.User32.DPI_AWARENESS"/> value of <see cref="F:PInvoke.User32.DPI_AWARENESS.DPI_AWARENESS_UNAWARE"/>, the return value will be 96. That is because the current context always assumes a DPI of 96.
            For any other <see cref="T:PInvoke.User32.DPI_AWARENESS"/> value, the return value will be the actual system DPI of the given process.
            </remarks>
        </member>
        <member name="M:PInvoke.User32.GetDpiFromDpiAwarenessContext(System.IntPtr)">
            <summary>
            Retrieves the DPI from a given DPI_AWARENESS_CONTEXT handle. This enables you to determine the DPI of a thread without needed to examine a window created within that thread.
            </summary>
            <param name="dpiAwarenessContext">The DPI_AWARENESS_CONTEXT handle to examine.</param>
            <returns>The DPI value associated with the DPI_AWARENESS_CONTEXT handle</returns>
            <remarks>
            DPI_AWARENESS_CONTEXT handles associated with values of <see cref="F:PInvoke.User32.DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE"/> and
            <see cref="F:PInvoke.User32.DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2"/> will return a value of 0 for their DPI. This is because the DPI of a
            per-monitor-aware window can change, and the actual DPI cannot be returned without the window's HWND.
            </remarks>
        </member>
        <member name="M:PInvoke.User32.SetThreadDpiHostingBehavior(PInvoke.User32.DPI_HOSTING_BEHAVIOR)">
            <summary>
            Sets the thread's <see cref="T:PInvoke.User32.DPI_HOSTING_BEHAVIOR"/>. This behavior allows windows created in the thread to host child windows with a different DPI_AWARENESS_CONTEXT.
            </summary>
            <param name="dpiHostingBehavior">The new <see cref="T:PInvoke.User32.DPI_HOSTING_BEHAVIOR"/> value for the current thread.</param>
            <returns>
            The previous <see cref="T:PInvoke.User32.DPI_HOSTING_BEHAVIOR"/> for the thread. If the hosting behavior passed in is invalid, the thread will not be updated and the return value will be
            <see cref="F:PInvoke.User32.DPI_HOSTING_BEHAVIOR.DPI_HOSTING_BEHAVIOR_INVALID"/>. You can use this value to restore the old <see cref="T:PInvoke.User32.DPI_HOSTING_BEHAVIOR"/> after overriding it with a predefined value.
            </returns>
            <remarks>
            <para>
            <see cref="T:PInvoke.User32.DPI_HOSTING_BEHAVIOR"/> enables a mixed content hosting behavior, which allows parent windows created in the thread to host child windows with a different DPI_AWARENESS_CONTEXT value.
            This property only effects new windows created within this thread while the mixed hosting behavior is active. A parent window with this hosting behavior is able to host child windows with
            different DPI_AWARENESS_CONTEXT values, regardless of whether the child windows have mixed hosting behavior enabled
            </para>
            <para>
            This hosting behavior does not allow for windows with per-monitor DPI_AWARENESS_CONTEXT values to be hosted until windows with DPI_AWARENESS_CONTEXT values of system or unaware.
            </para>
            <para>
            To avoid unexpected outcomes, a thread's <see cref="T:PInvoke.User32.DPI_HOSTING_BEHAVIOR"/> should be changed to support mixed hosting behaviors only when creating a new window which needs to support those behaviors.
            Once that window is created, the hosting behavior should be switched back to its default value.
            </para>
            <para>
            This API is used to change the thread's <see cref="T:PInvoke.User32.DPI_HOSTING_BEHAVIOR"/> from its default value. This is only necessary if your app needs to host child windows from plugins and third-party
            components that do not support per-monitor-aware context. This is most likely to occur if you are updating complex applications to support per-monitor DPI_AWARENESS_CONTEXT behaviors.
            </para>
            <para>
            Enabling mixed hosting behavior will not automatically adjust the thread's DPI_AWARENESS_CONTEXT to be compatible with legacy content. The thread's awareness context must
            still be manually changed before new windows are created to host such content.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.GetThreadDpiHostingBehavior">
            <summary>
            Retrieves the <see cref="T:PInvoke.User32.DPI_HOSTING_BEHAVIOR"/> from the current thread.
            </summary>
            <returns>The <see cref="T:PInvoke.User32.DPI_HOSTING_BEHAVIOR"/> of the current thread.</returns>
            <remarks>
            This API returns the hosting behavior set by an earlier call of <see cref="M:PInvoke.User32.SetThreadDpiHostingBehavior(PInvoke.User32.DPI_HOSTING_BEHAVIOR)"/>,
            or <see cref="F:PInvoke.User32.DPI_HOSTING_BEHAVIOR.DPI_HOSTING_BEHAVIOR_DEFAULT"/> if no earlier call has been made.
            </remarks>
        </member>
        <member name="M:PInvoke.User32.GetWindowDpiHostingBehavior(System.IntPtr)">
            <summary>
            Returns the <see cref="T:PInvoke.User32.DPI_HOSTING_BEHAVIOR"/> of the specified window.
            </summary>
            <param name="hwnd">The handle for the window to examine.</param>
            <returns>The <see cref="T:PInvoke.User32.DPI_HOSTING_BEHAVIOR"/> of the specified window.</returns>
            <remarks>
            This API allows you to examine the hosting behavior of a window after it has been created. A window's hosting behavior
            is the hosting behavior of the thread in which the window was created, as set by a call to <see cref="M:PInvoke.User32.SetThreadDpiHostingBehavior(PInvoke.User32.DPI_HOSTING_BEHAVIOR)"/>.
            This is a permanent value and cannot be changed after the window is created, even if the thread's hosting behavior is changed.
            </remarks>
        </member>
        <member name="M:PInvoke.User32.AdjustWindowRectEx(PInvoke.RECT*,PInvoke.User32.WindowStyles,System.Boolean,PInvoke.User32.WindowStylesEx)">
            <summary>
            Calculates the required size of the window rectangle, based on the desired size of the client rectangle.
            The window rectangle can then be passed to the CreateWindowEx function to create a window whose client area
            is the desired size.
            </summary>
            <param name="lpRect">
            A pointer to a RECT structure that contains the coordinates of the top-left and bottom-right corners
            of the desired client area. When the function returns, the structure contains the coordinates of the top-left
            and bottom-right corners of the window to accommodate the desired client area.
            </param>
            <param name="dwStyle">
            The window style of the window whose required size is to be calculated. Note that you cannot specify
            the <see cref="F:PInvoke.User32.WindowStyles.WS_OVERLAPPED"/> style.</param>
            <param name="bMenu">Indicates whether the window has a menu.</param>
            <param name="dwExStyle">The extended window style of the window whose required size is to be calculated.</param>
            <returns>
            If the function succeeds, the return value is true.
            If the function fails, the return value is false.
            To get extended error information, call GetLastError.
            </returns>
            <remarks>
            <para>
            A client rectangle is the smallest rectangle that completely encloses a client area.
            A window rectangle is the smallest rectangle that completely encloses the window, which includes
            the client area and the nonclient area.
            </para>
            <para>
            The AdjustWindowRectEx function does not add extra space when a menu bar wraps to two or more rows.
            </para>
            <para>
            The AdjustWindowRectEx function does not take the <see cref="F:PInvoke.User32.WindowStyles.WS_VSCROLL"/> or
            <see cref="F:PInvoke.User32.WindowStyles.WS_HSCROLL"/> styles into account.
            To account for the scroll bars, call the GetSystemMetrics function with <see cref="F:PInvoke.User32.SystemMetric.SM_CXVSCROLL"/> or
            <see cref="F:PInvoke.User32.SystemMetric.SM_CYHSCROLL"/>.
            </para>
            <para>
            This API is not DPI aware, and should not be used if the calling thread is per-monitor DPI aware.
            For the DPI-aware version of this API, see AdjustWindowsRectExForDPI.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.BeginPaint_IntPtr(System.IntPtr,PInvoke.User32.PAINTSTRUCT*)">
            <summary>
            The BeginPaint function prepares the specified window for painting and fills a <see cref="T:PInvoke.User32.PAINTSTRUCT"/> structure with information about the painting.
            </summary>
            <param name="hwnd">Handle to the window to be repainted.</param>
            <param name="lpPaint">Pointer to the <see cref="T:PInvoke.User32.PAINTSTRUCT"/> structure that will receive painting information.</param>
            <returns>
            If the function succeeds, the return value is the handle to a display device context for the specified window.
            If the function fails, the return value is <see cref="F:System.IntPtr.Zero"/>, indicating that no display device context is available..</returns>
            <remarks>
            <para>
            The BeginPaint function automatically sets the clipping region of the device context to exclude any area outside the update region.
            The update region is set by the InvalidateRect or InvalidateRgn function and by the system after sizing, moving, creating, scrolling,
            or any other operation that affects the client area. If the update region is marked for erasing, BeginPaint sends a <see cref="F:PInvoke.User32.WindowMessage.WM_ERASEBKGND"/> message to the window.
            </para>
            <para>
            An application should not call BeginPaint except in response to a <see cref="F:PInvoke.User32.WindowMessage.WM_PAINT"/> message.
            Each call to BeginPaint must have a corresponding call to the <see cref="M:PInvoke.User32.EndPaint(System.IntPtr,PInvoke.User32.PAINTSTRUCT*)"/> function.
            </para>
            <para>
            If the caret is in the area to be painted, BeginPaint automatically hides the caret to prevent it from being erased.
            If the window's class has a background brush, BeginPaint uses that brush to erase the background of the update region before returning.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.GetDC_IntPtr(System.IntPtr)">
            <summary>
            The <see cref="M:PInvoke.User32.GetDC(System.IntPtr)"/> function retrieves a handle to a device context (DC) for the client area of a specified window or for the entire screen.
            You can use the returned handle in subsequent GDI functions to draw in the DC. The device context is an opaque data structure, whose values are used internally by GDI.
            The GetDCEx function is an extension to <see cref="M:PInvoke.User32.GetDC(System.IntPtr)"/>, which gives an application more control over how and whether clipping occurs in the client area.
            </summary>
            <param name="hWnd">A handle to the window whose DC is to be retrieved. If this value is NULL, <see cref="M:PInvoke.User32.GetDC(System.IntPtr)"/> retrieves the DC for the entire screen.</param>
            <returns>
            If the function succeeds, the return value is a handle to the DC for the specified window's client area.
            If the function fails, the return value is <see cref="F:System.IntPtr.Zero"/>.
            </returns>
        </member>
        <member name="M:PInvoke.User32.GetDCEx_IntPtr(System.IntPtr,System.IntPtr,PInvoke.User32.DeviceContextValues)">
            <summary>
            The GetDCEx function retrieves a handle to a device context (DC) for the client area of a specified window or for the entire screen.
            You can use the returned handle in subsequent GDI functions to draw in the DC. The device context is an opaque data structure, whose values are used internally by GDI.
            This function is an extension to the <see cref="M:PInvoke.User32.GetDC(System.IntPtr)"/> function, which gives an application more control over how and whether clipping occurs in the client area.
            </summary>
            <param name="hWnd">A handle to the window whose DC is to be retrieved. If this value is <see cref="F:System.IntPtr.Zero"/>, GetDCEx retrieves the DC for the entire screen.</param>
            <param name="hrgnClip">
            A clipping region that may be combined with the visible region of the DC.
            If the value of flags is <see cref="F:PInvoke.User32.DeviceContextValues.DCX_INTERSECTRGN"/> or <see cref="F:PInvoke.User32.DeviceContextValues.DCX_EXCLUDERGN"/>,
            then the operating system assumes ownership of the region and will automatically delete it when it is no longer needed.
            In this case, the application should not use or delete the region after a successful call to GetDCEx.</param>
            <param name="flags">Specifies how the DC is created.</param>
            <returns>
            If the function succeeds, the return value is the handle to the DC for the specified window. If the function fails, the return value is <see cref="F:System.IntPtr.Zero"/>.
            An invalid value for the hWnd parameter will cause the function to fail.
            </returns>
            <remarks>
            <para>
            Unless the display DC belongs to a window class, the <see cref="M:PInvoke.User32.ReleaseDC(System.IntPtr,System.IntPtr)"/> function must be called to release the DC after painting.
            Also, <see cref="M:PInvoke.User32.ReleaseDC(System.IntPtr,System.IntPtr)"/> must be called from the same thread that called GetDCEx. The number of DCs is limited only by available memory.
            </para>
            <para>
            The function returns a handle to a DC that belongs to the window's class if CS_CLASSDC, CS_OWNDC or CS_PARENTDC was specified as a style in the WNDCLASS structure when the class was registered.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.GetWindowDC_IntPtr(System.IntPtr)">
            <summary>
            The GetWindowDC function retrieves the device context (DC) for the entire window, including title bar, menus, and scroll bars.
            A window device context permits painting anywhere in a window, because the origin of the device context is the upper-left corner of the window instead of the client area.
            GetWindowDC assigns default attributes to the window device context each time it retrieves the device context. Previous attributes are lost.
            </summary>
            <param name="hWnd">
            A handle to the window with a device context that is to be retrieved. If this value is <see cref="F:System.IntPtr.Zero"/>, GetWindowDC retrieves the device context for the entire screen.
            If this parameter is <see cref="F:System.IntPtr.Zero"/>, GetWindowDC retrieves the device context for the primary display monitor.
            To get the device context for other display monitors, use the <see cref="M:PInvoke.User32.EnumDisplayMonitors(System.IntPtr,PInvoke.RECT*,PInvoke.User32.MONITORENUMPROC,System.Void*)"/> and CreateDC functions.</param>
            <returns>
            If the function succeeds, the return value is a handle to a device context for the specified window.
            If the function fails, the return value is <see cref="F:System.IntPtr.Zero"/>, indicating an error or an invalid hWnd parameter.
            </returns>
            <remarks>
            <para>
            GetWindowDC is intended for special painting effects within a window's nonclient area. Painting in nonclient areas of any window is not recommended.
            </para>
            <para>
            The <see cref="M:PInvoke.User32.GetSystemMetrics(PInvoke.User32.SystemMetric)"/> function can be used to retrieve the dimensions of various parts of the nonclient area, such as the title bar, menu, and scroll bars.
            The <see cref="M:PInvoke.User32.GetDC(System.IntPtr)"/> function can be used to retrieve a device context for the entire screen.
            After painting is complete, the <see cref="M:PInvoke.User32.ReleaseDC(System.IntPtr,System.IntPtr)"/> function must be called to release the device context.
            Not releasing the window device context has serious effects on painting requested by applications.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.UnhookWindowsHookEx(System.IntPtr)">
            <summary>
                Removes a hook procedure installed in a hook chain by the
                <see cref="M:PInvoke.User32.SetWindowsHookEx(PInvoke.User32.WindowsHookType,System.IntPtr,System.IntPtr,System.Int32)" /> function.
            </summary>
            <param name="hhk">
                A handle to the hook to be removed. This parameter is a hook handle obtained by a previous call to
                <see cref="M:PInvoke.User32.SetWindowsHookEx(PInvoke.User32.WindowsHookType,System.IntPtr,System.IntPtr,System.Int32)" />.
            </param>
            <returns>
                If the function succeeds, the return value is true.
                <para>If the function fails, the return value is false. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:PInvoke.User32.UnhookWinEvent(System.IntPtr)">
            <summary>
                Removes a hook procedure installed in a hook chain by the
                <see cref="M:PInvoke.User32.SetWinEventHook(PInvoke.User32.WindowsEventHookType,PInvoke.User32.WindowsEventHookType,System.IntPtr,System.IntPtr,System.Int32,System.Int32,PInvoke.User32.WindowsEventHookFlags)" /> function.
            </summary>
            <param name="hWinEventHook">
                A handle to the hook to be removed. This parameter is a hook handle obtained by a previous call to
                <see cref="M:PInvoke.User32.SetWinEventHook(PInvoke.User32.WindowsEventHookType,PInvoke.User32.WindowsEventHookType,System.IntPtr,System.IntPtr,System.Int32,System.Int32,PInvoke.User32.WindowsEventHookFlags)" />.
            </param>
            <returns>
                If the function succeeds, the return value is true.
                <para>If the function fails, the return value is false. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:PInvoke.User32.DestroyCursor(System.IntPtr)">
            <summary>
            Destroys a cursor and frees any memory the cursor occupied. Do not use this function to destroy a shared cursor.
            </summary>
            <param name="hCursor">A handle to the cursor to be destroyed. The cursor must not be in use.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError" />.</returns>
        </member>
        <member name="M:PInvoke.User32.CreateWindowEx(PInvoke.User32.WindowStylesEx,System.IntPtr,System.String,PInvoke.User32.WindowStyles,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr,System.IntPtr,System.Void*)">
            <summary>
            Creates an overlapped, pop-up, or child window with an
            extended window style; otherwise, this function is identical to the CreateWindow function.
            </summary>
            <param name="dwExStyle">Specifies the extended window style of the window being created.</param>
            <param name="lpClassName">
            Pointer to a class atom created by a previous call to the
            RegisterClass or RegisterClassEx function. The atom must be in the low-order word of
            lpClassName; the high-order word must be zero.
            </param>
            <param name="lpWindowName">
            Pointer to a null-terminated string that specifies the window name. If the window style
            specifies a title bar, the window title pointed to by lpWindowName is displayed in the
            title bar. When using CreateWindow to create controls, such as buttons, check boxes, and
            static controls, use lpWindowName to specify the text of the control. When creating a
            static control with the SS_ICON style, use lpWindowName to specify the icon name or
            identifier. To specify an identifier, use the syntax "#num".
            </param>
            <param name="dwStyle">
            Specifies the style of the window being created. This parameter can be a combination of
            window styles, plus the control styles indicated in the Remarks section.
            </param>
            <param name="x">
            Specifies the initial horizontal position of the window. For an overlapped or pop-up
            window, the x parameter is the initial x-coordinate of the window's upper-left corner, in
            screen coordinates. For a child window, x is the x-coordinate of the upper-left corner of
            the window relative to the upper-left corner of the parent window's client area. If x is
            set to CW_USEDEFAULT, the system selects the default position for the window's upper-left
            corner and ignores the y parameter. CW_USEDEFAULT is valid only for overlapped windows;
            if it is specified for a pop-up or child window, the x and y parameters are set to zero.
            </param>
            <param name="y">
            Specifies the initial vertical position of the window. For an overlapped or pop-up
            window, the y parameter is the initial y-coordinate of the window's upper-left corner, in
            screen coordinates. For a child window, y is the initial y-coordinate of the upper-left
            corner of the child window relative to the upper-left corner of the parent window's
            client area. For a list box y is the initial y-coordinate of the upper-left corner of the
            list box's client area relative to the upper-left corner of the parent window's client area.
            <para>
            If an overlapped window is created with the WS_VISIBLE style bit set and the x parameter
            is set to CW_USEDEFAULT, then the y parameter determines how the window is shown. If the
            y parameter is CW_USEDEFAULT, then the window manager calls ShowWindow with the SW_SHOW
            flag after the window has been created. If the y parameter is some other value, then the
            window manager calls ShowWindow with that value as the nCmdShow parameter.
            </para>
            </param>
            <param name="nWidth">
            Specifies the width, in device units, of the window. For overlapped windows, nWidth is
            the window's width, in screen coordinates, or CW_USEDEFAULT. If nWidth is CW_USEDEFAULT,
            the system selects a default width and height for the window; the default width extends
            from the initial x-coordinates to the right edge of the screen; the default height
            extends from the initial y-coordinate to the top of the icon area. CW_USEDEFAULT is valid
            only for overlapped windows; if CW_USEDEFAULT is specified for a pop-up or child window,
            the nWidth and nHeight parameter are set to zero.
            </param>
            <param name="nHeight">
            Specifies the height, in device units, of the window. For overlapped windows, nHeight is
            the window's height, in screen coordinates. If the nWidth parameter is set to
            CW_USEDEFAULT, the system ignores nHeight.
            </param>
            <param name="hWndParent">
            Handle to the parent or owner window of the window being created. To create a child
            window or an owned window, supply a valid window handle. This parameter is optional for
            pop-up windows.
            <para>
            Windows 2000/XP: To create a message-only window, supply HWND_MESSAGE or a handle to an
            existing message-only window.
            </para>
            </param>
            <param name="hMenu">
            Handle to a menu, or specifies a child-window identifier, depending on the window style.
            For an overlapped or pop-up window, hMenu identifies the menu to be used with the window;
            it can be NULL if the class menu is to be used. For a child window, hMenu specifies the
            child-window identifier, an integer value used by a dialog box control to notify its
            parent about events. The application determines the child-window identifier; it must be
            unique for all child windows with the same parent window.
            </param>
            <param name="hInstance">
            Handle to the instance of the module to be associated with the window.
            </param>
            <param name="lpParam">
            Pointer to a value to be passed to the window through the CREATESTRUCT structure
            (lpCreateParams member) pointed to by the lParam param of the WM_CREATE message. This
            message is sent to the created window by this function before it returns.
            <para>
            If an application calls CreateWindow to create a MDI client window, lpParam should point
            to a CLIENTCREATESTRUCT structure. If an MDI client window calls CreateWindow to create
            an MDI child window, lpParam should point to a MDICREATESTRUCT structure. lpParam may be
            NULL if no additional data is needed.
            </para>
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the new window.
            <para>
            If the function fails, the return value is NULL. To get extended error information, call GetLastError.
            </para>
            <para>This function typically fails for one of the following reasons:</para>
            <list type="">
            <item>an invalid parameter value</item>
            <item>the system class was registered by a different module</item>
            <item>The WH_CBT hook is installed and returns a failure code</item>
            <item>
            if one of the controls in the dialog template is not registered, or its window window
            procedure fails WM_CREATE or WM_NCCREATE
            </item>
            </list>
            </returns>
        </member>
        <member name="M:PInvoke.User32.SetWindowLongPtr64(System.IntPtr,PInvoke.User32.WindowLongIndexFlags,System.Void*)">
            <summary>
            Changes an attribute of the specified window. The function also sets a value at the specified
            offset in the extra window memory.
            </summary>
            <param name="hWnd">A handle to the window and, indirectly, the class to which the window belongs.</param>
            <param name="nIndex">The zero-based offset to the value to be set.</param>
            <param name="dwNewLong">The replacement value.</param>
            <returns>
            <para>If the function succeeds, the return value is the previous value of the specified offset.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            <para>If the previous value is zero and the function succeeds, the return value is zero, but the function does
            not clear the last error information. To determine success or failure, clear the last error information by
            calling SetLastError with 0, then call SetWindowLongPtr. Function failure will be indicated by a return value of
            zero and a GetLastError result that is nonzero.</para>
            </returns>
            <remarks>
            When compiling for 32-bit Windows, SetWindowLongPtr is defined as a call to the SetWindowLong function. This
            function is exposed using a helper that conditionally calls SetWindowLong in 32-bit processes.
            </remarks>
        </member>
        <member name="M:PInvoke.User32.BeginPaint(System.IntPtr,PInvoke.User32.PAINTSTRUCT*)">
            <summary>
            The BeginPaint function prepares the specified window for painting and fills a <see cref="T:PInvoke.User32.PAINTSTRUCT"/> structure with information about the painting.
            </summary>
            <param name="hwnd">Handle to the window to be repainted.</param>
            <param name="lpPaint">Pointer to the <see cref="T:PInvoke.User32.PAINTSTRUCT"/> structure that will receive painting information.</param>
            <returns>
            If the function succeeds, the return value is the handle to a display device context for the specified window.
            If the function fails, the return value is <see cref="F:PInvoke.User32.SafeDCHandle.Null"/>, indicating that no display device context is available..</returns>
            <remarks>
            <para>
            The BeginPaint function automatically sets the clipping region of the device context to exclude any area outside the update region.
            The update region is set by the InvalidateRect or InvalidateRgn function and by the system after sizing, moving, creating, scrolling,
            or any other operation that affects the client area. If the update region is marked for erasing, BeginPaint sends a <see cref="F:PInvoke.User32.WindowMessage.WM_ERASEBKGND"/> message to the window.
            </para>
            <para>
            An application should not call BeginPaint except in response to a <see cref="F:PInvoke.User32.WindowMessage.WM_PAINT"/> message.
            Each call to BeginPaint must have a corresponding call to the <see cref="M:PInvoke.User32.EndPaint(System.IntPtr,PInvoke.User32.PAINTSTRUCT*)"/> function.
            </para>
            <para>
            If the caret is in the area to be painted, BeginPaint automatically hides the caret to prevent it from being erased.
            If the window's class has a background brush, BeginPaint uses that brush to erase the background of the update region before returning.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.GetDC(System.IntPtr)">
            <summary>
            The GetDC function retrieves a handle to a device context (DC) for the client area of a specified window or for the entire screen.
            You can use the returned handle in subsequent GDI functions to draw in the DC. The device context is an opaque data structure, whose values are used internally by GDI.
            The GetDCEx function is an extension to GetDC, which gives an application more control over how and whether clipping occurs in the client area.
            </summary>
            <param name="hWnd">A handle to the window whose DC is to be retrieved. If this value is NULL, GetDC retrieves the DC for the entire screen.</param>
            <returns>
            If the function succeeds, the return value is a handle to the DC for the specified window's client area.
            If the function fails, the return value is <see cref="F:PInvoke.User32.SafeDCHandle.Null"/>.
            </returns>
        </member>
        <member name="M:PInvoke.User32.GetDCEx(System.IntPtr,System.IntPtr,PInvoke.User32.DeviceContextValues)">
            <summary>
            The GetDCEx function retrieves a handle to a device context (DC) for the client area of a specified window or for the entire screen.
            You can use the returned handle in subsequent GDI functions to draw in the DC. The device context is an opaque data structure, whose values are used internally by GDI.
            This function is an extension to the <see cref="M:PInvoke.User32.GetDC(System.IntPtr)"/> function, which gives an application more control over how and whether clipping occurs in the client area.
            </summary>
            <param name="hWnd">A handle to the window whose DC is to be retrieved. If this value is <see cref="F:System.IntPtr.Zero"/>, GetDCEx retrieves the DC for the entire screen.</param>
            <param name="hrgnClip">
            A clipping region that may be combined with the visible region of the DC.
            If the value of flags is <see cref="F:PInvoke.User32.DeviceContextValues.DCX_INTERSECTRGN"/> or <see cref="F:PInvoke.User32.DeviceContextValues.DCX_EXCLUDERGN"/>,
            then the operating system assumes ownership of the region and will automatically delete it when it is no longer needed.
            In this case, the application should not use or delete the region after a successful call to GetDCEx.</param>
            <param name="flags">Specifies how the DC is created.</param>
            <returns>
            If the function succeeds, the return value is the handle to the DC for the specified window. If the function fails, the return value is <see cref="F:PInvoke.User32.SafeDCHandle.Null"/>.
            An invalid value for the hWnd parameter will cause the function to fail.
            </returns>
            <remarks>
            <para>
            Unless the display DC belongs to a window class, the <see cref="M:PInvoke.User32.ReleaseDC(System.IntPtr,System.IntPtr)"/> function must be called to release the DC after painting.
            Also, <see cref="M:PInvoke.User32.ReleaseDC(System.IntPtr,System.IntPtr)"/> must be called from the same thread that called GetDCEx. The number of DCs is limited only by available memory.
            </para>
            <para>
            The function returns a handle to a DC that belongs to the window's class if CS_CLASSDC, CS_OWNDC or CS_PARENTDC was specified as a style in the WNDCLASS structure when the class was registered.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.GetWindowDC(System.IntPtr)">
            <summary>
            The GetWindowDC function retrieves the device context (DC) for the entire window, including title bar, menus, and scroll bars.
            A window device context permits painting anywhere in a window, because the origin of the device context is the upper-left corner of the window instead of the client area.
            GetWindowDC assigns default attributes to the window device context each time it retrieves the device context. Previous attributes are lost.
            </summary>
            <param name="hWnd">
            A handle to the window with a device context that is to be retrieved. If this value is <see cref="F:System.IntPtr.Zero"/>, GetWindowDC retrieves the device context for the entire screen.
            If this parameter is <see cref="F:System.IntPtr.Zero"/>, GetWindowDC retrieves the device context for the primary display monitor.
            To get the device context for other display monitors, use the <see cref="M:PInvoke.User32.EnumDisplayMonitors(System.IntPtr,PInvoke.RECT*,PInvoke.User32.MONITORENUMPROC,System.Void*)"/> and CreateDC functions.</param>
            <returns>
            If the function succeeds, the return value is a handle to a device context for the specified window.
            If the function fails, the return value is <see cref="F:PInvoke.User32.SafeDCHandle.Null"/>, indicating an error or an invalid hWnd parameter.
            </returns>
            <remarks>
            <para>
            GetWindowDC is intended for special painting effects within a window's nonclient area. Painting in nonclient areas of any window is not recommended.
            </para>
            <para>
            The <see cref="M:PInvoke.User32.GetSystemMetrics(PInvoke.User32.SystemMetric)"/> function can be used to retrieve the dimensions of various parts of the nonclient area, such as the title bar, menu, and scroll bars.
            The <see cref="M:PInvoke.User32.GetDC(System.IntPtr)"/> function can be used to retrieve a device context for the entire screen.
            After painting is complete, the <see cref="M:PInvoke.User32.ReleaseDC(System.IntPtr,System.IntPtr)"/> function must be called to release the device context.
            Not releasing the window device context has serious effects on painting requested by applications.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.CreateWindow(System.String,System.String,PInvoke.User32.WindowStyles,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr,System.IntPtr,System.Void*)">
            <summary>
            The CreateWindow is identical to the CreateWindowEx function, actually it is a macro on C/C++
            </summary>
            <param name="lpClassName">
            Pointer to a null-terminated string or a class atom created by a previous call to the
            RegisterClass or RegisterClassEx function. The atom must be in the low-order word of
            lpClassName; the high-order word must be zero. If lpClassName is a string, it specifies
            the window class name. The class name can be any name registered with RegisterClass or
            RegisterClassEx, provided that the module that registers the class is also the module
            that creates the window. The class name can also be any of the predefined system class names.
            </param>
            <param name="lpWindowName">
            Pointer to a null-terminated string that specifies the window name. If the window style
            specifies a title bar, the window title pointed to by lpWindowName is displayed in the
            title bar. When using CreateWindow to create controls, such as buttons, check boxes, and
            static controls, use lpWindowName to specify the text of the control. When creating a
            static control with the SS_ICON style, use lpWindowName to specify the icon name or
            identifier. To specify an identifier, use the syntax "#num".
            </param>
            <param name="dwStyle">
            Specifies the style of the window being created. This parameter can be a combination of
            window styles, plus the control styles indicated in the Remarks section.
            </param>
            <param name="x">
            Specifies the initial horizontal position of the window. For an overlapped or pop-up
            window, the x parameter is the initial x-coordinate of the window's upper-left corner, in
            screen coordinates. For a child window, x is the x-coordinate of the upper-left corner of
            the window relative to the upper-left corner of the parent window's client area. If x is
            set to CW_USEDEFAULT, the system selects the default position for the window's upper-left
            corner and ignores the y parameter. CW_USEDEFAULT is valid only for overlapped windows;
            if it is specified for a pop-up or child window, the x and y parameters are set to zero.
            </param>
            <param name="y">
            Specifies the initial vertical position of the window. For an overlapped or pop-up
            window, the y parameter is the initial y-coordinate of the window's upper-left corner, in
            screen coordinates. For a child window, y is the initial y-coordinate of the upper-left
            corner of the child window relative to the upper-left corner of the parent window's
            client area. For a list box y is the initial y-coordinate of the upper-left corner of the
            list box's client area relative to the upper-left corner of the parent window's client area.
            <para>
            If an overlapped window is created with the WS_VISIBLE style bit set and the x parameter
            is set to CW_USEDEFAULT, then the y parameter determines how the window is shown. If the
            y parameter is CW_USEDEFAULT, then the window manager calls ShowWindow with the SW_SHOW
            flag after the window has been created. If the y parameter is some other value, then the
            window manager calls ShowWindow with that value as the nCmdShow parameter.
            </para>
            </param>
            <param name="nWidth">
            Specifies the width, in device units, of the window. For overlapped windows, nWidth is
            the window's width, in screen coordinates, or CW_USEDEFAULT. If nWidth is CW_USEDEFAULT,
            the system selects a default width and height for the window; the default width extends
            from the initial x-coordinates to the right edge of the screen; the default height
            extends from the initial y-coordinate to the top of the icon area. CW_USEDEFAULT is valid
            only for overlapped windows; if CW_USEDEFAULT is specified for a pop-up or child window,
            the nWidth and nHeight parameter are set to zero.
            </param>
            <param name="nHeight">
            Specifies the height, in device units, of the window. For overlapped windows, nHeight is
            the window's height, in screen coordinates. If the nWidth parameter is set to
            CW_USEDEFAULT, the system ignores nHeight.
            </param>
            <param name="hWndParent">
            Handle to the parent or owner window of the window being created. To create a child
            window or an owned window, supply a valid window handle. This parameter is optional for
            pop-up windows.
            <para>
            Windows 2000/XP: To create a message-only window, supply HWND_MESSAGE or a handle to an
            existing message-only window.
            </para>
            </param>
            <param name="hMenu">
            Handle to a menu, or specifies a child-window identifier, depending on the window style.
            For an overlapped or pop-up window, hMenu identifies the menu to be used with the window;
            it can be NULL if the class menu is to be used. For a child window, hMenu specifies the
            child-window identifier, an integer value used by a dialog box control to notify its
            parent about events. The application determines the child-window identifier; it must be
            unique for all child windows with the same parent window.
            </param>
            <param name="hInstance">
            Handle to the instance of the module to be associated with the window.
            </param>
            <param name="lpParam">
            Pointer to a value to be passed to the window through the CREATESTRUCT structure
            (lpCreateParams member) pointed to by the lParam param of the WM_CREATE message. This
            message is sent to the created window by this function before it returns.
            <para>
            If an application calls CreateWindow to create a MDI client window, lpParam should point
            to a CLIENTCREATESTRUCT structure. If an MDI client window calls CreateWindow to create
            an MDI child window, lpParam should point to a MDICREATESTRUCT structure. lpParam may be
            NULL if no additional data is needed.
            </para>
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the new window.
            <para>
            If the function fails, the return value is NULL. To get extended error information, call GetLastError.
            </para>
            <para>This function typically fails for one of the following reasons:</para>
            <list type="">
            <item>an invalid parameter value</item>
            <item>the system class was registered by a different module</item>
            <item>The WH_CBT hook is installed and returns a failure code</item>
            <item>
            if one of the controls in the dialog template is not registered, or its window window
            procedure fails WM_CREATE or WM_NCCREATE
            </item>
            </list>
            </returns>
        </member>
        <member name="M:PInvoke.User32.GetClassName(System.IntPtr,System.Int32)">
            <summary>
            Retrieves the name of the class to which the specified window belongs.
            </summary>
            <param name = "hWnd">A handle to the window and, indirectly, the class to which the window belongs.</param>
            <param name="maxLength">The size of the string to return</param>
            <returns>The class name string.</returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown when an error occurs.</exception>
            <remarks>The maximum length for lpszClassName is 256. See WNDCLASS structure documentation: https://msdn.microsoft.com/en-us/library/windows/desktop/ms633576(v=vs.85).aspx</remarks>
        </member>
        <member name="M:PInvoke.User32.GetClipboardFormatName(System.Int32)">
            <summary>
            Retrieves from the clipboard the name of the specified registered format.
            </summary>
            <param name = "format">The type of format to be retrieved. This parameter must not specify any of the predefined clipboard formats.</param>
            <returns>The format name string.</returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown when an error occurs.</exception>
        </member>
        <member name="M:PInvoke.User32.GetWindowText(System.IntPtr)">
            <summary>
            Get the text of the specified window's title bar (if it has one). If the specified window is a control, the
            text of the control is returned. However, GetWindowText cannot retrieve the text of a control in another application.
            </summary>
            <param name="hWnd">A handle to the window or control containing the text.</param>
            <returns>
            The text of the specified window's title bar. If the specified window is a control, the text of the control is
            returned.
            </returns>
        </member>
        <member name="M:PInvoke.User32.GetCursorPos">
            <summary>
            Retrieves the position of the mouse cursor, in screen coordinates.
            </summary>
            <returns>The screen coordinates of the cursor</returns>
        </member>
        <member name="M:PInvoke.User32.GetWindowPlacement(System.IntPtr)">
            <summary>Retrieves the show state and the restored, minimized, and maximized positions of the specified window.</summary>
            <param name="hWnd">A handle to the window.</param>
            <returns>
            A WINDOWPLACEMENT structure with the show state and position information.
            </returns>
        </member>
        <member name="M:PInvoke.User32.SetWindowLongPtr(System.IntPtr,PInvoke.User32.WindowLongIndexFlags,System.Void*)">
             <summary>
             Changes an attribute of the specified window. The function also sets a value at the specified
             offset in the extra window memory.
             </summary>
             <param name="hWnd">A handle to the window and, indirectly, the class to which the window belongs.
             The SetWindowLongPtr function fails if the process that owns the window specified by the
             <paramref name="hWnd"/> parameter is at a higher process privilege in the UIPI hierarchy than the
             process the calling thread resides in.</param>
             <param name="nIndex">The zero-based offset to the value to be set. Valid values are in the range zero
             through the number of bytes of extra window memory, minus the size of a LONG_PTR. To set any other value,
             specify one of the following values.
            
             <list type="table">
             <listheader><term>Value</term><term>Meaning</term></listheader>
             <item><term>GWL_EXSTYLE(-20)</term><term>Sets a new extended window style.</term></item>
             <item><term>GWLP_HINSTANCE(-6)</term><term>Sets a new application instance handle.</term></item>
             <item><term>GWLP_ID(-12)</term><term>Sets a new identifier of the child window.The window cannot be a top-level window.</term></item>
             <item><term>GWL_STYLE (-16)</term><term>Sets a new window style.</term></item>
             <item><term>GWLP_USERDATA</term><term>Sets the user data associated with the window.This data is intended for use by the application that created the window. Its value is initially zero.</term></item>
             <item><term>GWLP_WNDPROC (-4)</term><term>Sets a new address for the window procedure.</term></item>
             </list>
            
             The following values are also available when the hWnd parameter identifies a dialog box.
            
             <list type="table">
             <listheader><term>Value</term><term>Meaning</term></listheader>
             <item><term>DWLP_DLGPROC (DWLP_MSGRESULT + sizeof(LRESULT))</term><term>Sets the new pointer to the dialog box procedure.</term></item>
             <item><term>DWLP_MSGRESULT (0)</term><term>Sets the return value of a message processed in the dialog box procedure.</term></item>
             <item><term>DWLP_USER (DWLP_DLGPROC + sizeof(DLGPROC))</term><term>Sets new extra info</term></item>
             </list>
            
             </param>
             <param name="dwNewLong">The replacement value.</param>
             <returns>
             <para>If the function succeeds, the return value is the previous value of the specified offset.</para>
             <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
             <para>If the previous value is zero and the function succeeds, the return value is zero, but the function does
             not clear the last error information. To determine success or failure, clear the last error information by
             calling SetLastError with 0, then call SetWindowLongPtr. Function failure will be indicated by a return value of
             zero and a GetLastError result that is nonzero.</para>
             </returns>
             <remarks>
             <list type="bullet">
             <item>The return type, and the type of <paramref name="dwNewLong"/> are both LONG_PTR.
             LONG_PTR is defined as <code>__int64</code> on 64-bit platforms, and it is defined as <code>long</code>
             on 32-bit platforms. This definition fits nicely with now <see cref="T:System.IntPtr"/> works on 32-bit vs. 64-bit
             platforms.</item>
             <item>Windows XP/2000: The SetWindowLongPtr function fails if the window specified by the
             <paramref name="hWnd"/> parameter does not belong to the same process as the calling thread.</item>
             <item>When compiling for 32-bit Windows, SetWindowLongPtr is defined as a call to the SetWindowLong function.</item>
             <item>
             <para>Certain window data is cached, so changes you make using SetWindowLongPtr will not take effect until you call
             the SetWindowPos function.</para>
             <para>If you use SetWindowLongPtr with the <see cref="F:PInvoke.User32.WindowLongIndexFlags.GWLP_WNDPROC"/> index to replace the window procedure,
             the window procedure must conform to the guidelines specified in the description of the WindowProc callback function.</para>
             <para>If you use SetWindowLongPtr with the <see cref="F:PInvoke.User32.WindowLongIndexFlags.DWLP_MSGRESULT"/> index to set the return value for a
             message processed by a dialog box procedure, the dialog box procedure should return TRUE directly afterward. Otherwise, if you call
             any function that results in your dialog box procedure receiving a window message, the nested window message could overwrite the return value
             you set by using <see cref="F:PInvoke.User32.WindowLongIndexFlags.DWLP_MSGRESULT"/>.</para>
             <para>Calling SetWindowLongPtr with the <see cref="F:PInvoke.User32.WindowLongIndexFlags.GWLP_WNDPROC"/> index creates a subclass of the window
             class used to create the window. An application can subclass a system class, but should not subclass a window class created by another process.
             The SetWindowLongPtr function creates the window subclass by changing the window procedure associated with a particular
             window class, causing the system to call the new window procedure instead of the previous one. An application must pass
             any messages not processed by the new window procedure to the previous window procedure by calling CallWindowProc.
             This allows the application to create a chain of window procedures.</para>
             <para>Reserve extra window memory by specifying a nonzero value in the <see cref="F:PInvoke.User32.WNDCLASSEX.cbWndExtra"/> member of the
             <see cref="T:PInvoke.User32.WNDCLASSEX"/> structure used with the RegisterClassEx function.</para>
             <para>Do not call SetWindowLongPtr with the <see cref="F:PInvoke.User32.WindowLongIndexFlags.GWLP_HWNDPARENT"/> index to change the parent of a
             child window. Instead, use the SetParent function.</para>
             <para>If the window has a class style of <see cref="F:PInvoke.User32.ClassStyles.CS_CLASSDC"/> or <see cref="F:PInvoke.User32.ClassStyles.CS_PARENTDC"/>, do not set
             the extended window styles <see cref="F:PInvoke.User32.WindowStylesEx.WS_EX_COMPOSITED"/> or <see cref="F:PInvoke.User32.WindowStylesEx.WS_EX_LAYERED"/>.</para>
             <para>Calling SetWindowLongPtr to set the style on a progressbar will reset its position.</para>
             </item>
             </list>
             </remarks>
        </member>
        <member name="M:PInvoke.User32.GetClassName(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Retrieves the name of the class to which the specified window belongs.
            </summary>
            <param name = "hWnd">A handle to the window and, indirectly, the class to which the window belongs.</param>
            <param name = "lpClassName">The class name string.</param>
            <param name = "nMaxCount">
            The length of the <paramref name = "lpClassName"/> buffer, in characters. The buffer must be large enough to include the terminating null character; otherwise, the class name string is truncated to <paramref name = "nMaxCount"/>-1 characters.
            </param>
            <returns>
            If the function succeeds, the return value is the number of characters copied to the buffer, not including the terminating null character.
            If the function fails, the return value is zero. To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:PInvoke.User32.GetClassName(System.IntPtr,System.Char[],System.Int32)">
            <summary>
            Retrieves the name of the class to which the specified window belongs.
            </summary>
            <param name = "hWnd">A handle to the window and, indirectly, the class to which the window belongs.</param>
            <param name = "lpClassName">The class name string.</param>
            <param name = "nMaxCount">
            The length of the <paramref name = "lpClassName"/> buffer, in characters. The buffer must be large enough to include the terminating null character; otherwise, the class name string is truncated to <paramref name = "nMaxCount"/>-1 characters.
            </param>
            <returns>
            If the function succeeds, the return value is the number of characters copied to the buffer, not including the terminating null character.
            If the function fails, the return value is zero. To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:PInvoke.User32.SendMessage(System.IntPtr,PInvoke.User32.WindowMessage,System.IntPtr,System.IntPtr)">
            <summary>
            Sends the specified message to a window or windows. The SendMessage function calls the window procedure for the specified window and does not return until the window procedure has processed the message.
            To send a message and return immediately, use the SendMessageCallback or SendNotifyMessage function. To post a message to a thread's message queue and return immediately, use the PostMessage or PostThreadMessage function.
            </summary>
            <param name = "hWnd">
            A handle to the window whose window procedure will receive the message. If this parameter is HWND_BROADCAST ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows.
            Message sending is subject to UIPI. The thread of a process can send messages only to message queues of threads in processes of lesser or equal integrity level.
            </param>
            <param name = "wMsg">
            The message to be sent.
            For lists of the system-provided messages, see <see cref = "T:PInvoke.User32.WindowMessage"/>.
            </param>
            <param name = "wParam">Additional message-specific information.</param>
            <param name = "lParam">Additional message-specific information.</param>
            <returns>The return value specifies the result of the message processing; it depends on the message sent.</returns>
        </member>
        <member name="M:PInvoke.User32.PostMessage(System.IntPtr,PInvoke.User32.WindowMessage,System.IntPtr,System.IntPtr)">
            <summary>
            Places (posts) a message in the message queue associated with the thread that created the specified window and returns without waiting for the thread to process the message.
            To post a message in the message queue associated with a thread, use the PostThreadMessage function.
            </summary>
            <param name = "hWnd">
            A handle to the window whose window procedure is to receive the message.
            </param>
            <param name = "wMsg">
            The message to be posted.
            For lists of the system-provided messages, see <see cref = "T:PInvoke.User32.WindowMessage"/>.
            </param>
            <param name = "wParam">Additional message-specific information.</param>
            <param name = "lParam">Additional message-specific information.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call GetLastError. GetLastError returns ERROR_NOT_ENOUGH_QUOTA when the limit is hit.
            </returns>
        </member>
        <member name="M:PInvoke.User32.LoadCursor(System.IntPtr,System.IntPtr)">
            <summary>
            Loads the specified cursor resource from the executable (.EXE) file associated with an application instance.
            </summary>
            <param name = "hInstance">A handle to an instance of the module whose executable file contains the cursor to be loaded.</param>
            <param name = "lpCursorName">
            The name of the cursor resource to be loaded. Alternatively, this parameter can consist of the resource identifier in the low-order word and zero in the high-order word.
            The <see cref = "M:PInvoke.Kernel32.MAKEINTRESOURCE(System.Int32)"/> macro can also be used to create this value. To use one of the predefined cursors, the application must set the hInstance parameter to NULL and the lpCursorName parameter to one the values defined by <see cref = "T:PInvoke.User32.Cursors"/>.
            </param>
            <returns>
            If the function succeeds, the return value is the handle to the newly loaded cursor.
            If the function fails, the return value is NULL. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
            <remarks>
            Note: This function has been superseded by the LoadImage function.
            </remarks>
        </member>
        <member name="M:PInvoke.User32.LoadCursor(System.IntPtr,System.Char[])">
            <summary>
            Loads the specified cursor resource from the executable (.EXE) file associated with an application instance.
            </summary>
            <param name = "hInstance">A handle to an instance of the module whose executable file contains the cursor to be loaded.</param>
            <param name = "lpCursorName">
            The name of the cursor resource to be loaded. Alternatively, this parameter can consist of the resource identifier in the low-order word and zero in the high-order word.
            The <see cref = "M:PInvoke.Kernel32.MAKEINTRESOURCE(System.Int32)"/> macro can also be used to create this value. To use one of the predefined cursors, the application must set the hInstance parameter to NULL and the lpCursorName parameter to one the values defined by <see cref = "T:PInvoke.User32.Cursors"/>.
            </param>
            <returns>
            If the function succeeds, the return value is the handle to the newly loaded cursor.
            If the function fails, the return value is NULL. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
            <remarks>
            Note: This function has been superseded by the LoadImage function.
            </remarks>
        </member>
        <member name="M:PInvoke.User32.CreateCursor(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            Creates a cursor having the specified size, bit patterns, and hot spot.
            </summary>
            <param name = "hInst">A handle to the current instance of the application creating the cursor.</param>
            <param name = "xHotspot">The horizontal position of the cursor's hot spot.</param>
            <param name = "yHotSpot">The vertical position of the cursor's hot spot.</param>
            <param name = "nWidth">The width of the cursor, in pixels.</param>
            <param name = "nHeight">The height of the cursor, in pixels.</param>
            <param name = "pvANDPlane">An array of bytes that contains the bit values for the AND mask of the cursor, as in a device-dependent monochrome bitmap.</param>
            <param name = "pvXORPlane">An array of bytes that contains the bit values for the XOR mask of the cursor, as in a device-dependent monochrome bitmap.</param>
            <returns>
            If the function succeeds, the return value is a handle to the cursor.
            If the function fails, the return value is NULL. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
            <remarks>
            <para>The <paramref name = "nWidth"/> and <paramref name = "nHeight"/> parameters must specify a width and height that are supported by the current display driver, because the system cannot create cursors of other sizes. To determine the width and height supported by the display driver, use the GetSystemMetrics function, specifying the SM_CXCURSOR or SM_CYCURSOR value.</para>
            <para>Before closing, an application must call the <see cref = "M:PInvoke.User32.DestroyCursor(System.IntPtr)"/> function to free any system resources associated with the cursor.</para>
            <para>This API does not participate in DPI virtualization. The output returned is in terms of physical coordinates, and is not affected by the DPI of the calling thread. Note that the cursor created may still be scaled to match the DPI of any given window it is drawn into.</para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.CreateCursor(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Byte[])">
            <summary>
            Creates a cursor having the specified size, bit patterns, and hot spot.
            </summary>
            <param name = "hInst">A handle to the current instance of the application creating the cursor.</param>
            <param name = "xHotspot">The horizontal position of the cursor's hot spot.</param>
            <param name = "yHotSpot">The vertical position of the cursor's hot spot.</param>
            <param name = "nWidth">The width of the cursor, in pixels.</param>
            <param name = "nHeight">The height of the cursor, in pixels.</param>
            <param name = "pvANDPlane">An array of bytes that contains the bit values for the AND mask of the cursor, as in a device-dependent monochrome bitmap.</param>
            <param name = "pvXORPlane">An array of bytes that contains the bit values for the XOR mask of the cursor, as in a device-dependent monochrome bitmap.</param>
            <returns>
            If the function succeeds, the return value is a handle to the cursor.
            If the function fails, the return value is NULL. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
            <remarks>
            <para>The <paramref name = "nWidth"/> and <paramref name = "nHeight"/> parameters must specify a width and height that are supported by the current display driver, because the system cannot create cursors of other sizes. To determine the width and height supported by the display driver, use the GetSystemMetrics function, specifying the SM_CXCURSOR or SM_CYCURSOR value.</para>
            <para>Before closing, an application must call the <see cref = "M:PInvoke.User32.DestroyCursor(System.IntPtr)"/> function to free any system resources associated with the cursor.</para>
            <para>This API does not participate in DPI virtualization. The output returned is in terms of physical coordinates, and is not affected by the DPI of the calling thread. Note that the cursor created may still be scaled to match the DPI of any given window it is drawn into.</para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.GetCursorInfo(System.IntPtr)">
            <summary>
            Retrieves information about the global cursor.
            </summary>
            <param name = "pci">A pointer to a <see cref = "T:PInvoke.User32.CURSORINFO"/> structure that receives the information. Note that you must set the <see cref = "F:PInvoke.User32.CURSORINFO.cbSize"/> member to sizeof(CURSORINFO) before calling this function.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.User32.GetCursorInfo(PInvoke.User32.CURSORINFO@)">
            <summary>
            Retrieves information about the global cursor.
            </summary>
            <param name = "pci">A pointer to a <see cref = "T:PInvoke.User32.CURSORINFO"/> structure that receives the information. Note that you must set the <see cref = "F:PInvoke.User32.CURSORINFO.cbSize"/> member to sizeof(CURSORINFO) before calling this function.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.User32.LoadImage(System.IntPtr,System.IntPtr,PInvoke.User32.ImageType,System.Int32,System.Int32,PInvoke.User32.LoadImageFlags)">
            <summary>
            Loads an icon, cursor, animated cursor, or bitmap.
            </summary>
            <param name = "hInst">
            A handle to the module of either a DLL or executable (.exe) that contains the image to be loaded. For more information, see <see cref = "M:PInvoke.Kernel32.GetModuleHandle(System.String)"/>. Note that as of 32-bit Windows, an instance handle (HINSTANCE), such as the application instance handle exposed by system function call of WinMain, and a module handle (HMODULE) are the same thing.
            To load an OEM image, set this parameter to NULL.
            To load a stand-alone resource (icon, cursor, or bitmap file)—for example, c:\myimage.bmp—set this parameter to NULL.
            </param>
            <param name = "name">
            The image to be loaded. If the hinst parameter is non-NULL and the fuLoad parameter omits LR_LOADFROMFILE, lpszName specifies the image resource in the hinst module. If the image resource is to be loaded by name from the module, the lpszName parameter is a pointer to a null-terminated string that contains the name of the image resource. If the image resource is to be loaded by ordinal from the module, use the MAKEINTRESOURCE macro to convert the image ordinal into a form that can be passed to the LoadImage function.
            For more information, see the <see href = "https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-loadimagew">Microsoft documentation</see>.
            </param>
            <param name = "type">The type of image to be loaded.</param>
            <param name = "cx">The width, in pixels, of the icon or cursor. If this parameter is zero and the fuLoad parameter is LR_DEFAULTSIZE, the function uses the SM_CXICON or SM_CXCURSOR system metric value to set the width. If this parameter is zero and LR_DEFAULTSIZE is not used, the function uses the actual resource width.</param>
            <param name = "cy">The height, in pixels, of the icon or cursor. If this parameter is zero and the fuLoad parameter is LR_DEFAULTSIZE, the function uses the SM_CYICON or SM_CYCURSOR system metric value to set the height. If this parameter is zero and LR_DEFAULTSIZE is not used, the function uses the actual resource height.</param>
            <param name = "fuLoad">This parameter can be one or more of the values defined by the enum.</param>
            <returns>
            If the function succeeds, the return value is the handle of the newly loaded image.
            If the function fails, the return value is NULL. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.User32.LoadImage(System.IntPtr,System.Char[],PInvoke.User32.ImageType,System.Int32,System.Int32,PInvoke.User32.LoadImageFlags)">
            <summary>
            Loads an icon, cursor, animated cursor, or bitmap.
            </summary>
            <param name = "hInst">
            A handle to the module of either a DLL or executable (.exe) that contains the image to be loaded. For more information, see <see cref = "M:PInvoke.Kernel32.GetModuleHandle(System.String)"/>. Note that as of 32-bit Windows, an instance handle (HINSTANCE), such as the application instance handle exposed by system function call of WinMain, and a module handle (HMODULE) are the same thing.
            To load an OEM image, set this parameter to NULL.
            To load a stand-alone resource (icon, cursor, or bitmap file)—for example, c:\myimage.bmp—set this parameter to NULL.
            </param>
            <param name = "name">
            The image to be loaded. If the hinst parameter is non-NULL and the fuLoad parameter omits LR_LOADFROMFILE, lpszName specifies the image resource in the hinst module. If the image resource is to be loaded by name from the module, the lpszName parameter is a pointer to a null-terminated string that contains the name of the image resource. If the image resource is to be loaded by ordinal from the module, use the MAKEINTRESOURCE macro to convert the image ordinal into a form that can be passed to the LoadImage function.
            For more information, see the <see href = "https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-loadimagew">Microsoft documentation</see>.
            </param>
            <param name = "type">The type of image to be loaded.</param>
            <param name = "cx">The width, in pixels, of the icon or cursor. If this parameter is zero and the fuLoad parameter is LR_DEFAULTSIZE, the function uses the SM_CXICON or SM_CXCURSOR system metric value to set the width. If this parameter is zero and LR_DEFAULTSIZE is not used, the function uses the actual resource width.</param>
            <param name = "cy">The height, in pixels, of the icon or cursor. If this parameter is zero and the fuLoad parameter is LR_DEFAULTSIZE, the function uses the SM_CYICON or SM_CYCURSOR system metric value to set the height. If this parameter is zero and LR_DEFAULTSIZE is not used, the function uses the actual resource height.</param>
            <param name = "fuLoad">This parameter can be one or more of the values defined by the enum.</param>
            <returns>
            If the function succeeds, the return value is the handle of the newly loaded image.
            If the function fails, the return value is NULL. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.User32.LookupIconIdFromDirectory(System.IntPtr,System.Boolean)">
            <summary>
            Searches through icon or cursor data for the icon or cursor that best fits the current display device.
            To specify a desired height or width, use the LookupIconIdFromDirectoryEx function.
            </summary>
            <param name = "presbits">
            The icon or cursor directory data. Because this function does not validate the resource data, it causes a general protection (GP) fault or returns an undefined value if <paramref name = "presbits"/> is not pointing to valid resource data.
            </param>
            <param name = "fIcon">
            Indicates whether an icon or a cursor is sought. If this parameter is TRUE, the function is searching for an icon; if the parameter is FALSE, the function is searching for a cursor.
            </param>
            <returns>
            If the function succeeds, the return value is an integer resource identifier for the icon or cursor that best fits the current display device.
            If the function fails, the return value is zero. To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:PInvoke.User32.LookupIconIdFromDirectory(System.Byte[],System.Boolean)">
            <summary>
            Searches through icon or cursor data for the icon or cursor that best fits the current display device.
            To specify a desired height or width, use the LookupIconIdFromDirectoryEx function.
            </summary>
            <param name = "presbits">
            The icon or cursor directory data. Because this function does not validate the resource data, it causes a general protection (GP) fault or returns an undefined value if <paramref name = "presbits"/> is not pointing to valid resource data.
            </param>
            <param name = "fIcon">
            Indicates whether an icon or a cursor is sought. If this parameter is TRUE, the function is searching for an icon; if the parameter is FALSE, the function is searching for a cursor.
            </param>
            <returns>
            If the function succeeds, the return value is an integer resource identifier for the icon or cursor that best fits the current display device.
            If the function fails, the return value is zero. To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:PInvoke.User32.LookupIconIdFromDirectoryEx(System.IntPtr,System.Boolean,System.Int32,System.Int32,PInvoke.User32.LookupIconIdFromDirectoryExFlags)">
            <summary>
            Searches through icon or cursor data for the icon or cursor that best fits the current display device.
            To specify a desired height or width, use the LookupIconIdFromDirectoryEx function.
            </summary>
            <param name = "presbits">
            The icon or cursor directory data. Because this function does not validate the resource data, it causes a general protection (GP) fault or returns an undefined value if <paramref name = "presbits"/> is not pointing to valid resource data.
            </param>
            <param name = "fIcon">
            Indicates whether an icon or a cursor is sought. If this parameter is TRUE, the function is searching for an icon; if the parameter is FALSE, the function is searching for a cursor.
            </param>
            <param name = "cxDesired">The desired width, in pixels, of the icon. If this parameter is zero, the function uses the SM_CXICON or SM_CXCURSOR system metric value.</param>
            <param name = "cyDesired">The desired height, in pixels, of the icon. If this parameter is zero, the function uses the SM_CYICON or SM_CYCURSOR system metric value.</param>
            <param name = "Flags">A combination of the following values.</param>
            <returns>
            If the function succeeds, the return value is an integer resource identifier for the icon or cursor that best fits the current display device.
            If the function fails, the return value is zero. To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:PInvoke.User32.LookupIconIdFromDirectoryEx(System.Byte[],System.Boolean,System.Int32,System.Int32,PInvoke.User32.LookupIconIdFromDirectoryExFlags)">
            <summary>
            Searches through icon or cursor data for the icon or cursor that best fits the current display device.
            To specify a desired height or width, use the LookupIconIdFromDirectoryEx function.
            </summary>
            <param name = "presbits">
            The icon or cursor directory data. Because this function does not validate the resource data, it causes a general protection (GP) fault or returns an undefined value if <paramref name = "presbits"/> is not pointing to valid resource data.
            </param>
            <param name = "fIcon">
            Indicates whether an icon or a cursor is sought. If this parameter is TRUE, the function is searching for an icon; if the parameter is FALSE, the function is searching for a cursor.
            </param>
            <param name = "cxDesired">The desired width, in pixels, of the icon. If this parameter is zero, the function uses the SM_CXICON or SM_CXCURSOR system metric value.</param>
            <param name = "cyDesired">The desired height, in pixels, of the icon. If this parameter is zero, the function uses the SM_CYICON or SM_CYCURSOR system metric value.</param>
            <param name = "Flags">A combination of the following values.</param>
            <returns>
            If the function succeeds, the return value is an integer resource identifier for the icon or cursor that best fits the current display device.
            If the function fails, the return value is zero. To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:PInvoke.User32.GetClipboardFormatName(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Retrieves the name of the format from the clipboard.
            </summary>
            <param name = "format">The type of format to be retrieved. This parameter must not specify any of the predefined clipboard formats.</param>
            <param name = "lpszFormatName">The format name string.</param>
            <param name = "cchMaxCount">
            The length of the <paramref name = "lpszFormatName"/> buffer, in characters. The buffer must be large enough to include the terminating null character; otherwise, the format name string is truncated to <paramref name = "cchMaxCount"/>-1 characters.
            </param>
            <returns>
            If the function succeeds, the return value is the number of characters copied to the buffer.
            If the function fails, the return value is zero. To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:PInvoke.User32.GetClipboardFormatName(System.Int32,System.Char[],System.Int32)">
            <summary>
            Retrieves the name of the format from the clipboard.
            </summary>
            <param name = "format">The type of format to be retrieved. This parameter must not specify any of the predefined clipboard formats.</param>
            <param name = "lpszFormatName">The format name string.</param>
            <param name = "cchMaxCount">
            The length of the <paramref name = "lpszFormatName"/> buffer, in characters. The buffer must be large enough to include the terminating null character; otherwise, the format name string is truncated to <paramref name = "cchMaxCount"/>-1 characters.
            </param>
            <returns>
            If the function succeeds, the return value is the number of characters copied to the buffer.
            If the function fails, the return value is zero. To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:PInvoke.User32.SendInput(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Synthesizes keystrokes, mouse motions, and button clicks.
            </summary>
            <param name = "nInputs">The number of structures in the <paramref name = "pInputs"/> array.</param>
            <param name = "pInputs">An array of  structures. Each structure represents an event to be inserted into the keyboard or mouse input stream.</param>
            <param name = "cbSize">The size, in bytes, of an <see cref = "T:PInvoke.User32.INPUT"/> structure. If cbSize is not the size of an <see cref = "T:PInvoke.User32.INPUT"/> structure, the function fails.</param>
            <returns>
            The function returns the number of events that it successfully inserted into the keyboard or mouse input stream.
            If the function returns zero, the input was already blocked by another thread. To get extended error information, call GetLastError.
            </returns>
            <remarks>
            This function is subject to UIPI. Applications are permitted to inject input only into applications that are at an equal or lesser integrity level.
            This function fails when it is blocked by UIPI. Note that neither GetLastError nor the return value will indicate the failure was caused by UIPI blocking.
            </remarks>
        </member>
        <member name="M:PInvoke.User32.SendInput(System.Int32,PInvoke.User32.INPUT[],System.Int32)">
            <summary>
            Synthesizes keystrokes, mouse motions, and button clicks.
            </summary>
            <param name = "nInputs">The number of structures in the <paramref name = "pInputs"/> array.</param>
            <param name = "pInputs">An array of  structures. Each structure represents an event to be inserted into the keyboard or mouse input stream.</param>
            <param name = "cbSize">The size, in bytes, of an <see cref = "T:PInvoke.User32.INPUT"/> structure. If cbSize is not the size of an <see cref = "T:PInvoke.User32.INPUT"/> structure, the function fails.</param>
            <returns>
            The function returns the number of events that it successfully inserted into the keyboard or mouse input stream.
            If the function returns zero, the input was already blocked by another thread. To get extended error information, call GetLastError.
            </returns>
            <remarks>
            This function is subject to UIPI. Applications are permitted to inject input only into applications that are at an equal or lesser integrity level.
            This function fails when it is blocked by UIPI. Note that neither GetLastError nor the return value will indicate the failure was caused by UIPI blocking.
            </remarks>
        </member>
        <member name="M:PInvoke.User32.CreateDesktopEx(System.String,System.IntPtr,System.IntPtr,PInvoke.User32.DesktopCreationFlags,PInvoke.Kernel32.ACCESS_MASK,System.IntPtr,System.UInt32,System.IntPtr)">
            <summary>
            Creates a new desktop with the specified heap, associates it with the current window station of the calling process, and assigns it to the calling thread.
            The calling process must have an associated window station, either assigned by the system at process creation time or set by the <see cref = "M:PInvoke.User32.SetProcessWindowStation(PInvoke.User32.SafeWindowStationHandle)"/> function.
            </summary>
            <param name = "lpszDesktop">The name of the desktop to be created. Desktop names are case-insensitive and may not contain backslash characters (\).</param>
            <param name = "lpszDevice">This parameter is reserved and must be <see cref = "F:System.IntPtr.Zero"/></param>
            <param name = "pDevmode">This parameter is reserved and must be <see cref = "F:System.IntPtr.Zero"/>.</param>
            <param name = "dwFlags">Access control flags</param>
            <param name = "dwDesiredAccess">
            The requested access to the desktop. For a list of values, see <see cref = "T:PInvoke.Kernel32.ACCESS_MASK"/>.
            This parameter must include the <see cref = "F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_CREATEWINDOW"/> access right, because internally <see cref = "M:PInvoke.User32.CreateDesktop(System.String,System.String,System.IntPtr,PInvoke.User32.DesktopCreationFlags,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)"/> uses the handle to create a window.
            </param>
            <param name = "lpsa">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that determines whether the returned handle can be inherited by child processes. If lpsa is NULL, the handle cannot be inherited.
            The <see cref = "F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member of the structure specifies a security descriptor for the new desktop. If this parameter is NULL, the desktop inherits its security descriptor from the parent window station.
            </param>
            <param name = "ulHeapSize">The size of the desktop heap, in kilobytes.</param>
            <param name = "pvoid">This parameter is also reserved and must be <see cref = "F:System.IntPtr.Zero"/>.</param>
            <returns>
            If the function succeeds, the return value is a handle to the newly created desktop.
            If the specified desktop already exists, the function succeeds and returns a handle to the existing desktop.
            If the function fails, the return value is an invalid handle.
            </returns>
            <remarks>
            <para>
            If the dwDesiredAccess parameter specifies the READ_CONTROL, WRITE_DAC, or WRITE_OWNER standard access rights, you must also request the DESKTOP_READOBJECTS and DESKTOP_WRITEOBJECTS access rights.
            </para>
            <para>
            The number of desktops that can be created is limited by the size of the system desktop heap, which is 48 MB. Desktop objects use the heap to store resources. You can increase the number of desktops that can be created by reducing the default heap reserved for each desktop in the interactive window station. This value is specified in the SharedSection substring of the following registry value: HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\SubSystems\Windows.
            </para>
            <para>
            The default size of the desktop heap depends on factors such as hardware architecture. To retrieve the size of the desktop heap, call the <see cref = "M:PInvoke.User32.GetUserObjectInformation(System.IntPtr,PInvoke.User32.ObjectInformationType,System.Void*,System.UInt32,System.UInt32*)"/> function with UOI_HEAPSIZE.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.CreateDesktopEx(System.String,System.IntPtr,System.IntPtr,PInvoke.User32.DesktopCreationFlags,PInvoke.Kernel32.ACCESS_MASK,System.Nullable{PInvoke.Kernel32.SECURITY_ATTRIBUTES},System.UInt32,System.IntPtr)">
            <summary>
            Creates a new desktop with the specified heap, associates it with the current window station of the calling process, and assigns it to the calling thread.
            The calling process must have an associated window station, either assigned by the system at process creation time or set by the <see cref = "M:PInvoke.User32.SetProcessWindowStation(PInvoke.User32.SafeWindowStationHandle)"/> function.
            </summary>
            <param name = "lpszDesktop">The name of the desktop to be created. Desktop names are case-insensitive and may not contain backslash characters (\).</param>
            <param name = "lpszDevice">This parameter is reserved and must be <see cref = "F:System.IntPtr.Zero"/></param>
            <param name = "pDevmode">This parameter is reserved and must be <see cref = "F:System.IntPtr.Zero"/>.</param>
            <param name = "dwFlags">Access control flags</param>
            <param name = "dwDesiredAccess">
            The requested access to the desktop. For a list of values, see <see cref = "T:PInvoke.Kernel32.ACCESS_MASK"/>.
            This parameter must include the <see cref = "F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_CREATEWINDOW"/> access right, because internally <see cref = "M:PInvoke.User32.CreateDesktop(System.String,System.String,System.IntPtr,PInvoke.User32.DesktopCreationFlags,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)"/> uses the handle to create a window.
            </param>
            <param name = "lpsa">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that determines whether the returned handle can be inherited by child processes. If lpsa is NULL, the handle cannot be inherited.
            The <see cref = "F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member of the structure specifies a security descriptor for the new desktop. If this parameter is NULL, the desktop inherits its security descriptor from the parent window station.
            </param>
            <param name = "ulHeapSize">The size of the desktop heap, in kilobytes.</param>
            <param name = "pvoid">This parameter is also reserved and must be <see cref = "F:System.IntPtr.Zero"/>.</param>
            <returns>
            If the function succeeds, the return value is a handle to the newly created desktop.
            If the specified desktop already exists, the function succeeds and returns a handle to the existing desktop.
            If the function fails, the return value is an invalid handle.
            </returns>
            <remarks>
            <para>
            If the dwDesiredAccess parameter specifies the READ_CONTROL, WRITE_DAC, or WRITE_OWNER standard access rights, you must also request the DESKTOP_READOBJECTS and DESKTOP_WRITEOBJECTS access rights.
            </para>
            <para>
            The number of desktops that can be created is limited by the size of the system desktop heap, which is 48 MB. Desktop objects use the heap to store resources. You can increase the number of desktops that can be created by reducing the default heap reserved for each desktop in the interactive window station. This value is specified in the SharedSection substring of the following registry value: HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\SubSystems\Windows.
            </para>
            <para>
            The default size of the desktop heap depends on factors such as hardware architecture. To retrieve the size of the desktop heap, call the <see cref = "M:PInvoke.User32.GetUserObjectInformation(System.IntPtr,PInvoke.User32.ObjectInformationType,System.Void*,System.UInt32,System.UInt32*)"/> function with UOI_HEAPSIZE.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.CreateDesktop(System.String,System.String,System.IntPtr,PInvoke.User32.DesktopCreationFlags,PInvoke.Kernel32.ACCESS_MASK,System.IntPtr)">
            <summary>
            Creates a new desktop, associates it with the current window station of the calling process, and assigns it to the calling thread. The calling process must have an associated window station, either assigned by the system at process creation time or set by the <see cref = "M:PInvoke.User32.SetProcessWindowStation(PInvoke.User32.SafeWindowStationHandle)"/> function.
            </summary>
            <param name = "lpszDesktop">The name of the desktop to be created. Desktop names are case-insensitive and may not contain backslash characters (\).</param>
            <param name = "lpszDevice">This parameter is reserved and must be <see cref = "F:System.IntPtr.Zero"/></param>
            <param name = "pDevmode">This parameter is reserved and must be <see cref = "F:System.IntPtr.Zero"/>.</param>
            <param name = "dwFlags">Access control flags</param>
            <param name = "dwDesiredAccess">
            The requested access to the desktop. For a list of values, see <see cref = "T:PInvoke.Kernel32.ACCESS_MASK"/>.
            This parameter must include the <see cref = "F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_CREATEWINDOW"/> access right, because internally <see cref = "M:PInvoke.User32.CreateDesktop(System.String,System.String,System.IntPtr,PInvoke.User32.DesktopCreationFlags,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)"/> uses the handle to create a window.
            </param>
            <param name = "lpsa">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that determines whether the returned handle can be inherited by child processes. If lpsa is NULL, the handle cannot be inherited.
            The <see cref = "F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member of the structure specifies a security descriptor for the new desktop. If this parameter is NULL, the desktop inherits its security descriptor from the parent window station.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the newly created desktop.
            If the specified desktop already exists, the function succeeds and returns a handle to the existing desktop.
            If the function fails, the return value is an invalid handle.
            </returns>
            <remarks>
            <para>
            If the dwDesiredAccess parameter specifies the READ_CONTROL, WRITE_DAC, or WRITE_OWNER standard access rights, you must also request the DESKTOP_READOBJECTS and DESKTOP_WRITEOBJECTS access rights.
            </para>
            <para>
            The number of desktops that can be created is limited by the size of the system desktop heap, which is 48 MB. Desktop objects use the heap to store resources. You can increase the number of desktops that can be created by reducing the default heap reserved for each desktop in the interactive window station. This value is specified in the SharedSection substring of the following registry value: HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\SubSystems\Windows.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.CreateDesktop(System.String,System.String,System.IntPtr,PInvoke.User32.DesktopCreationFlags,PInvoke.Kernel32.ACCESS_MASK,System.Nullable{PInvoke.Kernel32.SECURITY_ATTRIBUTES})">
            <summary>
            Creates a new desktop, associates it with the current window station of the calling process, and assigns it to the calling thread. The calling process must have an associated window station, either assigned by the system at process creation time or set by the <see cref = "M:PInvoke.User32.SetProcessWindowStation(PInvoke.User32.SafeWindowStationHandle)"/> function.
            </summary>
            <param name = "lpszDesktop">The name of the desktop to be created. Desktop names are case-insensitive and may not contain backslash characters (\).</param>
            <param name = "lpszDevice">This parameter is reserved and must be <see cref = "F:System.IntPtr.Zero"/></param>
            <param name = "pDevmode">This parameter is reserved and must be <see cref = "F:System.IntPtr.Zero"/>.</param>
            <param name = "dwFlags">Access control flags</param>
            <param name = "dwDesiredAccess">
            The requested access to the desktop. For a list of values, see <see cref = "T:PInvoke.Kernel32.ACCESS_MASK"/>.
            This parameter must include the <see cref = "F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_CREATEWINDOW"/> access right, because internally <see cref = "M:PInvoke.User32.CreateDesktop(System.String,System.String,System.IntPtr,PInvoke.User32.DesktopCreationFlags,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)"/> uses the handle to create a window.
            </param>
            <param name = "lpsa">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that determines whether the returned handle can be inherited by child processes. If lpsa is NULL, the handle cannot be inherited.
            The <see cref = "F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member of the structure specifies a security descriptor for the new desktop. If this parameter is NULL, the desktop inherits its security descriptor from the parent window station.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the newly created desktop.
            If the specified desktop already exists, the function succeeds and returns a handle to the existing desktop.
            If the function fails, the return value is an invalid handle.
            </returns>
            <remarks>
            <para>
            If the dwDesiredAccess parameter specifies the READ_CONTROL, WRITE_DAC, or WRITE_OWNER standard access rights, you must also request the DESKTOP_READOBJECTS and DESKTOP_WRITEOBJECTS access rights.
            </para>
            <para>
            The number of desktops that can be created is limited by the size of the system desktop heap, which is 48 MB. Desktop objects use the heap to store resources. You can increase the number of desktops that can be created by reducing the default heap reserved for each desktop in the interactive window station. This value is specified in the SharedSection substring of the following registry value: HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\SubSystems\Windows.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.GetUserObjectInformation(System.IntPtr,PInvoke.User32.ObjectInformationType,System.IntPtr,System.UInt32,System.IntPtr)">
            <summary>
            Retrieves information about the specified window station or desktop object.
            </summary>
            <param name = "hObj">A handle to the window station or desktop object. This handle is returned by the <see cref = "M:PInvoke.User32.CreateWindowStation(System.String,PInvoke.User32.WindowStationCreationFlags,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)"/>, <see cref = "M:PInvoke.User32.OpenWindowStation(System.String,System.Boolean,PInvoke.Kernel32.ACCESS_MASK)"/>, <see cref = "M:PInvoke.User32.CreateDesktop(System.String,System.String,System.IntPtr,PInvoke.User32.DesktopCreationFlags,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)"/>, or <see cref = "M:PInvoke.User32.OpenDesktop(System.String,PInvoke.User32.DesktopCreationFlags,System.Boolean,PInvoke.Kernel32.ACCESS_MASK)"/> function.</param>
            <param name = "nIndex">The information to be retrieved.</param>
            <param name = "pvInfo">A pointer to a buffer to receive the object information.</param>
            <param name = "nLength">The size of the buffer pointed to by the <paramref name = "pvInfo"/> parameter, in bytes.</param>
            <param name = "lpnLengthNeeded">
            A pointer to a variable receiving the number of bytes required to store the requested information.
            If this variable's value is greater than the value of the <paramref name = "nLength"/> parameter when the function returns, the function returns false, and none of the information is copied to the <paramref name = "pvInfo"/> buffer.
            If the value of the variable pointed to by lpnLengthNeeded is less than or equal to the value of <paramref name = "nLength"/>, the entire information block is copied.</param>
            <returns>If the function succeeds, the return value is true, if it fails, the return value is false.</returns>
        </member>
        <member name="M:PInvoke.User32.CreateWindowStation(System.String,PInvoke.User32.WindowStationCreationFlags,PInvoke.Kernel32.ACCESS_MASK,System.IntPtr)">
            <summary>
            Creates a window station object, associates it with the calling process, and assigns it to the current session.
            </summary>
            <param name = "lpwinsta">
            The name of the window station to be created. Window station names are case-insensitive and cannot contain backslash characters (\).
            Only members of the Administrators group are allowed to specify a name.
            If lpwinsta is NULL or an empty string, the system forms a window station name using the logon session identifier for the calling process.
            To get this name, call the <see cref = "M:PInvoke.User32.GetUserObjectInformation(System.IntPtr,PInvoke.User32.ObjectInformationType,System.Void*,System.UInt32,System.UInt32*)"/> function.</param>
            <param name = "dwFlags">
            If this parameter is <see cref = "F:PInvoke.User32.WindowStationCreationFlags.CWF_CREATE_ONLY"/> and the window station already exists, the call fails.
            If this flag is not specified and the window station already exists, the function succeeds and returns a new handle to the existing window station.
            Windows XP/2000:  This parameter is reserved and must be zero.
            </param>
            <param name = "dwDesiredAccess">
            The requested access to the window station. For a list of values, see <see cref = "T:PInvoke.Kernel32.ACCESS_MASK"/>.
            In addition, you can specify any of the standard access rights, such as <see cref = "F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.READ_CONTROL"/> or <see cref = "F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.WRITE_DAC"/>, and a combination of the window station-specific access rights.
            </param>
            <param name = "lpsa">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that determines whether the returned handle can be inherited by child processes. If lpsa is NULL, the handle cannot be inherited.
            The <see cref = "F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member of the structure specifies a security descriptor for the new window station.
            If lpsa is NULL, the window station (and any desktops created within the window) gets a security descriptor that grants <see cref = "F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_ALL"/> access to all users.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the newly created window station.
            If the specified window station already exists, the function succeeds and returns a handle to the existing window station.
            If the function fails, the return value is an invalid handle.
            </returns>
            <remarks>After you are done with the handle, you must call <see cref = "M:PInvoke.User32.CloseWindowStation(System.IntPtr)"/> to free the handle.</remarks>
        </member>
        <member name="M:PInvoke.User32.CreateWindowStation(System.String,PInvoke.User32.WindowStationCreationFlags,PInvoke.Kernel32.ACCESS_MASK,System.Nullable{PInvoke.Kernel32.SECURITY_ATTRIBUTES})">
            <summary>
            Creates a window station object, associates it with the calling process, and assigns it to the current session.
            </summary>
            <param name = "lpwinsta">
            The name of the window station to be created. Window station names are case-insensitive and cannot contain backslash characters (\).
            Only members of the Administrators group are allowed to specify a name.
            If lpwinsta is NULL or an empty string, the system forms a window station name using the logon session identifier for the calling process.
            To get this name, call the <see cref = "M:PInvoke.User32.GetUserObjectInformation(System.IntPtr,PInvoke.User32.ObjectInformationType,System.Void*,System.UInt32,System.UInt32*)"/> function.</param>
            <param name = "dwFlags">
            If this parameter is <see cref = "F:PInvoke.User32.WindowStationCreationFlags.CWF_CREATE_ONLY"/> and the window station already exists, the call fails.
            If this flag is not specified and the window station already exists, the function succeeds and returns a new handle to the existing window station.
            Windows XP/2000:  This parameter is reserved and must be zero.
            </param>
            <param name = "dwDesiredAccess">
            The requested access to the window station. For a list of values, see <see cref = "T:PInvoke.Kernel32.ACCESS_MASK"/>.
            In addition, you can specify any of the standard access rights, such as <see cref = "F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.READ_CONTROL"/> or <see cref = "F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.WRITE_DAC"/>, and a combination of the window station-specific access rights.
            </param>
            <param name = "lpsa">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that determines whether the returned handle can be inherited by child processes. If lpsa is NULL, the handle cannot be inherited.
            The <see cref = "F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member of the structure specifies a security descriptor for the new window station.
            If lpsa is NULL, the window station (and any desktops created within the window) gets a security descriptor that grants <see cref = "F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_ALL"/> access to all users.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the newly created window station.
            If the specified window station already exists, the function succeeds and returns a handle to the existing window station.
            If the function fails, the return value is an invalid handle.
            </returns>
            <remarks>After you are done with the handle, you must call <see cref = "M:PInvoke.User32.CloseWindowStation(System.IntPtr)"/> to free the handle.</remarks>
        </member>
        <member name="M:PInvoke.User32.CreateDialogIndirectParam(PInvoke.Kernel32.SafeLibraryHandle,System.IntPtr,System.IntPtr,PInvoke.User32.DialogProc,System.IntPtr)">
            <summary>
                Creates a modeless dialog box from a dialog box template in memory. Before displaying the dialog box, the function
                passes an application-defined value to the dialog box procedure as the lParam parameter of the
                <see cref = "F:PInvoke.User32.WindowMessage.WM_INITDIALOG"/> message. An application can use this value to initialize dialog box
                controls.
            </summary>
            <param name = "hInstance">
                A handle to the module which contains the dialog box template. If this parameter is
                <see cref = "F:PInvoke.Kernel32.SafeLibraryHandle.Null"/>, then the current executable is used.
            </param>
            <param name = "lpTemplate">
                The template CreateDialogIndirectParam uses to create the dialog box. A dialog box template consists of a header
                that describes the dialog box, followed by one or more additional blocks of data that describe each of the controls
                in the dialog box. The template can use either the standard format or the extended format.
                <para>
                    In a standard template, the header is a <see cref = "T:PInvoke.User32.DLGTEMPLATE"/> structure followed by additional
                    variable-length arrays. The data for each control consists of a <see cref = "T:PInvoke.User32.DLGITEMTEMPLATE"/> structure
                    followed by additional variable-length arrays.
                </para>
                <para>
                    In an extended dialog box template, the header uses the DLGTEMPLATEEX format and the control definitions use
                    the DLGITEMTEMPLATEEX format.
                </para>
                <para>
                    After CreateDialogIndirectParam returns, you can free the template, which is only used to get the dialog box
                    started.
                </para>
            </param>
            <param name = "hWndParent">A handle to the window that owns the dialog box.</param>
            <param name = "lpDialogFunc">A pointer to the dialog box procedure.</param>
            <param name = "lParamInit">
                The value to pass to the dialog box in the lParam parameter of the
                <see cref = "F:PInvoke.User32.WindowMessage.WM_INITDIALOG"/> message.
            </param>
            <returns>
                If the function succeeds, the return value is the window handle to the dialog box.
                <para>
                    If the function fails, the return value is <see cref = "F:System.IntPtr.Zero"/>. To get extended error information,
                    call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.User32.GetMessage(System.IntPtr,System.IntPtr,PInvoke.User32.WindowMessage,PInvoke.User32.WindowMessage)">
            <summary>
                Retrieves a message from the calling thread's message queue. The function dispatches incoming sent messages until a
                posted message is available for retrieval.
                <para>
                    Unlike <see cref = "M:PInvoke.User32.GetMessage(PInvoke.User32.MSG*,System.IntPtr,PInvoke.User32.WindowMessage,PInvoke.User32.WindowMessage)"/>, the <see cref = "M:PInvoke.User32.PeekMessage(PInvoke.User32.MSG*,System.IntPtr,PInvoke.User32.WindowMessage,PInvoke.User32.WindowMessage,PInvoke.User32.PeekMessageRemoveFlags)"/> function does not wait for a message to be
                    posted before returning.
                </para>
            </summary>
            <param name = "lpMsg">A pointer to an <see cref = "T:PInvoke.User32.MSG"/> structure that receives message information.</param>
            <param name = "hWnd">
                A handle to the window whose messages are to be retrieved. The window must belong to the current thread.
                <para>
                    If hWnd is <see cref = "F:System.IntPtr.Zero"/>, PeekMessage retrieves messages for any window that belongs to the
                    current thread, and any messages on the current thread's message queue whose hwnd value is NULL (see the MSG
                    structure). Therefore if hWnd is <see cref = "F:System.IntPtr.Zero"/>, both window messages and thread messages are
                    processed.
                </para>
                <para>
                    If hWnd is -1, PeekMessage retrieves only messages on the current thread's message queue whose hwnd value is
                    NULL, that is, thread messages as posted by <see cref = "M:PInvoke.User32.PostMessage(System.IntPtr,PInvoke.User32.WindowMessage,System.Void*,System.Void*)"/>
                    (when the hWnd parameter is <see cref = "F:System.IntPtr.Zero"/>) or <see cref = "M:PInvoke.User32.PostThreadMessage(System.Int32,PInvoke.User32.WindowMessage,System.IntPtr,System.IntPtr)"/>.
                </para>
            </param>
            <param name = "wMsgFilterMin">
                <para>
                    The value of the first message in the range of messages to be examined. Use
                    <see cref = "F:PInvoke.User32.WindowMessage.WM_KEYFIRST"/> to specify the first keyboard message or
                    <see cref = "F:PInvoke.User32.WindowMessage.WM_MOUSEFIRST"/> to specify the first mouse message.
                </para>
                <para>
                    If wMsgFilterMin and wMsgFilterMax are both <see cref = "F:PInvoke.User32.WindowMessage.WM_NULL"/>, PeekMessage returns all
                    available messages (that is, no range filtering is performed).
                </para>
            </param>
            <param name = "wMsgFilterMax">
                <para>
                    The value of the last message in the range of messages to be examined. Use
                    <see cref = "F:PInvoke.User32.WindowMessage.WM_KEYLAST"/> to specify the last keyboard message or
                    <see cref = "F:PInvoke.User32.WindowMessage.WM_MOUSELAST"/> to specify the last mouse message.
                </para>
                <para>
                    If wMsgFilterMin and wMsgFilterMax are both <see cref = "F:PInvoke.User32.WindowMessage.WM_NULL"/>, PeekMessage returns all
                    available messages (that is, no range filtering is performed).
                </para>
            </param>
            <returns>
                If the function retrieves a message other than <see cref = "F:PInvoke.User32.WindowMessage.WM_QUIT"/>, the return value is nonzero.
                <para>If the function retrieves the <see cref = "F:PInvoke.User32.WindowMessage.WM_QUIT"/> message, the return value is zero.</para>
                <para>
                    If there is an error, the return value is -1. For example, the function fails if <paramref name = "hWnd"/> is
                    an invalid window handle or <paramref name = "lpMsg"/> is an invalid pointer. To get extended error information,
                    call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.User32.PeekMessage(System.IntPtr,System.IntPtr,PInvoke.User32.WindowMessage,PInvoke.User32.WindowMessage,PInvoke.User32.PeekMessageRemoveFlags)">
            <summary>
                Dispatches incoming sent messages, checks the thread message queue for a posted message, and retrieves the message
                (if any exist).
            </summary>
            <param name = "lpMsg">A pointer to an <see cref = "T:PInvoke.User32.MSG"/> structure that receives message information.</param>
            <param name = "hWnd">
                A handle to the window whose messages are to be retrieved. The window must belong to the current thread.
                <para>
                    If hWnd is <see cref = "F:System.IntPtr.Zero"/>, PeekMessage retrieves messages for any window that belongs to the
                    current thread, and any messages on the current thread's message queue whose hwnd value is NULL (see the MSG
                    structure). Therefore if hWnd is <see cref = "F:System.IntPtr.Zero"/>, both window messages and thread messages are
                    processed.
                </para>
                <para>
                    If hWnd is -1, PeekMessage retrieves only messages on the current thread's message queue whose hwnd value is
                    NULL, that is, thread messages as posted by <see cref = "M:PInvoke.User32.PostMessage(System.IntPtr,PInvoke.User32.WindowMessage,System.Void*,System.Void*)"/> (when the hWnd parameter is
                    <see cref = "F:System.IntPtr.Zero"/>) or <see cref = "M:PInvoke.User32.PostThreadMessage(System.Int32,PInvoke.User32.WindowMessage,System.IntPtr,System.IntPtr)"/>.
                </para>
            </param>
            <param name = "wMsgFilterMin">
                <para>
                    The value of the first message in the range of messages to be examined. Use
                    <see cref = "F:PInvoke.User32.WindowMessage.WM_KEYFIRST"/> to specify the first keyboard message or
                    <see cref = "F:PInvoke.User32.WindowMessage.WM_MOUSEFIRST"/> to specify the first mouse message.
                </para>
                <para>
                    If wMsgFilterMin and wMsgFilterMax are both <see cref = "F:PInvoke.User32.WindowMessage.WM_NULL"/>, PeekMessage returns all
                    available messages (that is, no range filtering is performed).
                </para>
            </param>
            <param name = "wMsgFilterMax">
                <para>
                    The value of the last message in the range of messages to be examined. Use
                    <see cref = "F:PInvoke.User32.WindowMessage.WM_KEYLAST"/> to specify the last keyboard message or
                    <see cref = "F:PInvoke.User32.WindowMessage.WM_MOUSELAST"/> to specify the last mouse message.
                </para>
                <para>
                    If wMsgFilterMin and wMsgFilterMax are both <see cref = "F:PInvoke.User32.WindowMessage.WM_NULL"/>, PeekMessage returns all
                    available messages (that is, no range filtering is performed).
                </para>
            </param>
            <param name = "wRemoveMsg">Specifies how messages are to be handled</param>
            <returns>
                If a message is available, the return value is true.
                <para>If no messages are available, the return value is false.</para>
            </returns>
        </member>
        <member name="M:PInvoke.User32.TranslateMessage(System.IntPtr)">
            <summary>
                Translates virtual-key messages into character messages. The character messages are posted to the calling thread's
                message queue, to be read the next time the thread calls the <see cref = "M:PInvoke.User32.GetMessage(PInvoke.User32.MSG*,System.IntPtr,PInvoke.User32.WindowMessage,PInvoke.User32.WindowMessage)"/> or
                <see cref = "M:PInvoke.User32.PeekMessage(PInvoke.User32.MSG*,System.IntPtr,PInvoke.User32.WindowMessage,PInvoke.User32.WindowMessage,PInvoke.User32.PeekMessageRemoveFlags)"/> function.
            </summary>
            <param name = "lpMsg">
                A pointer to an <see cref = "T:PInvoke.User32.MSG"/> structure that contains message information retrieved from the
                calling thread's message queue by using the <see cref = "M:PInvoke.User32.GetMessage(PInvoke.User32.MSG*,System.IntPtr,PInvoke.User32.WindowMessage,PInvoke.User32.WindowMessage)"/> or <see cref = "M:PInvoke.User32.PeekMessage(PInvoke.User32.MSG*,System.IntPtr,PInvoke.User32.WindowMessage,PInvoke.User32.WindowMessage,PInvoke.User32.PeekMessageRemoveFlags)"/> function.
            </param>
            <returns>
                If the message is translated (that is, a character message is posted to the thread's message queue), the return
                value is nonzero.
                <para>
                    If the message is <see cref = "F:PInvoke.User32.WindowMessage.WM_KEYDOWN"/>, <see cref = "F:PInvoke.User32.WindowMessage.WM_KEYUP"/>,
                    <see cref = "F:PInvoke.User32.WindowMessage.WM_SYSKEYDOWN"/>, or
                    <see cref = "F:PInvoke.User32.WindowMessage.WM_SYSKEYUP"/>, the return value is nonzero, regardless of the translation.
                </para>
                <para>
                    If the message is not translated (that is, a character message is not posted to the thread's message queue),
                    the return value is zero.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.User32.DispatchMessage(System.IntPtr)">
            <summary>
                Dispatches a message to a window procedure. It is typically used to dispatch a message retrieved by the
                <see cref = "M:PInvoke.User32.GetMessage(PInvoke.User32.MSG*,System.IntPtr,PInvoke.User32.WindowMessage,PInvoke.User32.WindowMessage)"/> function.
            </summary>
            <param name = "lpMsg">A pointer to a structure that contains the message.</param>
            <returns>
                The return value specifies the value returned by the window procedure. Although its meaning depends on the
                message being dispatched, the return value generally is ignored.
            </returns>
        </member>
        <member name="M:PInvoke.User32.IsDialogMessage(System.IntPtr,System.IntPtr)">
            <summary>
                Determines whether a message is intended for the specified dialog box and, if it is, processes the message.
            </summary>
            <param name = "hDlg">A handle to the dialog box.</param>
            <param name = "lpMsg">A pointer to an <see cref = "T:PInvoke.User32.MSG"/> structure that contains the message to be checked.</param>
            <returns>
                If the message has been processed, the return value is nonzero.
                <para>If the message has not been processed, the return value is zero.</para>
            </returns>
        </member>
        <member name="M:PInvoke.User32.LoadString(System.IntPtr,System.UInt32,System.IntPtr@,System.Int32)">
            <summary>
                Loads a string resource from the executable file associated with a specified module, copies the string into
                a buffer, and appends a terminating null character.
            </summary>
            <param name = "hInstance">
                A handle to an instance of the module whose executable file contains the string resource. To get the handle
                to the application itself, call the <see cref = "M:PInvoke.Kernel32.GetModuleHandle(System.String)"/> function with NULL.
            </param>
            <param name = "uID">
                The identifier of the string to be loaded.
            </param>
            <param name = "lpBuffer">
                The buffer is to receive the string. Must be of sufficient length to hold a pointer (8 bytes).
            </param>
            <param name = "cchBufferMax">
                The size of the buffer, in characters. The string is truncated and null-terminated if it is longer than the
                number of characters specified. If this parameter is 0, then lpBuffer receives a read-only pointer to the
                resource itself.
            </param>
            <returns>
                If the function succeeds, the return value is the number of characters copied into the buffer, not
                including the terminating null character, or zero if the string resource does not exist. To get extended
                error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.User32.GetWindowText(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Copies the text of the specified window's title bar (if it has one) into a buffer. If the specified window is
            a control, the text of the control is copied. However, GetWindowText cannot retrieve the text of a control in another
            application.
            </summary>
            <param name = "hWnd">A handle to the window or control containing the text.</param>
            <param name = "lpString">
            The buffer that will receive the text. If the string is as long or longer than the buffer, the
            string is truncated and terminated with a null character.
            </param>
            <param name = "nMaxCount">
            The maximum number of characters to copy to the buffer, including the null character. If the
            text exceeds this limit, it is truncated.
            </param>
            <returns>
            If the function succeeds, the return value is the length, in characters, of the copied string, not including
            the terminating null character. If the window has no title bar or text, if the title bar is empty, or if the window or
            control handle is invalid, the return value is zero. To get extended error information, call GetLastError.
            <para>This function cannot retrieve the text of an edit control in another application.</para>
            </returns>
        </member>
        <member name="M:PInvoke.User32.GetWindowText(System.IntPtr,System.Char[],System.Int32)">
            <summary>
            Copies the text of the specified window's title bar (if it has one) into a buffer. If the specified window is
            a control, the text of the control is copied. However, GetWindowText cannot retrieve the text of a control in another
            application.
            </summary>
            <param name = "hWnd">A handle to the window or control containing the text.</param>
            <param name = "lpString">
            The buffer that will receive the text. If the string is as long or longer than the buffer, the
            string is truncated and terminated with a null character.
            </param>
            <param name = "nMaxCount">
            The maximum number of characters to copy to the buffer, including the null character. If the
            text exceeds this limit, it is truncated.
            </param>
            <returns>
            If the function succeeds, the return value is the length, in characters, of the copied string, not including
            the terminating null character. If the window has no title bar or text, if the title bar is empty, or if the window or
            control handle is invalid, the return value is zero. To get extended error information, call GetLastError.
            <para>This function cannot retrieve the text of an edit control in another application.</para>
            </returns>
        </member>
        <member name="M:PInvoke.User32.GetCursorPos(System.IntPtr)">
            <summary>
            Retrieves the position of the mouse cursor, in screen coordinates.
            </summary>
            <param name = "lpPoint">A pointer to a POINT structure that receives the screen coordinates of the cursor.</param>
            <returns>Returns nonzero if successful or zero otherwise. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:PInvoke.User32.GetWindowPlacement(System.IntPtr,System.IntPtr)">
            <summary>Retrieves the show state and the restored, minimized, and maximized positions of the specified window.</summary>
            <param name = "hWnd">A handle to the window.</param>
            <param name = "lpwndpl">
            A pointer to the WINDOWPLACEMENT structure that receives the show state and position information.
            Before calling GetWindowPlacement, set the length member to sizeof(WINDOWPLACEMENT). GetWindowPlacement fails if
            lpwndpl-> length is not set correctly.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:PInvoke.User32.CreateWindowEx(PInvoke.User32.WindowStylesEx,System.String,System.String,PInvoke.User32.WindowStyles,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Creates an overlapped, pop-up, or child window with an
            extended window style; otherwise, this function is identical to the CreateWindow function.
            </summary>
            <param name = "dwExStyle">Specifies the extended window style of the window being created.</param>
            <param name = "lpClassName">
            Pointer to a null-terminated string that specifies
            the window class name. The class name can be any name registered with RegisterClass or
            RegisterClassEx, provided that the module that registers the class is also the module
            that creates the window. The class name can also be any of the predefined system class names.
            </param>
            <param name = "lpWindowName">
            Pointer to a null-terminated string that specifies the window name. If the window style
            specifies a title bar, the window title pointed to by lpWindowName is displayed in the
            title bar. When using CreateWindow to create controls, such as buttons, check boxes, and
            static controls, use lpWindowName to specify the text of the control. When creating a
            static control with the SS_ICON style, use lpWindowName to specify the icon name or
            identifier. To specify an identifier, use the syntax "#num".
            </param>
            <param name = "dwStyle">
            Specifies the style of the window being created. This parameter can be a combination of
            window styles, plus the control styles indicated in the Remarks section.
            </param>
            <param name = "x">
            Specifies the initial horizontal position of the window. For an overlapped or pop-up
            window, the x parameter is the initial x-coordinate of the window's upper-left corner, in
            screen coordinates. For a child window, x is the x-coordinate of the upper-left corner of
            the window relative to the upper-left corner of the parent window's client area. If x is
            set to CW_USEDEFAULT, the system selects the default position for the window's upper-left
            corner and ignores the y parameter. CW_USEDEFAULT is valid only for overlapped windows;
            if it is specified for a pop-up or child window, the x and y parameters are set to zero.
            </param>
            <param name = "y">
            Specifies the initial vertical position of the window. For an overlapped or pop-up
            window, the y parameter is the initial y-coordinate of the window's upper-left corner, in
            screen coordinates. For a child window, y is the initial y-coordinate of the upper-left
            corner of the child window relative to the upper-left corner of the parent window's
            client area. For a list box y is the initial y-coordinate of the upper-left corner of the
            list box's client area relative to the upper-left corner of the parent window's client area.
            <para>
            If an overlapped window is created with the WS_VISIBLE style bit set and the x parameter
            is set to CW_USEDEFAULT, then the y parameter determines how the window is shown. If the
            y parameter is CW_USEDEFAULT, then the window manager calls ShowWindow with the SW_SHOW
            flag after the window has been created. If the y parameter is some other value, then the
            window manager calls ShowWindow with that value as the nCmdShow parameter.
            </para>
            </param>
            <param name = "nWidth">
            Specifies the width, in device units, of the window. For overlapped windows, nWidth is
            the window's width, in screen coordinates, or CW_USEDEFAULT. If nWidth is CW_USEDEFAULT,
            the system selects a default width and height for the window; the default width extends
            from the initial x-coordinates to the right edge of the screen; the default height
            extends from the initial y-coordinate to the top of the icon area. CW_USEDEFAULT is valid
            only for overlapped windows; if CW_USEDEFAULT is specified for a pop-up or child window,
            the nWidth and nHeight parameter are set to zero.
            </param>
            <param name = "nHeight">
            Specifies the height, in device units, of the window. For overlapped windows, nHeight is
            the window's height, in screen coordinates. If the nWidth parameter is set to
            CW_USEDEFAULT, the system ignores nHeight.
            </param>
            <param name = "hWndParent">
            Handle to the parent or owner window of the window being created. To create a child
            window or an owned window, supply a valid window handle. This parameter is optional for
            pop-up windows.
            <para>
            Windows 2000/XP: To create a message-only window, supply HWND_MESSAGE or a handle to an
            existing message-only window.
            </para>
            </param>
            <param name = "hMenu">
            Handle to a menu, or specifies a child-window identifier, depending on the window style.
            For an overlapped or pop-up window, hMenu identifies the menu to be used with the window;
            it can be NULL if the class menu is to be used. For a child window, hMenu specifies the
            child-window identifier, an integer value used by a dialog box control to notify its
            parent about events. The application determines the child-window identifier; it must be
            unique for all child windows with the same parent window.
            </param>
            <param name = "hInstance">
            Handle to the instance of the module to be associated with the window.
            </param>
            <param name = "lpParam">
            Pointer to a value to be passed to the window through the CREATESTRUCT structure
            (lpCreateParams member) pointed to by the lParam param of the WM_CREATE message. This
            message is sent to the created window by this function before it returns.
            <para>
            If an application calls CreateWindow to create a MDI client window, lpParam should point
            to a CLIENTCREATESTRUCT structure. If an MDI client window calls CreateWindow to create
            an MDI child window, lpParam should point to a MDICREATESTRUCT structure. lpParam may be
            NULL if no additional data is needed.
            </para>
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the new window.
            <para>
            If the function fails, the return value is NULL. To get extended error information, call GetLastError.
            </para>
            <para>This function typically fails for one of the following reasons:</para>
            <list type = "">
            <item>an invalid parameter value</item>
            <item>the system class was registered by a different module</item>
            <item>The WH_CBT hook is installed and returns a failure code</item>
            <item>
            if one of the controls in the dialog template is not registered, or its window window
            procedure fails WM_CREATE or WM_NCCREATE
            </item>
            </list>
            </returns>
        </member>
        <member name="M:PInvoke.User32.CreateWindowEx(PInvoke.User32.WindowStylesEx,System.Int16,System.String,PInvoke.User32.WindowStyles,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Creates an overlapped, pop-up, or child window with an
            extended window style; otherwise, this function is identical to the CreateWindow function.
            </summary>
            <param name = "dwExStyle">Specifies the extended window style of the window being created.</param>
            <param name = "lpClassName">
            Pointer to a class atom created by a previous call to the
            RegisterClass or RegisterClassEx function. The atom must be in the low-order word of
            lpClassName; the high-order word must be zero.
            </param>
            <param name = "lpWindowName">
            Pointer to a null-terminated string that specifies the window name. If the window style
            specifies a title bar, the window title pointed to by lpWindowName is displayed in the
            title bar. When using CreateWindow to create controls, such as buttons, check boxes, and
            static controls, use lpWindowName to specify the text of the control. When creating a
            static control with the SS_ICON style, use lpWindowName to specify the icon name or
            identifier. To specify an identifier, use the syntax "#num".
            </param>
            <param name = "dwStyle">
            Specifies the style of the window being created. This parameter can be a combination of
            window styles, plus the control styles indicated in the Remarks section.
            </param>
            <param name = "x">
            Specifies the initial horizontal position of the window. For an overlapped or pop-up
            window, the x parameter is the initial x-coordinate of the window's upper-left corner, in
            screen coordinates. For a child window, x is the x-coordinate of the upper-left corner of
            the window relative to the upper-left corner of the parent window's client area. If x is
            set to CW_USEDEFAULT, the system selects the default position for the window's upper-left
            corner and ignores the y parameter. CW_USEDEFAULT is valid only for overlapped windows;
            if it is specified for a pop-up or child window, the x and y parameters are set to zero.
            </param>
            <param name = "y">
            Specifies the initial vertical position of the window. For an overlapped or pop-up
            window, the y parameter is the initial y-coordinate of the window's upper-left corner, in
            screen coordinates. For a child window, y is the initial y-coordinate of the upper-left
            corner of the child window relative to the upper-left corner of the parent window's
            client area. For a list box y is the initial y-coordinate of the upper-left corner of the
            list box's client area relative to the upper-left corner of the parent window's client area.
            <para>
            If an overlapped window is created with the WS_VISIBLE style bit set and the x parameter
            is set to CW_USEDEFAULT, then the y parameter determines how the window is shown. If the
            y parameter is CW_USEDEFAULT, then the window manager calls ShowWindow with the SW_SHOW
            flag after the window has been created. If the y parameter is some other value, then the
            window manager calls ShowWindow with that value as the nCmdShow parameter.
            </para>
            </param>
            <param name = "nWidth">
            Specifies the width, in device units, of the window. For overlapped windows, nWidth is
            the window's width, in screen coordinates, or CW_USEDEFAULT. If nWidth is CW_USEDEFAULT,
            the system selects a default width and height for the window; the default width extends
            from the initial x-coordinates to the right edge of the screen; the default height
            extends from the initial y-coordinate to the top of the icon area. CW_USEDEFAULT is valid
            only for overlapped windows; if CW_USEDEFAULT is specified for a pop-up or child window,
            the nWidth and nHeight parameter are set to zero.
            </param>
            <param name = "nHeight">
            Specifies the height, in device units, of the window. For overlapped windows, nHeight is
            the window's height, in screen coordinates. If the nWidth parameter is set to
            CW_USEDEFAULT, the system ignores nHeight.
            </param>
            <param name = "hWndParent">
            Handle to the parent or owner window of the window being created. To create a child
            window or an owned window, supply a valid window handle. This parameter is optional for
            pop-up windows.
            <para>
            Windows 2000/XP: To create a message-only window, supply HWND_MESSAGE or a handle to an
            existing message-only window.
            </para>
            </param>
            <param name = "hMenu">
            Handle to a menu, or specifies a child-window identifier, depending on the window style.
            For an overlapped or pop-up window, hMenu identifies the menu to be used with the window;
            it can be NULL if the class menu is to be used. For a child window, hMenu specifies the
            child-window identifier, an integer value used by a dialog box control to notify its
            parent about events. The application determines the child-window identifier; it must be
            unique for all child windows with the same parent window.
            </param>
            <param name = "hInstance">
            Handle to the instance of the module to be associated with the window.
            </param>
            <param name = "lpParam">
            Pointer to a value to be passed to the window through the CREATESTRUCT structure
            (lpCreateParams member) pointed to by the lParam param of the WM_CREATE message. This
            message is sent to the created window by this function before it returns.
            <para>
            If an application calls CreateWindow to create a MDI client window, lpParam should point
            to a CLIENTCREATESTRUCT structure. If an MDI client window calls CreateWindow to create
            an MDI child window, lpParam should point to a MDICREATESTRUCT structure. lpParam may be
            NULL if no additional data is needed.
            </para>
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the new window.
            <para>
            If the function fails, the return value is NULL. To get extended error information, call GetLastError.
            </para>
            <para>This function typically fails for one of the following reasons:</para>
            <list type = "">
            <item>an invalid parameter value</item>
            <item>the system class was registered by a different module</item>
            <item>The WH_CBT hook is installed and returns a failure code</item>
            <item>
            if one of the controls in the dialog template is not registered, or its window window
            procedure fails WM_CREATE or WM_NCCREATE
            </item>
            </list>
            </returns>
        </member>
        <member name="M:PInvoke.User32.DrawText(PInvoke.User32.SafeDCHandle,System.IntPtr,System.Int32,System.IntPtr,PInvoke.User32.TextFormats)">
            <summary>
            The DrawText function draws formatted text in the specified rectangle.
            It formats the text according to the specified method (expanding tabs, justifying characters, breaking lines, and so forth).
            To specify additional formatting options, use the <see cref = "M:PInvoke.User32.DrawTextEx(PInvoke.User32.SafeDCHandle,System.Char*,System.Int32,PInvoke.RECT*,System.UInt32,PInvoke.User32.DRAWTEXTPARAMS*)"/> function.
            </summary>
            <param name = "hDC">A handle to the device context.</param>
            <param name = "lpString">
            A pointer to the string that specifies the text to be drawn.
            If the <paramref name = "nCount"/> parameter is -1, the string must be null-terminated.
            If <paramref name = "uFormat"/> includes <see cref = "F:PInvoke.User32.TextFormats.DT_MODIFYSTRING"/>, the function could add up to four additional characters to this string.
            The buffer containing the string should be large enough to accommodate these extra characters.
            </param>
            <param name = "nCount">The length, in characters, of the string. If nCount is -1, then the lpchText parameter is assumed to be a pointer to a null-terminated string and DrawText computes the character count automatically.</param>
            <param name = "lpRect">A pointer to a RECT structure that contains the rectangle (in logical coordinates) in which the text is to be formatted.</param>
            <param name = "uFormat">The method of formatting the text.</param>
            <returns>
            If the function succeeds, the return value is the height of the text in logical units.
            If <see cref = "F:PInvoke.User32.TextFormats.DT_VCENTER"/> or <see cref = "F:PInvoke.User32.TextFormats.DT_BOTTOM"/> is specified, the return value is the offset from <see cref = "F:PInvoke.RECT.top"/> (<paramref name = "lpRect"/>) to the bottom of the drawn text.
            If the function fails, the return value is zero.</returns>
            <remarks>
            <para>
            The DrawText function uses the device context's selected font, text color, and background color to draw the text.
            Unless the <see cref = "F:PInvoke.User32.TextFormats.DT_NOCLIP"/> format is used, DrawText clips the text so that it does not appear outside the specified rectangle.
            Note that text with significant overhang may be clipped, for example, an initial "W" in the text string or text that is in italics.
            All formatting is assumed to have multiple lines unless the <see cref = "F:PInvoke.User32.TextFormats.DT_SINGLELINE"/> format is specified.
            </para>
            <para>
            If the selected font is too large for the specified rectangle, the DrawText function does not attempt to substitute a smaller font.
            The text alignment mode for the device context must include the TA_LEFT, TA_TOP, and TA_NOUPDATECP flags.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.DrawText(PInvoke.User32.SafeDCHandle,System.Char[],System.Int32,PInvoke.RECT@,PInvoke.User32.TextFormats)">
            <summary>
            The DrawText function draws formatted text in the specified rectangle.
            It formats the text according to the specified method (expanding tabs, justifying characters, breaking lines, and so forth).
            To specify additional formatting options, use the <see cref = "M:PInvoke.User32.DrawTextEx(PInvoke.User32.SafeDCHandle,System.Char*,System.Int32,PInvoke.RECT*,System.UInt32,PInvoke.User32.DRAWTEXTPARAMS*)"/> function.
            </summary>
            <param name = "hDC">A handle to the device context.</param>
            <param name = "lpString">
            A pointer to the string that specifies the text to be drawn.
            If the <paramref name = "nCount"/> parameter is -1, the string must be null-terminated.
            If <paramref name = "uFormat"/> includes <see cref = "F:PInvoke.User32.TextFormats.DT_MODIFYSTRING"/>, the function could add up to four additional characters to this string.
            The buffer containing the string should be large enough to accommodate these extra characters.
            </param>
            <param name = "nCount">The length, in characters, of the string. If nCount is -1, then the lpchText parameter is assumed to be a pointer to a null-terminated string and DrawText computes the character count automatically.</param>
            <param name = "lpRect">A pointer to a RECT structure that contains the rectangle (in logical coordinates) in which the text is to be formatted.</param>
            <param name = "uFormat">The method of formatting the text.</param>
            <returns>
            If the function succeeds, the return value is the height of the text in logical units.
            If <see cref = "F:PInvoke.User32.TextFormats.DT_VCENTER"/> or <see cref = "F:PInvoke.User32.TextFormats.DT_BOTTOM"/> is specified, the return value is the offset from <see cref = "F:PInvoke.RECT.top"/> (<paramref name = "lpRect"/>) to the bottom of the drawn text.
            If the function fails, the return value is zero.</returns>
            <remarks>
            <para>
            The DrawText function uses the device context's selected font, text color, and background color to draw the text.
            Unless the <see cref = "F:PInvoke.User32.TextFormats.DT_NOCLIP"/> format is used, DrawText clips the text so that it does not appear outside the specified rectangle.
            Note that text with significant overhang may be clipped, for example, an initial "W" in the text string or text that is in italics.
            All formatting is assumed to have multiple lines unless the <see cref = "F:PInvoke.User32.TextFormats.DT_SINGLELINE"/> format is specified.
            </para>
            <para>
            If the selected font is too large for the specified rectangle, the DrawText function does not attempt to substitute a smaller font.
            The text alignment mode for the device context must include the TA_LEFT, TA_TOP, and TA_NOUPDATECP flags.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.DrawTextEx(PInvoke.User32.SafeDCHandle,System.IntPtr,System.Int32,System.IntPtr,System.UInt32,System.IntPtr)">
            <summary>
            The DrawTextEx function draws formatted text in the specified rectangle.
            </summary>
            <param name = "hdc">A handle to the device context in which to draw.</param>
            <param name = "lpchText">
            A pointer to the string that contains the text to draw. If the <paramref name = "cchText"/> parameter is -1, the string must be null-terminated.
            If <paramref name = "dwDTFormat"/> includes <see cref = "F:PInvoke.User32.TextFormats.DT_MODIFYSTRING"/>, the function could add up to four additional characters to this string.
            The buffer containing the string should be large enough to accommodate these extra characters.
            </param>
            <param name = "cchText">
            The length of the string pointed to by <paramref name = "lpchText"/>.
            If cchText is -1, then the lpchText parameter is assumed to be a pointer to a null-terminated string and DrawTextEx computes the character count automatically.
            </param>
            <param name = "lprc">A pointer to a <see cref = "T:PInvoke.RECT"/> structure that contains the rectangle, in logical coordinates, in which the text is to be formatted.</param>
            <param name = "dwDTFormat">The formatting options.</param>
            <param name = "lpDTParams">A pointer to a <see cref = "T:PInvoke.User32.DRAWTEXTPARAMS"/> structure that specifies additional formatting options. This parameter can be NULL.</param>
            <returns>
            If the function succeeds, the return value is the text height in logical units.
            If <see cref = "F:PInvoke.User32.TextFormats.DT_VCENTER"/> or <see cref = "F:PInvoke.User32.TextFormats.DT_BOTTOM"/> is specified, the return value is the offset from  <see cref = "F:PInvoke.RECT.top"/> (<paramref name = "lprc"/>) to the bottom of the drawn text
            If the function fails, the return value is zero.
            </returns>
        </member>
        <member name="M:PInvoke.User32.DrawTextEx(PInvoke.User32.SafeDCHandle,System.Char[],System.Int32,PInvoke.RECT@,System.UInt32,System.Nullable{PInvoke.User32.DRAWTEXTPARAMS})">
            <summary>
            The DrawTextEx function draws formatted text in the specified rectangle.
            </summary>
            <param name = "hdc">A handle to the device context in which to draw.</param>
            <param name = "lpchText">
            A pointer to the string that contains the text to draw. If the <paramref name = "cchText"/> parameter is -1, the string must be null-terminated.
            If <paramref name = "dwDTFormat"/> includes <see cref = "F:PInvoke.User32.TextFormats.DT_MODIFYSTRING"/>, the function could add up to four additional characters to this string.
            The buffer containing the string should be large enough to accommodate these extra characters.
            </param>
            <param name = "cchText">
            The length of the string pointed to by <paramref name = "lpchText"/>.
            If cchText is -1, then the lpchText parameter is assumed to be a pointer to a null-terminated string and DrawTextEx computes the character count automatically.
            </param>
            <param name = "lprc">A pointer to a <see cref = "T:PInvoke.RECT"/> structure that contains the rectangle, in logical coordinates, in which the text is to be formatted.</param>
            <param name = "dwDTFormat">The formatting options.</param>
            <param name = "lpDTParams">A pointer to a <see cref = "T:PInvoke.User32.DRAWTEXTPARAMS"/> structure that specifies additional formatting options. This parameter can be NULL.</param>
            <returns>
            If the function succeeds, the return value is the text height in logical units.
            If <see cref = "F:PInvoke.User32.TextFormats.DT_VCENTER"/> or <see cref = "F:PInvoke.User32.TextFormats.DT_BOTTOM"/> is specified, the return value is the offset from  <see cref = "F:PInvoke.RECT.top"/> (<paramref name = "lprc"/>) to the bottom of the drawn text
            If the function fails, the return value is zero.
            </returns>
        </member>
        <member name="M:PInvoke.User32.EndPaint(System.IntPtr,System.IntPtr)">
            <summary>
            The EndPaint function marks the end of painting in the specified window. This function is required for each call to the <see cref = "M:PInvoke.User32.BeginPaint(System.IntPtr,PInvoke.User32.PAINTSTRUCT*)"/> function, but only after painting is complete.
            </summary>
            <param name = "hWnd">Handle to the window that has been repainted.</param>
            <param name = "lpPaint">Pointer to a <see cref = "T:PInvoke.User32.PAINTSTRUCT"/> structure that contains the painting information retrieved by <see cref = "M:PInvoke.User32.BeginPaint(System.IntPtr,PInvoke.User32.PAINTSTRUCT*)"/>.</param>
            <returns>The return value is always nonzero.</returns>
            <remarks>
            If the caret was hidden by <see cref = "M:PInvoke.User32.BeginPaint(System.IntPtr,PInvoke.User32.PAINTSTRUCT*)"/>, EndPaint restores the caret to the screen.
            EndPaint releases the display device context that <see cref = "M:PInvoke.User32.BeginPaint(System.IntPtr,PInvoke.User32.PAINTSTRUCT*)"/> retrieved.
            </remarks>
        </member>
        <member name="M:PInvoke.User32.EndPaint(System.IntPtr,PInvoke.User32.PAINTSTRUCT)">
            <summary>
            The EndPaint function marks the end of painting in the specified window. This function is required for each call to the <see cref = "M:PInvoke.User32.BeginPaint(System.IntPtr,PInvoke.User32.PAINTSTRUCT*)"/> function, but only after painting is complete.
            </summary>
            <param name = "hWnd">Handle to the window that has been repainted.</param>
            <param name = "lpPaint">Pointer to a <see cref = "T:PInvoke.User32.PAINTSTRUCT"/> structure that contains the painting information retrieved by <see cref = "M:PInvoke.User32.BeginPaint(System.IntPtr,PInvoke.User32.PAINTSTRUCT*)"/>.</param>
            <returns>The return value is always nonzero.</returns>
            <remarks>
            If the caret was hidden by <see cref = "M:PInvoke.User32.BeginPaint(System.IntPtr,PInvoke.User32.PAINTSTRUCT*)"/>, EndPaint restores the caret to the screen.
            EndPaint releases the display device context that <see cref = "M:PInvoke.User32.BeginPaint(System.IntPtr,PInvoke.User32.PAINTSTRUCT*)"/> retrieved.
            </remarks>
        </member>
        <member name="M:PInvoke.User32.SetWindowPlacement(System.IntPtr,System.IntPtr)">
            <summary>
            Sets the show state and the restored, minimized, and maximized positions of the specified window.
            </summary>
            <param name = "hWnd">A handle to the window.</param>
            <param name = "lpwndpl">A pointer to a WINDOWPLACEMENT structure that specifies the new show state and window positions.
            Before calling SetWindowPlacement, set the <see cref = "F:PInvoke.User32.WINDOWPLACEMENT.length"/> member of the <see cref = "T:PInvoke.User32.WINDOWPLACEMENT"/> structure to sizeof(WINDOWPLACEMENT).
            SetWindowPlacement fails if the length member is not set correctly.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:PInvoke.User32.SetWindowPlacement(System.IntPtr,PInvoke.User32.WINDOWPLACEMENT)">
            <summary>
            Sets the show state and the restored, minimized, and maximized positions of the specified window.
            </summary>
            <param name = "hWnd">A handle to the window.</param>
            <param name = "lpwndpl">A pointer to a WINDOWPLACEMENT structure that specifies the new show state and window positions.
            Before calling SetWindowPlacement, set the <see cref = "F:PInvoke.User32.WINDOWPLACEMENT.length"/> member of the <see cref = "T:PInvoke.User32.WINDOWPLACEMENT"/> structure to sizeof(WINDOWPLACEMENT).
            SetWindowPlacement fails if the length member is not set correctly.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:PInvoke.User32.keybd_event(System.Byte,System.Byte,PInvoke.User32.KEYEVENTF,System.IntPtr)">
            <summary>
                Synthesizes a keystroke. The system can use such a synthesized keystroke to generate a WM_KEYUP or WM_KEYDOWN message. The keyboard driver's interrupt handler calls the keybd_event function.
            </summary>
            <param name = "bVk">
                A virtual-key code from <see cref = "T:PInvoke.User32.VirtualKey"/>. The code must be a value in the range 1 to 254.
            </param>
            <param name = "bScan">
                A hardware scan code for the key from <see cref = "T:PInvoke.User32.ScanCode"/>.
            </param>
            <param name = "dwFlags">
                Controls various aspects of function operation. This parameter can be one or more of the following values.
            </param>
            <param name = "dwExtraInfo">
                An additional value associated with the key stroke.
            </param>
        </member>
        <member name="M:PInvoke.User32.mouse_event(PInvoke.User32.mouse_eventFlags,System.Int32,System.Int32,System.Int32,System.IntPtr)">
            <summary>
            The <see cref = "M:PInvoke.User32.mouse_event(PInvoke.User32.mouse_eventFlags,System.Int32,System.Int32,System.Int32,System.Void*)"/> function synthesizes mouse motion and button clicks.
            </summary>
            <param name = "dwFlags">Controls various aspects of mouse motion and button clicking.</param>
            <param name = "dx">The mouse's absolute position along the x-axis or its amount of motion since the last mouse event was generated, depending on the setting of <see cref = "F:PInvoke.User32.mouse_eventFlags.MOUSEEVENTF_ABSOLUTE"/>. Absolute data is specified as the mouse's actual x-coordinate; relative data is specified as the number of mickeys moved. A mickey is the amount that a mouse has to move for it to report that it has moved.</param>
            <param name = "dy">The mouse's absolute position along the y-axis or its amount of motion since the last mouse event was generated, depending on the setting of <see cref = "F:PInvoke.User32.mouse_eventFlags.MOUSEEVENTF_ABSOLUTE"/>. Absolute data is specified as the mouse's actual y-coordinate; relative data is specified as the number of mickeys moved.</param>
            <param name = "dwData">
            If <paramref name = "dwFlags"/> contains <see cref = "F:PInvoke.User32.mouse_eventFlags.MOUSEEVENTF_WHEEL"/>, then dwData specifies the amount of wheel movement. A positive value indicates that the wheel was rotated forward, away from the user; a negative value indicates that the wheel was rotated backward, toward the user. One wheel click is defined as WHEEL_DELTA, which is 120.
            If <paramref name = "dwFlags"/> contains <see cref = "F:PInvoke.User32.mouse_eventFlags.MOUSEEVENTF_HWHEEL"/>, then dwData specifies the amount of wheel movement. A positive value indicates that the wheel was tilted to the right; a negative value indicates that the wheel was tilted to the left.
            If <paramref name = "dwFlags"/> contains <see cref = "F:PInvoke.User32.mouse_eventFlags.MOUSEEVENTF_XDOWN"/> or <see cref = "F:PInvoke.User32.mouse_eventFlags.MOUSEEVENTF_XUP"/>, then <paramref name = "dwData"/> specifies which X buttons were pressed or released. This value may be any combination of the following flags.
            If <paramref name = "dwFlags"/> is not <see cref = "F:PInvoke.User32.mouse_eventFlags.MOUSEEVENTF_WHEEL"/>, <see cref = "F:PInvoke.User32.mouse_eventFlags.MOUSEEVENTF_XDOWN"/>, or <see cref = "F:PInvoke.User32.mouse_eventFlags.MOUSEEVENTF_XUP"/>, then <paramref name = "dwData"/> should be zero.
            </param>
            <param name = "dwExtraInfo">An additional value associated with the mouse event. An application calls GetMessageExtraInfo to obtain this extra information.</param>
        </member>
        <member name="M:PInvoke.User32.AdjustWindowRectExForDpi(System.IntPtr,PInvoke.User32.WindowStyles,System.Boolean,PInvoke.User32.WindowStylesEx,System.Int32)">
            <summary>
            Calculates the required size of the window rectangle, based on the desired size of the client rectangle and the provided DPI. This window rectangle can then be passed to the CreateWindowEx function to create a window with a client area of the desired size.
            </summary>
            <param name = "lpRect">A pointer to a <see cref = "T:PInvoke.RECT"/> structure that contains the coordinates of the top-left and bottom-right corners of the desired client area. When the function returns, the structure contains the coordinates of the top-left and bottom-right corners of the window to accommodate the desired client area.</param>
            <param name = "dwStyle">The Window Style of the window whose required size is to be calculated. Note that you cannot specify the <see cref = "F:PInvoke.User32.WindowStyles.WS_OVERLAPPED"/> style.</param>
            <param name = "bMenu">Indicates whether the window has a menu.</param>
            <param name = "dwExStyle">The Extended Window Style of the window whose required size is to be calculated.</param>
            <param name = "dpi">The DPI to use for scaling.</param>
            <returns>
            If the function succeeds, the return value is true.
            If the function fails, the return value is false. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.User32.SystemParametersInfoForDpi(PInvoke.User32.SystemParametersInfoAction,System.Int32,System.IntPtr,PInvoke.User32.SystemParametersInfoFlags,System.Int32)">
            <summary>
            Retrieves the value of one of the system-wide parameters, taking into account the provided DPI value.
            </summary>
            <param name = "uiAction">The system-wide parameter to be retrieved. This function is only intended for use with <see cref = "F:PInvoke.User32.SystemParametersInfoAction.SPI_GETICONTITLELOGFONT"/>, <see cref = "F:PInvoke.User32.SystemParametersInfoAction.SPI_GETICONMETRICS"/>, or <see cref = "F:PInvoke.User32.SystemParametersInfoAction.SPI_GETNONCLIENTMETRICS"/>. See <see cref = "T:PInvoke.User32.SystemParametersInfoAction"/> for more information on these values.</param>
            <param name = "uiParam">A parameter whose usage and format depends on the system parameter being queried. For more information about system-wide parameters, see the <paramref name = "uiAction"/> parameter. If not otherwise indicated, you must specify zero for this parameter.</param>
            <param name = "pvParam">A parameter whose usage and format depends on the system parameter being queried. For more information about system-wide parameters, see the <paramref name = "uiAction"/> parameter. If not otherwise indicated, you must specify NULL for this parameter.</param>
            <param name = "fWinIni">Has no effect for with this API. This parameter only has an effect if you're setting parameter.</param>
            <param name = "dpi">The DPI to use for scaling the metric.</param>
            <returns>
            If the function succeeds, the return value is true.
            If the function fails, the return value is false. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
            <remarks>
            This function returns a similar result as SystemParametersInfo, but scales it according to an arbitrary DPI you provide (if appropriate). It only scales with the following possible values for uiAction:
                SPI_GETICONTITLELOGFONT, SPI_GETICONMETRICS, SPI_GETNONCLIENTMETRICS.
            Other possible uiAction values do not provide ForDPI behavior, and therefore this function returns 0 if called with them.
            For uiAction values that contain strings within their associated structures, only Unicode(LOGFONTW) strings are supported in this function.
            </remarks>
        </member>
        <member name="M:PInvoke.User32.AdjustWindowRectEx(System.IntPtr,PInvoke.User32.WindowStyles,System.Boolean,PInvoke.User32.WindowStylesEx)">
            <summary>
            Calculates the required size of the window rectangle, based on the desired size of the client rectangle.
            The window rectangle can then be passed to the CreateWindowEx function to create a window whose client area
            is the desired size.
            </summary>
            <param name = "lpRect">
            A pointer to a RECT structure that contains the coordinates of the top-left and bottom-right corners
            of the desired client area. When the function returns, the structure contains the coordinates of the top-left
            and bottom-right corners of the window to accommodate the desired client area.
            </param>
            <param name = "dwStyle">
            The window style of the window whose required size is to be calculated. Note that you cannot specify
            the <see cref = "F:PInvoke.User32.WindowStyles.WS_OVERLAPPED"/> style.</param>
            <param name = "bMenu">Indicates whether the window has a menu.</param>
            <param name = "dwExStyle">The extended window style of the window whose required size is to be calculated.</param>
            <returns>
            If the function succeeds, the return value is true.
            If the function fails, the return value is false.
            To get extended error information, call GetLastError.
            </returns>
            <remarks>
            <para>
            A client rectangle is the smallest rectangle that completely encloses a client area.
            A window rectangle is the smallest rectangle that completely encloses the window, which includes
            the client area and the nonclient area.
            </para>
            <para>
            The AdjustWindowRectEx function does not add extra space when a menu bar wraps to two or more rows.
            </para>
            <para>
            The AdjustWindowRectEx function does not take the <see cref = "F:PInvoke.User32.WindowStyles.WS_VSCROLL"/> or
            <see cref = "F:PInvoke.User32.WindowStyles.WS_HSCROLL"/> styles into account.
            To account for the scroll bars, call the GetSystemMetrics function with <see cref = "F:PInvoke.User32.SystemMetric.SM_CXVSCROLL"/> or
            <see cref = "F:PInvoke.User32.SystemMetric.SM_CYHSCROLL"/>.
            </para>
            <para>
            This API is not DPI aware, and should not be used if the calling thread is per-monitor DPI aware.
            For the DPI-aware version of this API, see AdjustWindowsRectExForDPI.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.BeginPaint_IntPtr(System.IntPtr,System.IntPtr)">
            <summary>
            The BeginPaint function prepares the specified window for painting and fills a <see cref = "T:PInvoke.User32.PAINTSTRUCT"/> structure with information about the painting.
            </summary>
            <param name = "hwnd">Handle to the window to be repainted.</param>
            <param name = "lpPaint">Pointer to the <see cref = "T:PInvoke.User32.PAINTSTRUCT"/> structure that will receive painting information.</param>
            <returns>
            If the function succeeds, the return value is the handle to a display device context for the specified window.
            If the function fails, the return value is <see cref = "F:System.IntPtr.Zero"/>, indicating that no display device context is available..</returns>
            <remarks>
            <para>
            The BeginPaint function automatically sets the clipping region of the device context to exclude any area outside the update region.
            The update region is set by the InvalidateRect or InvalidateRgn function and by the system after sizing, moving, creating, scrolling,
            or any other operation that affects the client area. If the update region is marked for erasing, BeginPaint sends a <see cref = "F:PInvoke.User32.WindowMessage.WM_ERASEBKGND"/> message to the window.
            </para>
            <para>
            An application should not call BeginPaint except in response to a <see cref = "F:PInvoke.User32.WindowMessage.WM_PAINT"/> message.
            Each call to BeginPaint must have a corresponding call to the <see cref = "M:PInvoke.User32.EndPaint(System.IntPtr,PInvoke.User32.PAINTSTRUCT*)"/> function.
            </para>
            <para>
            If the caret is in the area to be painted, BeginPaint automatically hides the caret to prevent it from being erased.
            If the window's class has a background brush, BeginPaint uses that brush to erase the background of the update region before returning.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.BeginPaint_IntPtr(System.IntPtr,PInvoke.User32.PAINTSTRUCT@)">
            <summary>
            The BeginPaint function prepares the specified window for painting and fills a <see cref = "T:PInvoke.User32.PAINTSTRUCT"/> structure with information about the painting.
            </summary>
            <param name = "hwnd">Handle to the window to be repainted.</param>
            <param name = "lpPaint">Pointer to the <see cref = "T:PInvoke.User32.PAINTSTRUCT"/> structure that will receive painting information.</param>
            <returns>
            If the function succeeds, the return value is the handle to a display device context for the specified window.
            If the function fails, the return value is <see cref = "F:System.IntPtr.Zero"/>, indicating that no display device context is available..</returns>
            <remarks>
            <para>
            The BeginPaint function automatically sets the clipping region of the device context to exclude any area outside the update region.
            The update region is set by the InvalidateRect or InvalidateRgn function and by the system after sizing, moving, creating, scrolling,
            or any other operation that affects the client area. If the update region is marked for erasing, BeginPaint sends a <see cref = "F:PInvoke.User32.WindowMessage.WM_ERASEBKGND"/> message to the window.
            </para>
            <para>
            An application should not call BeginPaint except in response to a <see cref = "F:PInvoke.User32.WindowMessage.WM_PAINT"/> message.
            Each call to BeginPaint must have a corresponding call to the <see cref = "M:PInvoke.User32.EndPaint(System.IntPtr,PInvoke.User32.PAINTSTRUCT*)"/> function.
            </para>
            <para>
            If the caret is in the area to be painted, BeginPaint automatically hides the caret to prevent it from being erased.
            If the window's class has a background brush, BeginPaint uses that brush to erase the background of the update region before returning.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.CreateWindowEx(PInvoke.User32.WindowStylesEx,System.IntPtr,System.String,PInvoke.User32.WindowStyles,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Creates an overlapped, pop-up, or child window with an
            extended window style; otherwise, this function is identical to the CreateWindow function.
            </summary>
            <param name = "dwExStyle">Specifies the extended window style of the window being created.</param>
            <param name = "lpClassName">
            Pointer to a class atom created by a previous call to the
            RegisterClass or RegisterClassEx function. The atom must be in the low-order word of
            lpClassName; the high-order word must be zero.
            </param>
            <param name = "lpWindowName">
            Pointer to a null-terminated string that specifies the window name. If the window style
            specifies a title bar, the window title pointed to by lpWindowName is displayed in the
            title bar. When using CreateWindow to create controls, such as buttons, check boxes, and
            static controls, use lpWindowName to specify the text of the control. When creating a
            static control with the SS_ICON style, use lpWindowName to specify the icon name or
            identifier. To specify an identifier, use the syntax "#num".
            </param>
            <param name = "dwStyle">
            Specifies the style of the window being created. This parameter can be a combination of
            window styles, plus the control styles indicated in the Remarks section.
            </param>
            <param name = "x">
            Specifies the initial horizontal position of the window. For an overlapped or pop-up
            window, the x parameter is the initial x-coordinate of the window's upper-left corner, in
            screen coordinates. For a child window, x is the x-coordinate of the upper-left corner of
            the window relative to the upper-left corner of the parent window's client area. If x is
            set to CW_USEDEFAULT, the system selects the default position for the window's upper-left
            corner and ignores the y parameter. CW_USEDEFAULT is valid only for overlapped windows;
            if it is specified for a pop-up or child window, the x and y parameters are set to zero.
            </param>
            <param name = "y">
            Specifies the initial vertical position of the window. For an overlapped or pop-up
            window, the y parameter is the initial y-coordinate of the window's upper-left corner, in
            screen coordinates. For a child window, y is the initial y-coordinate of the upper-left
            corner of the child window relative to the upper-left corner of the parent window's
            client area. For a list box y is the initial y-coordinate of the upper-left corner of the
            list box's client area relative to the upper-left corner of the parent window's client area.
            <para>
            If an overlapped window is created with the WS_VISIBLE style bit set and the x parameter
            is set to CW_USEDEFAULT, then the y parameter determines how the window is shown. If the
            y parameter is CW_USEDEFAULT, then the window manager calls ShowWindow with the SW_SHOW
            flag after the window has been created. If the y parameter is some other value, then the
            window manager calls ShowWindow with that value as the nCmdShow parameter.
            </para>
            </param>
            <param name = "nWidth">
            Specifies the width, in device units, of the window. For overlapped windows, nWidth is
            the window's width, in screen coordinates, or CW_USEDEFAULT. If nWidth is CW_USEDEFAULT,
            the system selects a default width and height for the window; the default width extends
            from the initial x-coordinates to the right edge of the screen; the default height
            extends from the initial y-coordinate to the top of the icon area. CW_USEDEFAULT is valid
            only for overlapped windows; if CW_USEDEFAULT is specified for a pop-up or child window,
            the nWidth and nHeight parameter are set to zero.
            </param>
            <param name = "nHeight">
            Specifies the height, in device units, of the window. For overlapped windows, nHeight is
            the window's height, in screen coordinates. If the nWidth parameter is set to
            CW_USEDEFAULT, the system ignores nHeight.
            </param>
            <param name = "hWndParent">
            Handle to the parent or owner window of the window being created. To create a child
            window or an owned window, supply a valid window handle. This parameter is optional for
            pop-up windows.
            <para>
            Windows 2000/XP: To create a message-only window, supply HWND_MESSAGE or a handle to an
            existing message-only window.
            </para>
            </param>
            <param name = "hMenu">
            Handle to a menu, or specifies a child-window identifier, depending on the window style.
            For an overlapped or pop-up window, hMenu identifies the menu to be used with the window;
            it can be NULL if the class menu is to be used. For a child window, hMenu specifies the
            child-window identifier, an integer value used by a dialog box control to notify its
            parent about events. The application determines the child-window identifier; it must be
            unique for all child windows with the same parent window.
            </param>
            <param name = "hInstance">
            Handle to the instance of the module to be associated with the window.
            </param>
            <param name = "lpParam">
            Pointer to a value to be passed to the window through the CREATESTRUCT structure
            (lpCreateParams member) pointed to by the lParam param of the WM_CREATE message. This
            message is sent to the created window by this function before it returns.
            <para>
            If an application calls CreateWindow to create a MDI client window, lpParam should point
            to a CLIENTCREATESTRUCT structure. If an MDI client window calls CreateWindow to create
            an MDI child window, lpParam should point to a MDICREATESTRUCT structure. lpParam may be
            NULL if no additional data is needed.
            </para>
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the new window.
            <para>
            If the function fails, the return value is NULL. To get extended error information, call GetLastError.
            </para>
            <para>This function typically fails for one of the following reasons:</para>
            <list type = "">
            <item>an invalid parameter value</item>
            <item>the system class was registered by a different module</item>
            <item>The WH_CBT hook is installed and returns a failure code</item>
            <item>
            if one of the controls in the dialog template is not registered, or its window window
            procedure fails WM_CREATE or WM_NCCREATE
            </item>
            </list>
            </returns>
        </member>
        <member name="M:PInvoke.User32.SetWindowLongPtr64(System.IntPtr,PInvoke.User32.WindowLongIndexFlags,System.IntPtr)">
            <summary>
            Changes an attribute of the specified window. The function also sets a value at the specified
            offset in the extra window memory.
            </summary>
            <param name = "hWnd">A handle to the window and, indirectly, the class to which the window belongs.</param>
            <param name = "nIndex">The zero-based offset to the value to be set.</param>
            <param name = "dwNewLong">The replacement value.</param>
            <returns>
            <para>If the function succeeds, the return value is the previous value of the specified offset.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            <para>If the previous value is zero and the function succeeds, the return value is zero, but the function does
            not clear the last error information. To determine success or failure, clear the last error information by
            calling SetLastError with 0, then call SetWindowLongPtr. Function failure will be indicated by a return value of
            zero and a GetLastError result that is nonzero.</para>
            </returns>
            <remarks>
            When compiling for 32-bit Windows, SetWindowLongPtr is defined as a call to the SetWindowLong function. This
            function is exposed using a helper that conditionally calls SetWindowLong in 32-bit processes.
            </remarks>
        </member>
        <member name="M:PInvoke.User32.BeginPaint(System.IntPtr,System.IntPtr)">
            <summary>
            The BeginPaint function prepares the specified window for painting and fills a <see cref = "T:PInvoke.User32.PAINTSTRUCT"/> structure with information about the painting.
            </summary>
            <param name = "hwnd">Handle to the window to be repainted.</param>
            <param name = "lpPaint">Pointer to the <see cref = "T:PInvoke.User32.PAINTSTRUCT"/> structure that will receive painting information.</param>
            <returns>
            If the function succeeds, the return value is the handle to a display device context for the specified window.
            If the function fails, the return value is <see cref = "F:PInvoke.User32.SafeDCHandle.Null"/>, indicating that no display device context is available..</returns>
            <remarks>
            <para>
            The BeginPaint function automatically sets the clipping region of the device context to exclude any area outside the update region.
            The update region is set by the InvalidateRect or InvalidateRgn function and by the system after sizing, moving, creating, scrolling,
            or any other operation that affects the client area. If the update region is marked for erasing, BeginPaint sends a <see cref = "F:PInvoke.User32.WindowMessage.WM_ERASEBKGND"/> message to the window.
            </para>
            <para>
            An application should not call BeginPaint except in response to a <see cref = "F:PInvoke.User32.WindowMessage.WM_PAINT"/> message.
            Each call to BeginPaint must have a corresponding call to the <see cref = "M:PInvoke.User32.EndPaint(System.IntPtr,PInvoke.User32.PAINTSTRUCT*)"/> function.
            </para>
            <para>
            If the caret is in the area to be painted, BeginPaint automatically hides the caret to prevent it from being erased.
            If the window's class has a background brush, BeginPaint uses that brush to erase the background of the update region before returning.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.BeginPaint(System.IntPtr,PInvoke.User32.PAINTSTRUCT@)">
            <summary>
            The BeginPaint function prepares the specified window for painting and fills a <see cref = "T:PInvoke.User32.PAINTSTRUCT"/> structure with information about the painting.
            </summary>
            <param name = "hwnd">Handle to the window to be repainted.</param>
            <param name = "lpPaint">Pointer to the <see cref = "T:PInvoke.User32.PAINTSTRUCT"/> structure that will receive painting information.</param>
            <returns>
            If the function succeeds, the return value is the handle to a display device context for the specified window.
            If the function fails, the return value is <see cref = "F:PInvoke.User32.SafeDCHandle.Null"/>, indicating that no display device context is available..</returns>
            <remarks>
            <para>
            The BeginPaint function automatically sets the clipping region of the device context to exclude any area outside the update region.
            The update region is set by the InvalidateRect or InvalidateRgn function and by the system after sizing, moving, creating, scrolling,
            or any other operation that affects the client area. If the update region is marked for erasing, BeginPaint sends a <see cref = "F:PInvoke.User32.WindowMessage.WM_ERASEBKGND"/> message to the window.
            </para>
            <para>
            An application should not call BeginPaint except in response to a <see cref = "F:PInvoke.User32.WindowMessage.WM_PAINT"/> message.
            Each call to BeginPaint must have a corresponding call to the <see cref = "M:PInvoke.User32.EndPaint(System.IntPtr,PInvoke.User32.PAINTSTRUCT*)"/> function.
            </para>
            <para>
            If the caret is in the area to be painted, BeginPaint automatically hides the caret to prevent it from being erased.
            If the window's class has a background brush, BeginPaint uses that brush to erase the background of the update region before returning.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.User32.CreateWindow(System.String,System.String,PInvoke.User32.WindowStyles,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            The CreateWindow is identical to the CreateWindowEx function, actually it is a macro on C/C++
            </summary>
            <param name = "lpClassName">
            Pointer to a null-terminated string or a class atom created by a previous call to the
            RegisterClass or RegisterClassEx function. The atom must be in the low-order word of
            lpClassName; the high-order word must be zero. If lpClassName is a string, it specifies
            the window class name. The class name can be any name registered with RegisterClass or
            RegisterClassEx, provided that the module that registers the class is also the module
            that creates the window. The class name can also be any of the predefined system class names.
            </param>
            <param name = "lpWindowName">
            Pointer to a null-terminated string that specifies the window name. If the window style
            specifies a title bar, the window title pointed to by lpWindowName is displayed in the
            title bar. When using CreateWindow to create controls, such as buttons, check boxes, and
            static controls, use lpWindowName to specify the text of the control. When creating a
            static control with the SS_ICON style, use lpWindowName to specify the icon name or
            identifier. To specify an identifier, use the syntax "#num".
            </param>
            <param name = "dwStyle">
            Specifies the style of the window being created. This parameter can be a combination of
            window styles, plus the control styles indicated in the Remarks section.
            </param>
            <param name = "x">
            Specifies the initial horizontal position of the window. For an overlapped or pop-up
            window, the x parameter is the initial x-coordinate of the window's upper-left corner, in
            screen coordinates. For a child window, x is the x-coordinate of the upper-left corner of
            the window relative to the upper-left corner of the parent window's client area. If x is
            set to CW_USEDEFAULT, the system selects the default position for the window's upper-left
            corner and ignores the y parameter. CW_USEDEFAULT is valid only for overlapped windows;
            if it is specified for a pop-up or child window, the x and y parameters are set to zero.
            </param>
            <param name = "y">
            Specifies the initial vertical position of the window. For an overlapped or pop-up
            window, the y parameter is the initial y-coordinate of the window's upper-left corner, in
            screen coordinates. For a child window, y is the initial y-coordinate of the upper-left
            corner of the child window relative to the upper-left corner of the parent window's
            client area. For a list box y is the initial y-coordinate of the upper-left corner of the
            list box's client area relative to the upper-left corner of the parent window's client area.
            <para>
            If an overlapped window is created with the WS_VISIBLE style bit set and the x parameter
            is set to CW_USEDEFAULT, then the y parameter determines how the window is shown. If the
            y parameter is CW_USEDEFAULT, then the window manager calls ShowWindow with the SW_SHOW
            flag after the window has been created. If the y parameter is some other value, then the
            window manager calls ShowWindow with that value as the nCmdShow parameter.
            </para>
            </param>
            <param name = "nWidth">
            Specifies the width, in device units, of the window. For overlapped windows, nWidth is
            the window's width, in screen coordinates, or CW_USEDEFAULT. If nWidth is CW_USEDEFAULT,
            the system selects a default width and height for the window; the default width extends
            from the initial x-coordinates to the right edge of the screen; the default height
            extends from the initial y-coordinate to the top of the icon area. CW_USEDEFAULT is valid
            only for overlapped windows; if CW_USEDEFAULT is specified for a pop-up or child window,
            the nWidth and nHeight parameter are set to zero.
            </param>
            <param name = "nHeight">
            Specifies the height, in device units, of the window. For overlapped windows, nHeight is
            the window's height, in screen coordinates. If the nWidth parameter is set to
            CW_USEDEFAULT, the system ignores nHeight.
            </param>
            <param name = "hWndParent">
            Handle to the parent or owner window of the window being created. To create a child
            window or an owned window, supply a valid window handle. This parameter is optional for
            pop-up windows.
            <para>
            Windows 2000/XP: To create a message-only window, supply HWND_MESSAGE or a handle to an
            existing message-only window.
            </para>
            </param>
            <param name = "hMenu">
            Handle to a menu, or specifies a child-window identifier, depending on the window style.
            For an overlapped or pop-up window, hMenu identifies the menu to be used with the window;
            it can be NULL if the class menu is to be used. For a child window, hMenu specifies the
            child-window identifier, an integer value used by a dialog box control to notify its
            parent about events. The application determines the child-window identifier; it must be
            unique for all child windows with the same parent window.
            </param>
            <param name = "hInstance">
            Handle to the instance of the module to be associated with the window.
            </param>
            <param name = "lpParam">
            Pointer to a value to be passed to the window through the CREATESTRUCT structure
            (lpCreateParams member) pointed to by the lParam param of the WM_CREATE message. This
            message is sent to the created window by this function before it returns.
            <para>
            If an application calls CreateWindow to create a MDI client window, lpParam should point
            to a CLIENTCREATESTRUCT structure. If an MDI client window calls CreateWindow to create
            an MDI child window, lpParam should point to a MDICREATESTRUCT structure. lpParam may be
            NULL if no additional data is needed.
            </para>
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the new window.
            <para>
            If the function fails, the return value is NULL. To get extended error information, call GetLastError.
            </para>
            <para>This function typically fails for one of the following reasons:</para>
            <list type = "">
            <item>an invalid parameter value</item>
            <item>the system class was registered by a different module</item>
            <item>The WH_CBT hook is installed and returns a failure code</item>
            <item>
            if one of the controls in the dialog template is not registered, or its window window
            procedure fails WM_CREATE or WM_NCCREATE
            </item>
            </list>
            </returns>
        </member>
        <member name="M:PInvoke.User32.SetWindowLongPtr(System.IntPtr,PInvoke.User32.WindowLongIndexFlags,System.IntPtr)">
             <summary>
             Changes an attribute of the specified window. The function also sets a value at the specified
             offset in the extra window memory.
             </summary>
             <param name = "hWnd">A handle to the window and, indirectly, the class to which the window belongs.
             The SetWindowLongPtr function fails if the process that owns the window specified by the
             <paramref name = "hWnd"/> parameter is at a higher process privilege in the UIPI hierarchy than the
             process the calling thread resides in.</param>
             <param name = "nIndex">The zero-based offset to the value to be set. Valid values are in the range zero
             through the number of bytes of extra window memory, minus the size of a LONG_PTR. To set any other value,
             specify one of the following values.
            
             <list type = "table">
             <listheader><term>Value</term><term>Meaning</term></listheader>
             <item><term>GWL_EXSTYLE(-20)</term><term>Sets a new extended window style.</term></item>
             <item><term>GWLP_HINSTANCE(-6)</term><term>Sets a new application instance handle.</term></item>
             <item><term>GWLP_ID(-12)</term><term>Sets a new identifier of the child window.The window cannot be a top-level window.</term></item>
             <item><term>GWL_STYLE (-16)</term><term>Sets a new window style.</term></item>
             <item><term>GWLP_USERDATA</term><term>Sets the user data associated with the window.This data is intended for use by the application that created the window. Its value is initially zero.</term></item>
             <item><term>GWLP_WNDPROC (-4)</term><term>Sets a new address for the window procedure.</term></item>
             </list>
            
             The following values are also available when the hWnd parameter identifies a dialog box.
            
             <list type = "table">
             <listheader><term>Value</term><term>Meaning</term></listheader>
             <item><term>DWLP_DLGPROC (DWLP_MSGRESULT + sizeof(LRESULT))</term><term>Sets the new pointer to the dialog box procedure.</term></item>
             <item><term>DWLP_MSGRESULT (0)</term><term>Sets the return value of a message processed in the dialog box procedure.</term></item>
             <item><term>DWLP_USER (DWLP_DLGPROC + sizeof(DLGPROC))</term><term>Sets new extra info</term></item>
             </list>
            
             </param>
             <param name = "dwNewLong">The replacement value.</param>
             <returns>
             <para>If the function succeeds, the return value is the previous value of the specified offset.</para>
             <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
             <para>If the previous value is zero and the function succeeds, the return value is zero, but the function does
             not clear the last error information. To determine success or failure, clear the last error information by
             calling SetLastError with 0, then call SetWindowLongPtr. Function failure will be indicated by a return value of
             zero and a GetLastError result that is nonzero.</para>
             </returns>
             <remarks>
             <list type = "bullet">
             <item>The return type, and the type of <paramref name = "dwNewLong"/> are both LONG_PTR.
             LONG_PTR is defined as <code>__int64</code> on 64-bit platforms, and it is defined as <code>long</code>
             on 32-bit platforms. This definition fits nicely with now <see cref = "T:System.IntPtr"/> works on 32-bit vs. 64-bit
             platforms.</item>
             <item>Windows XP/2000: The SetWindowLongPtr function fails if the window specified by the
             <paramref name = "hWnd"/> parameter does not belong to the same process as the calling thread.</item>
             <item>When compiling for 32-bit Windows, SetWindowLongPtr is defined as a call to the SetWindowLong function.</item>
             <item>
             <para>Certain window data is cached, so changes you make using SetWindowLongPtr will not take effect until you call
             the SetWindowPos function.</para>
             <para>If you use SetWindowLongPtr with the <see cref = "F:PInvoke.User32.WindowLongIndexFlags.GWLP_WNDPROC"/> index to replace the window procedure,
             the window procedure must conform to the guidelines specified in the description of the WindowProc callback function.</para>
             <para>If you use SetWindowLongPtr with the <see cref = "F:PInvoke.User32.WindowLongIndexFlags.DWLP_MSGRESULT"/> index to set the return value for a
             message processed by a dialog box procedure, the dialog box procedure should return TRUE directly afterward. Otherwise, if you call
             any function that results in your dialog box procedure receiving a window message, the nested window message could overwrite the return value
             you set by using <see cref = "F:PInvoke.User32.WindowLongIndexFlags.DWLP_MSGRESULT"/>.</para>
             <para>Calling SetWindowLongPtr with the <see cref = "F:PInvoke.User32.WindowLongIndexFlags.GWLP_WNDPROC"/> index creates a subclass of the window
             class used to create the window. An application can subclass a system class, but should not subclass a window class created by another process.
             The SetWindowLongPtr function creates the window subclass by changing the window procedure associated with a particular
             window class, causing the system to call the new window procedure instead of the previous one. An application must pass
             any messages not processed by the new window procedure to the previous window procedure by calling CallWindowProc.
             This allows the application to create a chain of window procedures.</para>
             <para>Reserve extra window memory by specifying a nonzero value in the <see cref = "F:PInvoke.User32.WNDCLASSEX.cbWndExtra"/> member of the
             <see cref = "T:PInvoke.User32.WNDCLASSEX"/> structure used with the RegisterClassEx function.</para>
             <para>Do not call SetWindowLongPtr with the <see cref = "F:PInvoke.User32.WindowLongIndexFlags.GWLP_HWNDPARENT"/> index to change the parent of a
             child window. Instead, use the SetParent function.</para>
             <para>If the window has a class style of <see cref = "F:PInvoke.User32.ClassStyles.CS_CLASSDC"/> or <see cref = "F:PInvoke.User32.ClassStyles.CS_PARENTDC"/>, do not set
             the extended window styles <see cref = "F:PInvoke.User32.WindowStylesEx.WS_EX_COMPOSITED"/> or <see cref = "F:PInvoke.User32.WindowStylesEx.WS_EX_LAYERED"/>.</para>
             <para>Calling SetWindowLongPtr to set the style on a progressbar will reset its position.</para>
             </item>
             </list>
             </remarks>
        </member>
    </members>
</doc>
